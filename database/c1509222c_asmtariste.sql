-- phpMyAdmin SQL Dump
-- version 5.2.1
-- https://www.phpmyadmin.net/
--
-- Hôte : localhost:3306
-- Généré le : lun. 19 août 2024 à 00:57
-- Version du serveur : 10.6.17-MariaDB-cll-lve
-- Version de PHP : 8.1.26

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Base de données : `c1509222c_asmtariste`
--

-- --------------------------------------------------------

--
-- Structure de la table `articles`
--

CREATE TABLE `articles` (
  `id_articles` int(11) NOT NULL,
  `title` varchar(128) DEFAULT NULL,
  `creation_date` date DEFAULT NULL,
  `description` mediumtext DEFAULT NULL,
  `cover` varchar(128) DEFAULT NULL,
  `isDisplay` tinyint(1) DEFAULT NULL,
  `id_categories` int(11) NOT NULL,
  `id_users` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `articles`
--

INSERT INTO `articles` (`id_articles`, `title`, `creation_date`, `description`, `cover`, `isDisplay`, `id_categories`, `id_users`) VALUES
(1, 'ASMtariSTe est ouvert !', '2024-06-27', 'ASMtariste ouvre ses portes pour tout ceux qui souhaitent apprendre la programmation en assembleur 68000 sur Atari ST. ', '1720686646713.png', 1, 2, 1),
(2, 'À propos du BIOS', '2024-06-27', 'Le BIOS (Basic Input/Output System) représente l\'interface de plus bas niveau entre le système d\'exploitation de l\'Atari et le matériel, et est appelé via le Trap #13 du 680X0. Il est préférable que ces fonctions ne soient pas utilisées par les programmes applicatifs, car des fonctions beaucoup plus puissantes à un niveau supérieur sont disponibles pour fournir de meilleures alternatives.', '1720686675098.jpg', 1, 3, 1),
(3, 'Le Système d\'Exploitation TOS', '2024-06-27', 'Le système d\'exploitation TOS (The Operating System) peut être subdivisé en différentes sections. La communication avec les utilisateurs est réalisée via GEM, qui offre une interface utilisateur confortable et se compose des fonctions AES et VDI.', '1720686675098.jpg', 1, 3, 1),
(4, 'Savoir configurer les outils de développement - Partie 1', '2024-06-27', 'Avant toute chose, pour commencer à écrire du code, tu auras besoin de plusieurs outils et il te faudra apprendre à les utiliser. Ces outils peuvent être soit sur PC, soit directement sur Atari ST.', '1719526785197.png', 1, 1, 1),
(5, 'L\'octet sous toutes ses formes', '2024-07-20', 'La maîtrise des conversions entre les systèmes décimal, binaire et hexadécimal est cruciale pour comprendre et manipuler les données en informatique. Nous reviendrons sur ces concepts pour démontrer leurs avantages dans divers contextes. Nous parlerons ici des différentes façons d\'écrire la valeur d\'un octet. Sans connaissance à ce sujet, vous n\'irez pas très loin dans votre apprentissage de l\'assembleur.', '1721474650895.webp', 1, 1, 1),
(6, 'Miracle Boy in Dragon Land : Le projet d\'un passionné sur Atari ST', '2024-07-22', 'Le projet Miracle Boy in Dragon Land a officiellement débuté à la mi-août 2022, avec l\'ambition de créer un jeu en assembleur 68000 pour Atari ST. Samuel Blanchard, l\'initiateur du projet, a rapidement rassemblé une communauté de 302 membres passionnés qui suivent avec enthousiasme ce jeu prometteur, qui s\'annonce être une véritable pépite pour les fans de rétro-gaming sur Atari ST.', '1721664001193.png', 1, 2, 1),
(7, 'Messages d\'erreur du BIOS & GEMDOS', '2024-07-22', 'Les erreurs sont signalées par le BIOS et le XBIOS sous forme de valeurs négatives. Les erreurs sont signalées par GEMDOS sous forme de valeurs LONGUES négatives. La liste suivante contient tous les messages d\'erreur connus.', '1721671688947.jpg', 1, 3, 1),
(8, 'Savoir configurer les outils de développement - Partie 2', '2024-07-25', 'Après une première partie qui concernait principalement l\'environnement de travail lié à l\'utilisation de l\'émulateur, je vais te guider pour apprendre à installer le logiciel Hisoft DevPac 3. Mais aussi le configurer un minimum avec le GEM pour avoir un outils rapide et érgonomique.', '1721929777601.jpg', 1, 1, 1),
(9, 'Créer un disque dur virtuel  ou \"RAM Disk\"', '2024-07-26', 'Vous avez probablement un Atari chez vous avec un lecteur de disquette (ou un Gotek en remplacement), mais sans disque dur ni Ultra Satan. C\'est dommage car ces périphériques ont l\'avantage d\'être bien plus rapides que les supports disquettes. Si c\'est pour un besoin ponctuel, vous pouvez créer un espace mémoire dans la RAM, où vous pourrez stocker vos fichiers sur lesquels vous désirez travailler, comme si c\'était un disque dur. On appelle cela un RAM Disk.', '1722027028454.png', 1, 4, 1),
(10, 'La RAM et la ROM', '2024-07-27', 'Précédemment, nous avons parlé des octets qui sont stockés dans la RAM (mémoire vive), où le 68000 peut aller lire ces données temporaires. Cependant, il peut aussi aller lire dans la ROM (mémoire morte), qui, contrairement à la RAM, contient des données permanentes.', '1722072708519.png', 1, 1, 1),
(11, 'Les registres du 68000', '2024-07-27', 'On y est ! Tu vas pouvoir commencer à taper tes premières lignes de code en assembleur et, pour cela, je vais t\'apprendre à manipuler des données. Nous allons beaucoup utiliser le débogueur Monst que DevPac nous offre, car tu pourras concrètement voir sous tes yeux les données se transformer et se déplacer en suivant ton programme pas à pas.', '1722101341272.png', 1, 1, 1),
(12, 'Les modes d\'adressage du 68000', '2024-07-30', 'Maintenant que vous vous êtes familiarisé avec les différents Registres du 68000, je vais définir les différents MODES D\'ADRESSAGE.\r\n\r\nLes modes d\'adressage permettent de modifier les valeurs du PC, du SP, du SR et la pile système.\r\n\r\nJe prendrai les instructions MOVE (permet de déplacer l\'opérande source jusqu\'à l\'opérande destination) et ADD (ajoute l\'opérande source à son opérande destination) pour illustrer les différents types de modes d\'adressage.', '1722345975616.jpg', 1, 3, 1),
(13, 'Capture et conversion d\'image NEO, PI1 et PC1', '2024-08-01', 'Certaines manipulations comme celle-ci sur du matériel réel auraient nécessité l\'utilisation de l\'Ultimate Ripper, un matériel très rare à trouver de nos jours. Heureusement, les émulateurs simplifient cette partie du travail, même si certains outils purement ST restent encore très utiles. \r\nLa finalité est de pouvoir utiliser ces images dans vos productions.', '1722513288165.png', 1, 4, 1),
(14, 'Afficher une image', '2024-08-02', 'On y est enfin ! Ce n\'était pas trop tôt, mais il fallait s\'assurer que vous ayez les prérequis avant de commencer votre premier programme en assembleur. Cette étape est importante car nous allons également apprendre à structurer un programme. En parlant de prérequis, assurez-vous de savoir utiliser des outils tels que Deluxe Paint par exemple. Si ce n\'est pas le cas, allez jeter un œil dans la section tutoriel \"Capture et conversion d\'image NEO, PI1 et PC1\".', '1722549828686.webp', 1, 1, 1),
(15, 'À propos du XBIOS (Fonctions de l\'écran)', '2024-08-03', 'Ses fonctions permettent un accès aux diverses puces spéciales de l\'Atari. Elles sont appelées via le trap 680X0 numéro 14 et ne doivent être utilisées que si aucune routine de niveau supérieur (GEMDOS, BIOS) n\'est disponible pour les remplacer.', '1722640009122.jpg', 1, 3, 1),
(16, 'À propos du GEMDOS (Fonctions de fichier)', '2024-08-05', 'Le GEMDOS est, en dehors du BIOS et XBIOS dépendants du matériel, le véritable système d\'exploitation de l\'Atari, et ses fonctions constituent le niveau le plus élevé du TOS. Les fonctions sont appelées via le Trap #1 du 680X0. Les fonctions du système d\'exploitation peuvent être facilement divisées en catégories par la première lettre du nom de la fonction.', '1722846752008.jpg', 1, 3, 1),
(17, 'Créer une planche de sprites avec Multipaint', '2024-08-06', 'C\'est après avoir effectué de multiples tests avec Deluxe Paint, OCP Art Studio, et même Néochrome, des logiciels de référence à l\'époque de l\'Atari ST, que j\'ai dû me résoudre à abandonner l\'idée de créer une planche de sprites avec ces logiciels. Ils étaient soit incomplets (Deluxe Paint), soit anti-ergonomiques (OCP Art Studio). Nous allons donc utiliser ce bon vieux Multipaint !', '1722945267466.webp', 1, 4, 1),
(18, 'Afficher un sprite - Partie 1', '2024-08-09', 'Si tu es arrivé à ce cours, c\'est que tu es à l\'aise avec les registres et les instructions telles que move, add, trap, dbf/label, beq/rts. De plus, tu maîtrises bien les directives d\'assemblage comme SECTION TEXT/DATA, EQU, REPT/ENDR. Si tout cela te semble du chinois, alors tu n\'as rien à faire ici. Fais demi-tour et consulte les cours précédents.', '1723196287493.png', 1, 1, 1),
(19, 'DevPac v3.10 - Les raccourcis clavier', '2024-08-11', 'Ce n\'est pas une chose simple de se rappeler de tous les raccourcis clavier de DevPac, donc voici un petit mémo qui à pour vocation d\'être le plus  exhaustif possible. S\'il en manque n\'hésitez pas à me le signaler.', '1723378647520.jpg', 1, 3, 1),
(20, 'À propos du GEMDOS (Date et heure)', '2024-08-11', 'Le GEMDOS est, en dehors du BIOS et XBIOS dépendants du matériel, le véritable système d\'exploitation de l\'Atari, et ses fonctions constituent le niveau le plus élevé du TOS. Les fonctions sont appelées via le Trap #1 du 680X0. Les fonctions du système d\'exploitation peuvent être facilement divisées en catégories par la première lettre du nom de la fonction.', '1723394869187.jpg', 1, 3, 1),
(21, 'Masquage de sprite', '2024-08-13', 'On aborde le masquage de sprites en utilisant des opérations logiques, principalement le AND et le OR, pour manipuler les pixels d’un sprite de manière à le rendre transparent sur un fond, évitant ainsi d\'afficher les pixels indésirables qui entourent le sprite.', '1723563955482.png', 1, 1, 1),
(24, 'Déplacer un sprite - Partie 1', '2024-08-19', 'Petit à petit, l\'oiseau fait son nid ! Eh oui, normalement, tu sais déjà afficher une image et un sprite masqué. Mais c\'est beaucoup plus amusant de pouvoir le déplacer à l\'écran ! Je vais donc t\'expliquer des concepts propres à quasiment tous les jeux vidéo de cette époque, sur des machines qui ne disposaient pas de hardware tel que des sprites matériels !', '1724021146993.png', 0, 1, 1);

-- --------------------------------------------------------

--
-- Structure de la table `categories`
--

CREATE TABLE `categories` (
  `id_categories` int(11) NOT NULL,
  `name` varchar(50) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `categories`
--

INSERT INTO `categories` (`id_categories`, `name`) VALUES
(1, 'coding'),
(2, 'news'),
(3, 'doc'),
(4, 'tuto');

-- --------------------------------------------------------

--
-- Structure de la table `certificates`
--

CREATE TABLE `certificates` (
  `id_certificates` int(11) NOT NULL,
  `creationDate` date DEFAULT NULL,
  `note` tinyint(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `certificates`
--

INSERT INTO `certificates` (`id_certificates`, `creationDate`, `note`) VALUES
(8, '2024-07-16', 20),
(9, '2024-07-16', 20),
(10, '2024-07-19', 16),
(11, '2024-07-22', 20),
(12, '2024-07-22', 20),
(15, '2024-07-25', 20),
(16, '2024-07-27', 20),
(17, '2024-07-28', 20),
(18, '2024-07-28', 18),
(20, '2024-07-29', 18),
(21, '2024-08-01', 16),
(22, '2024-08-01', 17),
(23, '2024-08-01', 16),
(24, '2024-08-01', 20),
(25, '2024-08-01', 20),
(27, '2024-08-02', 20),
(29, '2024-08-10', 17),
(30, '2024-08-11', 20),
(31, '2024-08-11', 15),
(32, '2024-08-11', 17),
(33, '2024-08-11', 14),
(34, '2024-08-11', 14),
(35, '2024-08-11', 20),
(36, '2024-08-11', 16),
(38, '2024-08-12', 18),
(39, '2024-08-12', 20),
(40, '2024-08-12', 20),
(41, '2024-08-12', 20),
(42, '2024-08-12', 20),
(43, '2024-08-12', 20),
(44, '2024-08-12', 16),
(45, '2024-08-13', 16),
(46, '2024-08-13', 13),
(50, '2024-08-14', 20),
(51, '2024-08-14', 20),
(52, '2024-08-14', 20),
(53, '2024-08-14', 20),
(54, '2024-08-15', 20),
(55, '2024-08-16', 20),
(56, '2024-08-16', 20),
(57, '2024-08-17', 20),
(58, '2024-08-17', 14),
(59, '2024-08-17', 15);

-- --------------------------------------------------------

--
-- Structure de la table `choices`
--

CREATE TABLE `choices` (
  `id_choices` int(11) NOT NULL,
  `choice_name` varchar(256) DEFAULT NULL,
  `answer` tinyint(1) DEFAULT NULL,
  `id_questions` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `choices`
--

INSERT INTO `choices` (`id_choices`, `choice_name`, `answer`, `id_questions`) VALUES
(1, 'Un logiciel qui imite le fonctionnement d\'un autre', 1, 1),
(2, 'Un programme de traitement de texte', 0, 1),
(3, 'Un outil de gestion de fichiers', 0, 1),
(4, 'Stocker des fichiers dans la RAM', 0, 2),
(5, 'Augmenter la capacité de mémoire', 0, 2),
(6, 'A émuler un disque durs avec des cartes SD', 1, 2),
(7, 'Le langage binaire', 1, 3),
(8, 'L\'assembleur', 0, 3),
(9, 'Le langage C', 0, 3),
(10, 'Le langage Basic', 0, 3),
(11, 'Écrire du code source', 1, 4),
(12, 'Compiler des programmes', 0, 4),
(13, 'Déboguer des applications', 0, 4),
(14, 'Traduire du code assembleur en code machine', 1, 5),
(15, 'Optimiser le code source', 0, 5),
(16, 'Interpréter le code source', 0, 5),
(17, 'Dans la mémoire RAM', 0, 6),
(18, 'Dans un fichier exécutable', 1, 6),
(19, 'Dans un fichier texte', 0, 6),
(20, 'Dans la mémoire RAM', 0, 7),
(21, 'Dans un fichier source', 1, 7),
(22, 'Sur un disque dur externe', 0, 7),
(23, 'DavePac', 0, 8),
(24, 'ASM-One', 0, 8),
(25, 'HiSoft DevPac 3', 1, 8),
(26, 'Le bureau EmuTOS', 0, 9),
(27, 'Le bureau GEM', 1, 9),
(28, 'Le bureau TOS', 0, 9),
(29, 'Le système d\'exploitation de l\'Atari ST', 1, 10),
(30, 'Un type de mémoire', 0, 10),
(31, 'The Original System', 0, 10),
(32, 'Un type de périphérique de stockage', 0, 11),
(33, 'Un protocole de communication', 1, 11),
(34, 'Une carte graphique', 0, 11),
(35, '203', 1, 12),
(36, '191', 0, 12),
(37, '196', 0, 12),
(38, '178', 0, 12),
(39, '$4F', 0, 13),
(40, '$4B', 1, 13),
(41, '$6B', 0, 13),
(42, '$5B', 0, 13),
(43, '%10010011', 0, 14),
(44, '%11000011', 0, 14),
(45, '%10100001', 0, 14),
(46, '%10100011', 1, 14),
(47, '192', 0, 15),
(48, '128', 0, 15),
(49, '224', 1, 15),
(50, '240', 0, 15),
(51, '64', 0, 16),
(52, '128', 1, 16),
(53, '32', 0, 16),
(54, '16', 0, 16),
(55, '%00000101', 1, 17),
(56, '%00001010', 0, 17),
(57, '%00001111', 0, 17),
(58, '%00000000', 0, 17),
(59, '$FE', 0, 18),
(60, '$FF', 1, 18),
(61, '$F0', 0, 18),
(62, '$00', 0, 18),
(63, '%10100111', 1, 19),
(64, '%10110011', 0, 19),
(65, '%10011111', 0, 19),
(66, '%11010011', 0, 19),
(67, '%0100', 0, 20),
(68, '%1010', 0, 20),
(69, '%1100', 0, 20),
(70, '%0110', 1, 20),
(71, '511', 1, 21),
(72, '255', 0, 21),
(73, '256', 0, 21),
(74, '512', 0, 21),
(75, 'Glisser le fichier zip dans la fenêtre de l\'émulateur', 0, 22),
(76, 'Cliquer une seule fois sur l\'icône qui représente un lecteur de disquette.', 0, 22),
(77, 'Double cliquer sur l\'icône qui représente un lecteur de disquette.', 0, 22),
(78, 'Rien car çà charge tout seul au démarrage, Atari c\'est magique !', 0, 22),
(79, 'Sur une disquette vierge', 0, 23),
(80, 'Sur le disque dure', 1, 23),
(81, 'Dans une RAM disk', 1, 23),
(82, 'Control + Shift + S', 0, 24),
(83, 'Shift + Alternate + S', 1, 24),
(84, 'Alternate + S', 1, 24),
(85, 'Utiliser le pavé numérique dans un autre éditeur de texte avant de revenir à DevPac.', 0, 25),
(86, 'Remplacer les touches défectueuses de l\'Atari ou du PC.', 0, 25),
(87, 'Trouver l\'options à décocher \"Cursor mode numeric keypad\".', 1, 25),
(88, 'Aller dans le menu GEM -> Option -> Installer application.', 1, 26),
(89, 'Modifier les paramètres d\'ouverture automatique dans le menu Options de DevPac.', 0, 26),
(90, 'Ouvrir DevPac, puis utiliser le menu File -> Open pour sélectionner les fichiers sources.', 0, 26),
(91, 'La RAM est volatile et stocke des données temporaires, tandis que la ROM est non-volatile et stocke des données permanentes.', 1, 27),
(92, 'La RAM est volatile et stocke des données permanentes, tandis que la ROM est non-volatile et stocke des données temporaires.', 0, 27),
(93, 'On peut écrire dans la RAM, on ne peut pas écrire dans la ROM.', 1, 27),
(94, '1 Mo, 2 Mo', 1, 28),
(95, '512 Ko, 2,5 Mo, 4 Mo', 1, 28),
(96, '1 Mo, 2 Mo, 3 Mo, 4Mo', 0, 28),
(97, 'Une adresse dans la ROM.', 0, 29),
(98, 'Une adresse dans la RAM.', 1, 29),
(99, 'Une adresse parmis tant d\'autre.', 1, 29),
(100, '512 Ko : $7FFFF, 1 Mo : $0FFFFF, 2 Mo : $1F8000, 4 Mo : $1F8000.', 0, 30),
(101, '512 Ko : $7FFFF, 1 Mo : $0FFFFF, 2 Mo : $1FFFFF, 4 Mo : $3FFFFF.', 1, 30),
(102, '512 Ko : $7FFFF, 1 Mo : $0FFFFF, 2 Mo : $2F8000, 4 Mo : $4F8000.', 0, 30),
(103, 'Juste après les données systemes utilisées par le TOS', 0, 31),
(104, 'Dans la zone de la mémoire morte', 0, 31),
(105, 'En fin de RAM.', 1, 31),
(106, 'Visualiser les données de la RAM sous forme de couleurs.', 1, 32),
(107, 'Modifier les données de la RAM.', 0, 32),
(108, 'Réparer les erreurs dans la RAM.', 0, 32),
(109, 'Utiliser [Shift] + [TAB] pour naviguer entre les fenêtres et [Alt] + [D] pour ouvrir le débogueur.', 0, 33),
(110, 'Utiliser [TAB] pour naviguer entre les fenêtres et [Alt] + [D] pour ouvrir le débogueur.', 1, 33),
(111, 'Utiliser [TAB] pour naviguer entre les fenêtres et [Alt] + [E] pour ouvrir le débogueur.', 0, 33),
(112, 'Cette valeur pointe vers une adresse', 1, 34),
(113, 'Cette valeur affiche le frame buffer ', 0, 34),
(114, 'Cette valeur est un long word', 1, 34),
(115, 'Pour optimiser l\'utilisation des ressources et diagnostiquer les problèmes.', 1, 35),
(116, 'Pour augmenter la capacité de la RAM et améliorer la vitesse du processeur.', 0, 35),
(117, 'T\'as pas d\'autres questions débiles à poser ?.', 0, 35),
(118, 'Les registres de données et les registres d\'adresse', 1, 36),
(119, 'Les registres d\'instructions et les registres de segments', 0, 36),
(120, 'Les registres d\'accumulation et les registres de base', 0, 36),
(121, 'Les registres de données et les registres de segments', 0, 36),
(122, 'add', 0, 37),
(123, 'store', 0, 37),
(124, 'load', 0, 37),
(125, 'move', 1, 37),
(126, 'Les registres de données stockent les entiers, les registres d\'adresse stockent les adresses mémoire', 1, 38),
(127, 'Les registres de données stockent les instructions, les registres d\'adresse stockent les adresses IP', 0, 38),
(128, 'Les registres de données sont plus grands que les registres d\'adresse', 0, 38),
(129, 'Les registres de données sont utilisés pour les opérations arithmétiques et logiques, les registres d\'adresse pour les pointeurs d\'adresse', 1, 38),
(130, 'Des valeurs de 0 à 255', 1, 39),
(131, 'Des valeurs de 0 à 65535', 0, 39),
(132, 'Des valeurs de 0 à 4294967295', 0, 39),
(133, 'Des valeurs de 0 à 127', 1, 39),
(134, 'move.w #548, D0', 0, 40),
(135, 'move.b #548, D0', 1, 40),
(136, 'move.l #548, D0', 0, 40),
(137, 'move #548, D0', 0, 40),
(138, 'C\'est le registre de la pile', 1, 41),
(139, 'C\'est le registre de l\'accumulateur', 0, 41),
(140, 'C\'est le registre stack pointer', 1, 41),
(141, 'C\'est le registre d\'adresse 7', 1, 41),
(142, 'Ils indiquent la taille des opérations: .b pour octet, .w pour mot, .l pour long mot', 1, 42),
(143, 'Ils indiquent le type de données: .b pour booléen, .w pour word, .l pour liste', 0, 42),
(144, 'Ils indiquent la priorité de l\'instruction: .b pour basse, .w pour moyenne, .l pour haute', 0, 42),
(145, 'Ils indiquent le mode d\'adressage: .b pour direct, .w pour indirect, .l pour indexé', 0, 42),
(146, 'add.w #$4,d0', 1, 43),
(147, 'add.w $4,$85F0', 0, 43),
(148, 'add.l #$4,#$85F0', 0, 43),
(149, 'add.b #4,d0', 1, 43),
(150, 'Déplace le contenu de l\'adresse pointée par A0 vers le registre D0, puis incrémente A0', 0, 44),
(151, 'Déplace une constante vers le registre D0 et incrémente A0', 0, 44),
(152, 'Déplace le contenu du registre D0 vers l\'adresse pointée par A0, puis incrémente A0', 1, 44),
(153, 'Déplace le contenu du registre D0 vers une adresse immédiate', 0, 44),
(154, 'Le registre SP', 1, 45),
(155, 'Le registre de données', 0, 45),
(156, 'Le registre de segment', 0, 45),
(157, 'Le pointeur de pile', 1, 45),
(158, 'Initialiser la palette de couleurs', 0, 46),
(159, 'Terminer correctement le programme', 1, 46),
(160, 'Changer la résolution de l\'écran', 0, 46),
(161, 'Attendre une pression de touche', 0, 46),
(162, 'SECTION TEXT', 0, 47),
(163, 'SECTION DATA', 1, 47),
(164, 'SECTION BSS', 0, 47),
(165, 'SECTION INIT', 0, 47),
(166, 'include', 0, 48),
(167, 'incbin', 1, 48),
(168, 'import', 0, 48),
(169, 'load', 0, 48),
(170, 'Pterm0()', 0, 49),
(171, 'Setscreen()', 1, 49),
(172, 'Setpalette()', 0, 49),
(173, 'Cconin()', 0, 49),
(174, 'Les 2 premiers octets', 0, 50),
(175, 'Les 32 octets suivants', 1, 50),
(176, 'À partir du 34e octet', 0, 50),
(177, 'Les 64 premiers octets', 0, 50),
(178, '0 pour basse résolution', 1, 51),
(179, '1 pour moyenne résolution', 1, 51),
(180, '2 pour haute résolution', 1, 51),
(181, '3 pour très haute résolution', 0, 51),
(182, 'Recopie 4 octets de l\'adresse de a0 vers l\'adresse de a1', 1, 52),
(183, 'Incrémente a0 et a1 de 4 octets après la copie', 1, 52),
(184, 'Décrémente a0 et a1 de 4 octets après la copie', 0, 52),
(185, 'Recopie 1 octet de l\'adresse de a0 vers l\'adresse de a1', 0, 52),
(186, 'SECTION TEXT pour le code exécutable', 1, 53),
(187, 'SECTION BSS pour les variables non initialisées', 1, 53),
(188, 'SECTION DATA pour le code exécutable', 0, 53),
(189, 'SECTION INIT pour les variables non initialisées', 0, 53),
(190, '0', 0, 55),
(191, '-1', 1, 55),
(192, '1', 0, 55),
(193, '2', 0, 55),
(194, 'INCLUDE', 0, 56),
(195, 'EQU', 1, 56),
(196, 'DEFINE', 0, 56),
(197, 'CONST', 0, 56),
(198, 'RTS', 1, 57),
(199, 'BSR', 0, 57),
(200, 'DBF', 0, 57),
(201, 'TRAP', 0, 57),
(202, 'Incrémente un registre', 0, 58),
(203, 'Décrémente un registre et boucle si le registre n\'est pas égal à -1', 1, 58),
(204, 'Charge une valeur dans un registre', 0, 58),
(205, 'Effectue un appel système', 0, 58),
(206, 'incbin', 0, 59),
(207, 'include', 1, 59),
(208, 'import', 0, 59),
(209, 'link', 0, 59),
(210, 'Pterm0()', 0, 60),
(211, 'Cconin()', 1, 60),
(212, 'Setscreen()', 0, 60),
(213, 'Setpalette()', 0, 60),
(214, 'Ajouter 160 octets pour chaque ligne au décalage de la ligne précédente', 1, 61),
(215, 'Ajouter 320 octets pour chaque ligne au décalage de la ligne précédente', 0, 61),
(216, 'Multiplier le numéro de la ligne par 320 octets', 0, 61),
(217, 'Multiplier le numéro de la ligne par 160 octets', 1, 61),
(218, '10 groupes', 0, 62),
(219, '20 groupes', 1, 62),
(220, '16 groupes', 0, 62),
(221, '25 groupes', 0, 62),
(222, 'SECTION TEXT', 0, 63),
(223, 'SECTION DATA', 0, 63),
(224, 'SECTION BSS', 1, 63),
(225, 'SECTION CODE', 0, 63),
(226, 'Ajouter le nombre de pixels de largeur du sprite fois sa position, à l\'adresse Y', 0, 64),
(227, 'Ajouter le nombre d\'octets du sprite fois sa position, à l\'adresse Y', 1, 64),
(228, 'Ajouter le nombre d\'octets du sprite fois sa position, à l\'adresse de base.', 0, 64),
(229, 'Ajouter le nombre de colonnes du sprite à l\'adresse de base', 0, 64),
(230, 'Récupérer l\'adresse du framebuffer', 1, 65),
(231, 'Initialiser la palette de couleurs', 0, 65),
(232, 'Calculer les coordonnées X et Y d\'un sprite', 0, 65),
(233, 'Modifier la résolution de l\'écran', 0, 65),
(234, 'Pour éviter que les pixels du fond ne soient modifiés.', 1, 66),
(235, 'Pour s\'assurer que seuls les pixels utiles du sprite soient affichés.', 1, 66),
(236, 'Pour augmenter la vitesse de rendu du sprite.', 0, 66),
(237, 'OR', 0, 67),
(238, 'AND', 1, 67),
(239, 'XOR', 0, 67),
(240, 'Le bit de valeur 0 prend toujours le dessus.', 1, 68),
(241, 'Le bit de valeur 1 prend toujours le dessus.', 0, 68),
(242, 'Les deux bits sont combinés pour produire un nouveau bit.', 0, 68),
(243, 'Créer un fond de couleur unie.', 0, 69),
(244, 'Rendre la zone autour du masque transparente.', 1, 69),
(245, 'Augmenter la luminosité du sprite.', 0, 69),
(246, 'Les bits du fond sont mis à 0.', 0, 70),
(247, 'Les bits du fond sont mis à 1.', 0, 70),
(248, 'Le fond reste inchangé.', 1, 70),
(249, 'De %0000 à %1111', 1, 71),
(250, 'De %0000 à %FFFF', 0, 71),
(251, 'De %0000 à %0010', 0, 71),
(252, 'OR', 1, 72),
(253, 'AND', 0, 72),
(254, 'XOR', 0, 72),
(255, 'Le sprite remplace totalement l\'octet du fond.', 0, 73),
(256, 'Les bits du sprite sont ajoutés à ceux du fond.', 0, 73),
(257, 'Le fond reste inchangé.', 1, 73);

-- --------------------------------------------------------

--
-- Structure de la table `contents`
--

CREATE TABLE `contents` (
  `id_contents` int(11) NOT NULL,
  `title_left` varchar(50) DEFAULT NULL,
  `title_right` varchar(50) DEFAULT NULL,
  `title_center` varchar(50) DEFAULT NULL,
  `text_left` mediumtext DEFAULT NULL,
  `text_right` mediumtext DEFAULT NULL,
  `text_center` mediumtext DEFAULT NULL,
  `image_left` varchar(50) DEFAULT NULL,
  `image_right` varchar(50) DEFAULT NULL,
  `image_center` varchar(50) DEFAULT NULL,
  `attachement_left` varchar(50) DEFAULT NULL,
  `attachement_right` varchar(50) DEFAULT NULL,
  `attachement_center` varchar(50) DEFAULT NULL,
  `page` tinyint(4) DEFAULT NULL,
  `id_templates` int(11) NOT NULL,
  `id_articles` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `contents`
--

INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(1, 'C\'est de là que je viens !', 'C\'est par-là que je vais :D', '', 'Oui je viens surtout du monde de l\' <span class=\"hashtag\">Amstrad</span>, une communauté qui partage énormément et qui reste ultra dynamique encore en 2024. <span class=\"bold\">Plus d\'une centaine de production chaque année</span> (france, espagne, angleterre, allemagne ...) des outils de développement sont également crées comme <span class=\"color-red\">Arkos Tracker</span> pour la musique (merci Julien) ou <span class=\"color-red\">IMPDraw 2</span> qui est carrément une suite d\'outils graphiques ultra complète (Merci AST !).<br>\n<br>\nEt comme si ce n\'était pas suffisant certain comme BDCIron on carrément créé <span class=\"bold\">un site complet pour l\'apprentissage de l\'assembleur sur Zilog 80</span> (zilog.fr). <br>\nBref çà rigole pas.', 'J\'ai pu participer à mon premier event il \'y a deux années de celà, c\'était au <span class=\"hashtag\">GemTOS</span>. Une convention en béton armé qui montre qu\'il y\'a beaucoup de monde chez les ataristes et tous très créatif ! A cette époque je découvrais tout juste l\'assembleur 68000 et j\'ai fait de superbe rencontre et appris beaucoup de chose ce week-end là !<br>\nC\'est bien mais question <span class=\"italic\">\"je trouve les informations facilement ET  en français\"</span> ... c\'est pas trop çà sur cette bécane.<br>\nFranchement chez les ataristes c\'est un peu moue de la chique question transmission du savoir en comparaison avec les amstradiens.<br>\nDonc quand un truc me plaît pas et bien je prends ma cervelle et mes petits doigts et je me met au boulot !', '', NULL, NULL, NULL, '', '', '', 1, 3, 1),
(2, 'Mais je compte faire quoi ?', '', '', 'Et bien pour commencer je souhaite proposer quelque chose<span class=\"bold\"> qui permette à n\'importe quel débutant de se mettre à la programmation en assembleur.</span> <br>\n<br>\nEn simplifiant, en donnant des exemples, en schématisant, en proposant de la documentation, en rassemblant un maximum de source, et en faisant !', '', '', NULL, '1719517602886.png', NULL, '', '', '', 1, 1, 1),
(3, '', '', '', '', '', 'Le screen, là haut à droite, c\'est mon premier <span class=\"italic\">\"Zelda like\"</span> que j\'ai pu coder sur mon 1040 STe, et toi, <span class=\"bold\">OUI TOI !!!!</span> Tu es CAPABLE de coder en assembleur, sauf que sans aucune information où avec seulement des bouts de ficelles c\'est compliqué, puis au bout d\'un moment t\'en a marre et donc tu finis par laisser tomber.<br>\n<br>\nJe te parlerai aussi des sources  d\'informations qui m\'ont aidé à comprendre des trucs, notamment les vidéos de la chaîne <a class=\"link\" href=\"https://www.youtube.com/@Vretrocomputing\" target=\"blank\">VRetroComputing</a>, pédagogue, carré, clair net et précis ! Y\'en a .... mais c\'est le seul à fournir un support réellement pédagogique.<br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 1),
(4, '', '', '', '', '', '', '1719517980320.png', '1719517980322.png', NULL, '', '', '', 1, 2, 1),
(5, '', '', 'Il va se passer quoi maintenant ?', '', '', 'Et bien c\'est simple tu vas se poser tranquille dans ton canapé, une bière à la main à mater une série sur <span class=\"bold\"><span class=\"color-blue\">Prime vidéo</span></span>. Et moi pendant ce temps je me donne <span class=\"bold\">jusqu\'à la fin du mois de juin</span>, pour re-factoriser mon code, et faire çà plus proprement, me donner aussi un peu plus de confort quant à l’ergonomie de mon back-office (qui représente tout de même 80% du site. La partie visible (donc public) ne représente finalement pas grand chose). A l\'heure où je met ce site en ligne je suis ce que l\'on appelle un \"développeur junior\" (suite à ma reconversion professionnelle qui date d\'il y\'a un an à peine).<br>\nCe projet de site, assembleur mis à part, va me servir d\'expérience et d\'expertise. Cela signifie aussi qu\'une multitude de détails ne vont pas aller et je devrais donc améliorer toutes ces petites choses au fils des mois durant.<br>\n<br>\nRevenez y de temps en temps vous y verrez certainement des ajouts, des articles et des fichiers dans les unités de disque, qui serviront de tiroirs à fichiers en tout genre. Mais ce sera classé et bien rangé, à l\'inverse du contenu facebook ou même discord, qui finira par se perdre !<br>\nIci ce n\'est pas perdu <span class=\"color-red\"><span class=\"bold\">et ce sera rangé !</span></span> <br>\nQuand au site en lui même il ne va pas disparaître du jour au lendemain, car c\'est mon métier à présent, donc je saurais m\'en occuper :).<br>\n<br>\nA l\'occasion de ce site web, j\'ai créé un groupe <span class=\"hashtag\">facebook</span> qui s\'appelle tout simplement <span class=\"bold\"><span class=\"color-blue\">\"L\'assembleur 68000 sur Atari ST\"</span></span>.<br>\nIl y\'a à l\'heure actuelle, une cinquantaine de personnes, ce groupe a été ouvert il y\'a à peine 2 semaines.<br>\n<br>\nIl existe aussi un <span class=\"hashtag\">Discord</span> dont voici le lien d\'invitation (qu\'il faut copier coller car j\'ai pas encore mis de fonctionnalité de lien) :<br>\n<a class=\"link\" href=\"https://discord.gg/WPAsfrng5n\" target=\"blank\">https://discord.gg/WPAsfrng5n</a><br>\n<br>\n<br>\nVoilà voilà, je crois que j\'ai tout dis !<br>\n@pluche !', NULL, NULL, NULL, '', '', '', 1, 4, 1),
(6, '', '', '', '', '', '- <span class=\"bold\">Bconin</span> : Lire un caractère depuis un périphérique.<br>\n- <span class=\"bold\">Bconout</span> : Envoyer un caractère à une unité périphérique.<br>\n- <span class=\"bold\">Bconstat</span> : Obtenir le statut d\'entrée d\'une unité périphérique.<br>\n- <span class=\"bold\">Bcostat</span> : Obtenir le statut d\'un périphérique de sortie standard.<br>\n- <span class=\"bold\">Drvmap</span> : Obtenir des informations sur les périphériques attachés.<br>\n- <span class=\"bold\">Getbpb</span> : Obtenir l\'adresse du bloc de paramètres BIOS d\'une unité.<br>\n- <span class=\"bold\">Getmpb</span> : Déterminer le bloc de paramètres de mémoire.<br>\n- <span class=\"bold\">Kbshift</span> : Récupérer/mettre à jour le statut des touches de modification.<br>\n- <span class=\"bold\">Mediach</span> : Demander si le média a été changé.<br>\n- <span class=\"bold\">Rwabs</span> : Opération de lecture/écriture directe sur une unité.<br>\n- <span class=\"bold\">Setexc</span> : Définir et obtenir le vecteur d\'interruption.<br>\n- <span class=\"bold\">Tickcal</span> : Obtenir la différence de temps entre deux appels de minuterie.<br>\n<br>\nLe <span class=\"bold\">BIOS</span> est \"ré-entrant\" sous <span class=\"bold\">MagiC</span>. Cela signifie que ces fonctions <span class=\"underline\">peuvent également être appelées de manière répétée depuis des interruptions</span> <span class=\"italic\">(tant que la pile du superviseur concerné ne déborde pas...)</span>.<br>\n<br>\n<div class=\"border-yellow\"><p> - La couche <span class=\"bold\"><saveptr_area></span> du BIOS est toujours présente<span class=\"italic\"> (pour des raisons de compatibilité)</span>, mais elle n\'est pas utilisée par le système.<br>\n<br>\n - Les vérifications de pile de Turbo C/Pure-C échoueront pour les routines exécutées en mode superviseur <span class=\"italic\">(sous TOS, cela pouvait se produire uniquement pour les routines USERDEF dans l\'AES, qui sont également exécutées en mode superviseur)</span>.</p></div><br>\n<br>\nSi vous insérez vos propres routines dans le BIOS, assurez-vous qu\'elles soient entièrement ré-entrantes. Ne faites aucune supposition sur le contenu de la couche <span class=\"bold\"><saveptr_area></span> !<br>\n<br>\nLe <span class=\"bold\">BIOS</span> reçoit ses paramètres de la pile ; pour cela, le dernier argument de la liste de paramètres est stocké en premier sur la pile.<br>\n<div class=\"border-yellow\"><p>Les résultats des fonctions sont renvoyés dans le registre du processeur d0.<br>\nSeuls les registres d3-d7 et a3-a7 sont sauvegardés, tous les autres peuvent être modifiés par l\'appel.</p></div>', NULL, NULL, NULL, '', '', '', 1, 4, 2),
(7, 'Bconin', '', '', '<span class=\"bold\">Nom :</span> Entrée console BIOS<br>\n<span class=\"bold\">Opcode :</span> 2<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Bconin ( int16_t dev );<br>\n<span class=\"bold\">Description :</span> La routine BIOS Bconin lit un caractère depuis un périphérique. Les périphériques suivants peuvent être spécifiés pour dev (dev = le numéros de la colonne de gauche) :<br>\n<br>\n0	prn: (Imprimante/Port parallèle)<br>\n1	aux: (périphérique auxiliaire, le port RS-232)<br>\n2	con: (Console)<br>\n3	Port MIDI<br>\n4	Port clavier<br>\n5	Écran<br>\n6	Port RS232 compatible ST (Modem 1)<br>\n7	Canal SCC B (Modem 2)<br>\n8	Port série TTMFP (Modem 3)<br>\n9	Canal SCC A (Modem 4)', '<div class=\"border-red\"><p>Notez que les numéros de périphérique à partir de 6 ne sont disponibles qu\'à partir du TOS030 de l\'Atari-TT. Une déclaration incorrecte pour dev peut entraîner un plantage du système.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction renvoie le caractère lu comme une valeur ASCII dans les bits 0..7. Lors de la lecture depuis la console, <span class=\"underline\">les bits 16 à 23 contiennent le scan-code de la touche correspondante</span>. Si, en plus, le bit correspondant de la variable système <span class=\"italic\">conterm</span> est défini, alors les bits 24 à 31 contiennent la valeur actuelle de <span class=\"italic\">Kbshift</span>.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions TOS.<br>\n<br>\n<span class=\"code\">move.w    dev,-(sp)    ; Offset 2<br>\nmove.w    #2,-(sp)     ; Offset 0<br>\ntrap      #13          ; Call BIOS<br>\naddq.l    #4,sp        ; Correct stack</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 2),
(8, 'Bconout', '', '', '<span class=\"bold\">Nom :</span> Sortie console BIOS<br>\n<span class=\"bold\">Opcode :</span> 3<br>\n<span class=\"bold\">Syntaxe :</span> VOID Bconout ( int16_t dev, int16_t c );<br>\n<span class=\"bold\">Description :</span> La routine BIOS Bconout écrit le caractère c sur le périphérique dev. Les périphériques suivants peuvent être spécifiés pour dev :<br>\n<br>\n0	prn: (Imprimante/Port parallèle)<br>\n1	aux: (périphérique auxiliaire, le port RS-232)<br>\n2	con: (Console, terminal VT-52)<br>\n3	Port MIDI<br>\n4	Port clavier<br>\n5	Écran<br>\n6	Port RS-232 compatible ST (Modem 1)<br>\n7	Canal SCC B (Modem 2)<br>\n8	Port série TTMFP (Modem 3)<br>\n9	Canal SCC A (Modem 4)', '<div class=\"border-red\"><p>Notez que les numéros de périphérique à partir de 6 ne sont disponibles qu\'à partir du TOS030 de l\'Atari-TT.</p></div><br>\n<br>\n<div class=\"border-red\"><p>La fonction ne retourne que lorsque le caractère a effectivement été sorti par le périphérique concerné. Une déclaration incorrecte pour dev peut entraîner un plantage du système. </p></div><br>\n<br>\n<div class=\"border-red\"><p>Tous les codes de 0x00 à 0xFF pour le caractère c sont interprétés comme des caractères imprimables. La sortie via (5) est, incidemment, plus rapide que via (2), car les séquences VT-52 n\'ont pas besoin d\'être évaluées.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction ne renvoie pas de résultat.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions TOS.<br>\n<br>\n<span class=\"code\">move.w    c,-(sp)      ; Offset 4<br>\nmove.w    dev,-(sp)    ; Offset 2<br>\nmove.w    #3,-(sp)     ; Offset 0<br>\ntrap      #13          ; Call BIOS<br>\naddq.l    #6,sp        ; Correct stack</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 2),
(9, 'Bconstat', '', '', '<span class=\"bold\">Nom :</span> Statut console BIOS<br>\n<span class=\"bold\">Opcode :</span> 1<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Bconstat ( int16_t dev );<br>\n<span class=\"bold\">Description :</span> La routine BIOS Bconstat établit le statut d\'entrée d\'un périphérique standard dev. Les périphériques suivants peuvent être spécifiés pour dev :<br>\n<br>\n0	prn: (Imprimante/Port parallèle)<br>\n1	aux: (périphérique auxiliaire, le port RS-232)<br>\n2	con: (Console)<br>\n3	Port MIDI<br>\n4	Port clavier<br>\n5	Écran<br>\n6	Port RS-232 compatible ST (Modem 1)<br>\n7	Canal SCC B (Modem 2)<br>\n8	Port série TTMFP (Modem 3)<br>\n9	Canal SCC A (Modem 4)', '<div class=\"border-red\"><p>Notez que les numéros de périphérique à partir de 6 ne sont disponibles qu\'à partir du TOS030 de l\'Atari-TT. Une déclaration incorrecte pour dev peut entraîner un plantage du système.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction renvoie -1 lorsqu\'il y a des caractères en attente dans le tampon, et 0 si ce n\'est pas le cas.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions TOS.<br>\n<br>\n<span class=\"code\">move.w    dev,-(sp)    ; Offset 2<br>\nmove.w    #1,-(sp)     ; Offset 0<br>\ntrap      #13          ; Call BIOS<br>\naddq.l    #4,sp        ; Correct stack</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 2),
(10, 'Bcostat', '', '', '<span class=\"bold\">Nom :</span> Statut périphérique de sortie BIOS<br>\n<span class=\"bold\">Opcode :</span> 8<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Bcostat ( int16_t dev );<br>\n<span class=\"bold\">Description :</span> La routine BIOS Bcostat établit le statut d\'un périphérique de sortie standard dev. Les périphériques suivants peuvent être spécifiés pour dev :<br>\n<br>\n0	prn: (Imprimante/Port parallèle)<br>\n1	aux: (périphérique auxiliaire, le port RS-232)<br>\n2	con: (Console)<br>\n3	Port MIDI<br>\n4	Port clavier<br>\n5	Écran<br>\n6	Port RS-232 compatible ST (Modem 1)<br>\n7	Canal SCC B (Modem 2)<br>\n8	Port série TTMFP (Modem 3)<br>\n9	Canal SCC A (Modem 4)', '<div class=\"border-red\"><p>Notez que les numéros de périphérique à partir de 6 ne sont disponibles qu\'à partir du TOS030 de l\'Atari-TT. Une déclaration incorrecte pour dev peut entraîner un plantage du système.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction renvoie -1 si le périphérique de sortie est prêt, et 0 si ce n\'est pas le cas.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions TOS.<br>\n<br>\n<span class=\"code\">move.w    dev,-(sp)    ; Offset 2<br>\nmove.w    #8,-(sp)     ; Offset 0<br>\ntrap      #13          ; Call BIOS<br>\naddq.l    #4,sp        ; Correct stack</span><br>\n', '', NULL, NULL, NULL, '', '', '', 1, 3, 2),
(11, '', '', '', '', '', 'En plus de cela, de nombreuses autres routines sont disponibles, lesquelles peuvent être réparties dans l\'une des catégories suivantes :<br>\n<br>\n - <span class=\"bold\">GEMDOS</span><br>\n-  <span class=\"bold\">BIOS</span><br>\n-  <span class=\"bold\">XBIOS</span><br>\n<br>\nLe <span class=\"bold\">TOS</span> remonte à l\'année 1985. Au fil du temps, il a été développé davantage par <span class=\"bold\">Atari</span> et est disponible pour divers modèles d\'ordinateurs (ST, STE, Mega-ST, TT, Falcon, ...). De plus, il existe un certain nombre de systèmes compatibles TOS proposés par des tiers.<br>\n<br>\nIl convient de mentionner à cet égard, surtout, <a class=\"link\" href=\"https://www.atariuptodate.de/en/6/magic#\" target=\"blank\">MagiC</a> et <a class=\"link\" href=\"https://www.atariuptodate.de/en/5/geneva\" target=\"blank\">Geneva</a>. Alors que <span class=\"bold\">MagiC</span> est devenu particulièrement important en Allemagne (et au Royaume-Uni), <span class=\"bold\">Geneva</span> semble avoir rencontré un certain succès aux États-Unis.<br>\n<br>\nGrâce à <a class=\"link\" href=\"https://gitlab.com/AndreasK/AtariX\" target=\"blank\">MagiC Mac</a>, une implémentation de <span class=\"bold\">MagiC</span> sur le matériel Apple (Power) Macintosh, les programmes TOS fonctionnent désormais également sur les ordinateurs Apple.<br>\nUne variante ultérieure, <a class=\"link\" href=\"https://magicpc.atari-users.com/\" target=\"blank\">MagiC PC</a>, a également étendu cette compatibilité à de nombreuses machines Windows.<br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 3),
(12, '', '', 'GEM (Graphics Environment Manager) ', '', '', 'Il fait partie du système d\'exploitation et représente l\'interface (graphique) entre l\'ordinateur et l\'utilisateur. <br>\n<span class=\"bold\">GEM</span> a été développé par l\'entreprise <a class=\"link\" href=\"https://fr.wikipedia.org/wiki/Digital_Research\" target=\"blank\">Digital Research</a> en 1984 pour les PC avec processeurs Intel. Le système est devenu bien connu surtout lorsque l\'Atari ST a été commercialisé, offrant une alternative puissante et abordable aux machines PC et Macintosh coûteuses de l\'époque.<br>\n<br>\nAu fil du temps, GEM a été adapté à divers systèmes d\'exploitation et plateformes matérielles, y compris :<br>\n<br>\n- PC GEM<br>\n- Atari GEM<br>\n- GEM sur X <span class=\"italic\">(version pour systèmes Unix)</span><br>\n- X/GEM <span class=\"italic\">(pour le système d\'exploitation FlexOS)</span><br>\n<br>\nGEM peut être divisé en deux sous-ensembles :<br>\n<br>\n- AES, Application Environment Services<br>\n- VDI, Virtual Device Interface<br>\n<br>\nL\'<span class=\"bold\">AES</span> se charge de l\'organisation de l\'environnement utilisateur, tandis que le <span class=\"bold\">VDI</span> s\'occupe de l\'affichage graphique uniforme de l\'interface utilisateur.<br>\nLors du développement de programmes <span class=\"bold\">GEM</span>, il est impératif de respecter les lignes directrices en vigueur et de ne jamais tenter d\'imposer à l\'utilisateur une interface qui ne respecte aucune norme.', NULL, NULL, NULL, '', '', '', 2, 4, 3),
(13, '', '', 'Les différentes versions de GEM', '', '', 'Pour connaître le numéro de version de <span class=\"bold\">GEM</span>, on utilise généralement <span class=\"underline\">l\'ID renvoyé dans le champ global par l\'appel appl_init</span>. Le <span class=\"bold\">VDI</span>, en revanche, <span class=\"underline\">n\'a en réalité pas de numéro de version propre</span>, d\'autant plus que le comportement des fonctions <span class=\"bold\">VDI</span> individuelles est principalement <span class=\"underline\">déterminé par les pilotes de périphériques utilisés</span>, qui sont, après tout, remplaçables.<br>\n<br>\nOn peut globalement différencier les versions de <span class=\"bold\">GEM</span> suivantes :', NULL, NULL, NULL, '', '', '', 2, 4, 3),
(14, 'GEM 1.x', '', '', 'Cette première version de l\'<span class=\"bold\">AES (1.x)</span> avait, non par hasard, <span class=\"underline\">de grandes similitudes avec le système d\'exploitation du Macintosh d\'Apple</span>.<br>\n<br>\nCela se manifestait non seulement dans la conception des éléments de fenêtre, mais aussi dans de nombreuses fonctionnalités du bureau et d\'autres programmes d\'application. <br>\n<br>\nÀ l\'époque, <span class=\"bold\">GEM</span> était présenté principalement en connexion avec des versions d\'essai de <span class=\"bold\">GEM-Draw</span>, <span class=\"bold\">GEM-Paint</span> et <span class=\"bold\">GEM-Write</span>, qui correspondaient en de nombreux détails aux prototypes Macintosh bien connus <span class=\"bold\">MacDraw</span>, <span class=\"bold\">MacPaint</span> et <span class=\"bold\">MacWrite</span>.', '', '', NULL, '1719520729587.png', NULL, '', '', '', 2, 1, 3),
(15, '', '', '', '', '', 'C\'est également la version adoptée par Atari et livrée dans le ST ; toutes les versions plus récentes de l\'Atari-GEM sont également basées sur cette version.<br>\nEn effet, la société Atari a acquis tous les droits sur la version existante et a continué à la développer elle-même. Cela explique également les différences de plus en plus grandes entre <span class=\"bold\">PC-GEM</span> et <span class=\"bold\">Atari-GEM</span>. <br>\n<br>\nLe plus grand défaut de la version Atari était certainement l\'absence du <span class=\"bold\">Graphics Device Operating System (GDOS)</span> ; celui-ci contient des fonctions graphiques indépendantes du périphérique, qui n\'étaient implémentées sur l\'Atari que pour l\'écran, et devaient donc être chargées séparément pour les imprimantes, traceurs, caméras, etc. <br>\nEn conséquence <span class=\"italic\">(surtout dans les premiers jours de l\'Atari)</span>, chaque programme utilisait ses propres pilotes et formats, rendant ainsi l\'échange de données entre applications presque impossible.', NULL, NULL, NULL, '', '', '', 2, 4, 3),
(16, 'GEM 2.x', '', '', 'En raison d\'un différend juridique entre <span class=\"bold\">Apple</span> et <span class=\"bold\">Digital Research</span> <span class=\"italic\">(concernant principalement l\'apparence des programmes d\'application et du bureau)</span>, la version PC de GEM a dû être modifiée.<br>\n<br>\nLe règlement, qui n\'affectait pas la version GEM d\'Atari, ressemblait à ceci :<br>\n<br>\n- <span class=\"color-blue\">Certains éléments de fenêtre</span> ont été modifiés de telle sorte qu\'ils ne ressemblaient plus aux fenêtres du Macintosh <span class=\"italic\">(surtout la barre de titre)</span><br>\n<br>\n- <span class=\"color-blue\">Le menu Accessory</span> a été déplacé dans le coin opposé (droit) de l\'écran<br>\n<br>\n- <span class=\"color-blue\">Les fonctions <span class=\"bold\">graf_growbox</span> et <span class=\"bold\">graf_shrinkbox</span> </span>ont été éliminées<br>\n<br>\n- <span class=\"color-blue\">Le bureau</span> a été entièrement reprogrammé et limité à deux fenêtres fixes.', '', '', NULL, '1719520816205.png', NULL, '', '', '', 2, 1, 3),
(17, '', '', '', '', '', 'Contrairement aux idées reçues, il ne s\'agissait cependant <span class=\"underline\">que d\'une modification du bureau</span>, et non de l\'<span class=\"bold\">AES</span>, qui continuait à permettre jusqu\'à huit fenêtres superposées.<br>\nCependant, il n\'y avait pas que des restrictions, mais aussi des améliorations. L\'exemple le plus important à mentionner est que les accessoires pouvaient installer leur propre barre de menu.<br>\n<br>\nCette version a reçu le numéro de <span class=\"bold\">version 2.0</span> et a été fournie <span class=\"underline\">à partir de 1987</span> ; peu de temps après, elle a été portée par la société de logiciels néerlandaise <span class=\"bold\">ABC</span> avec <span class=\"bold\">GEM-Draw</span>, <span class=\"bold\">GEM-Paint</span>, <span class=\"bold\">GEM-Graph</span> et bien sûr le bureau GEM sur l\'Atari.<br>\nCependant, cette version n\'a jamais vraiment pris de l\'importance et n\'est plus disponible aujourd\'hui.', NULL, NULL, NULL, '', '', '', 2, 4, 3),
(18, 'PC-GEM 3.x', 'GEM Desktop 3.13', '', 'Cette version contenait quelques améliorations mineures. Ainsi, le comportement du menu pouvait être commuté de déroulant à dépliant, par exemple.<br>\n<br>\nÀ partir de la version <span class=\"bold\">GEM/3 3.11</span>, il existe des fonctions <span class=\"bold\">VDI</span> supplémentaires, qui concernent <span class=\"color-blue\">les fonctions Bézier</span> et <span class=\"color-blue\">les imprimantes Postscript</span>.<br>\n<br>\nLe programme <span class=\"bold\">ARTLINE</span> utilise ces nouvelles fonctions avec ses polices vectorielles.<br>\n<br>\nEn raison de la domination de <span class=\"bold\">MS-Windows</span>, cette version a pratiquement disparu du marché des PC.', 'La dernière version standard vendue.<br>\n<br>\nPartie du <span class=\"bold\">GEM PTK/SDK 3.13</span> qui a finalement été réécrite pour prendre en charge les compilateurs <span class=\"bold\">ANSI C</span>.', '', NULL, NULL, '1719520929760.png', '', '', '', 2, 9, 3),
(19, 'GEM/4 ', 'GEM/5', '', 'N\'a atteint le marché qu\'en tant que support d\'exécution pour <span class=\"bold\">Artline/2</span>, <span class=\"bold\">PresTeam/2</span>, <span class=\"bold\">Publish it/3</span>, etc. Le <span class=\"bold\">VDI</span> utilisera <span class=\"bold\">EMS</span>, si disponible.<br>\n<br>\nLe bureau <span class=\"bold\">GEM/3</span> ne fonctionne pas correctement et une commande shell fournie pour lancer des applications <span class=\"bold\">GEM/4</span> à partir du bureau <span class=\"bold\">GEM/3</span> peut planter après une utilisation répétée.', 'N\'a atteint le marché qu\'en tant que support d\'exécution pour <span class=\"bold\">Timeworks Publisher 2.1</span>. Il avait un support de police évolutive utilisant la mémoire <span class=\"bold\">XMS</span> et ajoute un aspect 3D aux objets <span class=\"bold\">AES</span>.<br>\n<br>\n<span class=\"bold\">GEM/4 </span>et <span class=\"bold\">GEM/5</span> ont ajouté de nouveaux appels <span class=\"bold\">VDI</span> et <span class=\"bold\">AES</span>, mais leurs liaisons sont inconnues. <br>\n<br>\nCet <span class=\"bold\">AES 4.0</span> propriétaire prend en charge un nouveau message MU_HELP et certains appels prennent un paramètre supplémentaire pour une aide contextuelle.<br>\nCe que ces fonctionnalités font réellement n\'est pas connu.', '', NULL, NULL, NULL, '', '', '', 3, 3, 3),
(20, '', 'GEM/XM', '', '', 'Probablement le modèle pour le <span class=\"bold\">X/GEM</span> de <span class=\"bold\">DRI</span> pour <span class=\"bold\">FlexOS</span><span class=\"italic\"> (un système multitâche en mode protégé 32 bits)</span>.<br>\n<br>\n<span class=\"bold\">GEM/XM</span> prévoyait d\'apporter un support multitâche sous <span class=\"bold\">DOS</span>, mais est resté inachevé. La dernière version est FreeGEM/XM 3.0beta5-je1.', '', '1719521060733.png', NULL, NULL, '', '', '', 3, 6, 3),
(21, 'ViewMAX/1 (DR-DOS 5.0)', 'ViewMAX/3 (DR-DOS 7.0)', 'ViewMAX/2 (DR-DOS 6.0)', 'C\'est un noyau <span class=\"bold\">GEM/4</span> \"limité\" et ne peut être utilisé que comme un shell pour appeler des applications <span class=\"bold\">GEM</span>. <br>\nBien que conçu pour <span class=\"bold\">DR DOS</span>, il fonctionnera sous <span class=\"bold\">MS-DOS 3.x</span> et versions ultérieures <span class=\"italic\">(moins les mots de passe)</span>. <br>\nPour l\'utiliser avec des applications <span class=\"bold\">GEM</span>, vous devez avoir une installation<span class=\"bold\"> GEM/3</span> ainsi qu\'une installation <span class=\"bold\">ViewMAX</span>. Cette version a été écrite en <span class=\"bold\">Lattice C 3.x</span>.', 'Il n\'a jamais été publié, mais du code bêta est disponible.', 'C\' était une version améliorée de la précédente, mais avec les mêmes limitations de noyau que ci-dessus. Cette version a été réécrite en <span class=\"bold\">Turbo C2.0</span> et permet une configuration via un fichier *.ini.', NULL, NULL, NULL, '', '', '', 3, 7, 3),
(22, '', '', '', '', '', '', NULL, NULL, '1719521179677.png', '', '', '', 3, 5, 3),
(23, 'X/GEM', 'Atari-GEM 1.4', '', 'Cette version de <span class=\"bold\">GEM</span> a été développée par <a class=\"link\" href=\"https://fr.wikipedia.org/wiki/Digital_Research\" target=\"blank\">Digital Research</a> sur un système d\'exploitation multitâche multi-utilisateurs <span class=\"italic\">(FlexOS)</span>, et permet la gestion simultanée de plusieurs applications au premier plan.', 'Des modifications majeures ont été apportées par Atari uniquement dans <span class=\"bold\">GEM 1.4</span> de <span class=\"bold\">TOS 1.04</span> ; la fonctionnalité la plus connue est le sélecteur de fichiers grandement amélioré.', '', NULL, NULL, NULL, '', '', '', 3, 3, 3),
(24, 'Drvmap', '', '', '<span class=\"bold\">Nom :</span> Carte des lecteurs<br>\n<span class=\"bold\">Opcode :</span> 10<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Drvmap ( VOID );<br>\n<br>\n<span class=\"bold\">Description :</span> La routine BIOS Drvmap établit la carte des lecteurs montés. Pour chaque lecteur monté, un bit est défini. Les bits valides sont :<br>\nBit 0 : Lecteur A<br>\nBit 1 : Lecteur B, etc. (32 périphériques maximum possibles)<br>\n<br>\n<span class=\"bold\">Note :</span> La fonction retourne le contenu de la variable système _drvbits. Pour déterminer quels lecteurs sont reconnus par GEMDOS, il faut utiliser la fonction Dsetdrv.<br>\n<br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction renvoie un WORD (int16_t) dont les bits 0 à 15 représentent les périphériques de bloc installés. Par exemple, si le bit 2 (2^2) est défini, le disque dur logique \'C\' est disponible.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions TOS.<br>\n<br>\n<span class=\"code\">move.w    #$A,-(sp)     ; Offset 0<br>\ntrap      #13           ; Appel au BIOS<br>\naddq.l    #2,sp         ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 2),
(25, 'Getbpb', '', '', '<span class=\"bold\">Nom :</span> Obtenir le BPB (Bloc de Paramètres du BIOS)<br>\n<span class=\"bold\">Opcode :</span> 7<br>\n<span class=\"bold\">Syntaxe :</span> BPB *Getbpb ( int16_t dev );<br>\n<br>\n<span class=\"bold\">Description :</span> La routine BIOS Getbpb établit le bloc de paramètres du BIOS (BPB) du périphérique dev, qui est codé comme suit :<br>\ndev	Signification<br>\n0	Lecteur A<br>\n1	Lecteur B<br>\n2	Lecteur C<br>\n<br>\nLes lecteurs suivants sont codés de manière similaire. En appelant cette fonction, l\'état de changement de média dans le BIOS est réinitialisé.', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne l\'adresse du BPB<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    dev,-(sp)    ; Offset 2<br>\nmove.w    #7,-(sp)     ; Offset 0<br>\ntrap      #13          ; Appel au BIOS<br>\naddq.l    #4,sp        ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 2, 3, 2),
(26, 'Getmpb', '', '', '<span class=\"bold\">Nom :</span> Obtenir le BPB de la mémoire (Bloc de Paramètres de la Mémoire)<br>\n<span class=\"bold\">Opcode :</span> 0<br>\n<span class=\"bold\">Syntaxe :</span> VOID Getmpb ( MPB *ptr );<br>\n<br>\n<span class=\"bold\">Description :</span> La routine BIOS Getmpb sert à initialiser la gestion de la mémoire et est appelée au démarrage par GEMDOS pour créer le TPA (Transient Program Area) initial. Après cela, Getmpb ne doit plus être utilisé.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction ne retourne pas de résultat.', '<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">pea       ptr          ; Offset 2<br>\nmove.w    #0,-(sp)     ; Offset 0<br>\ntrap      #13          ; Appel au BIOS<br>\naddq.l    #6,sp        ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 2, 3, 2),
(27, 'Kbshift', '', '', '<span class=\"bold\">Nom :</span> État des touches spéciales du clavier<br>\n<span class=\"bold\">Opcode :</span> 11<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Kbshift ( int16_t mode );<br>\n<br>\n<span class=\"bold\">Description :</span> La routine BIOS Kbshift établit ou modifie l\'état actuel des touches spéciales du clavier. Si mode est négatif, l\'état est simplement établi. Si mode est 0 ou supérieur à 0, l\'état correspondant sera défini. Les bits individuels sont définis comme suit :<br>\n<br>\nBit	Signification<br>\n0	Touche <span class=\"keyboard-key\">Maj</span> droite<br>\n1	Touche <span class=\"keyboard-key\">Maj</span> gauche<br>\n2	Touche <span class=\"keyboard-key\">Ctrl</span><br>\n3	Touche <span class=\"keyboard-key\">Alt</span><br>\n4	Verrouillage des majuscules<br>\n5	Bouton droit de la souris<br>\n6	Bouton gauche de la souris<br>\n7	<span class=\"keyboard-key\">Alt Gr</span> depuis TOS 4.06 (Milan)', '<div class=\"border-yellow\"><p>Note : La fonction interroge simplement une variable système interne du BIOS, dont l\'adresse peut être calculée via _sysbase si nécessaire. Pour TOS 1.0, cette variable système se trouve à l\'adresse 0xE1B.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne l\'état des touches de modification.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    mode,-(sp)   ; Offset 2<br>\nmove.w    #$B,-(sp)    ; Offset 0<br>\ntrap      #13          ; Appel au BIOS<br>\naddq.l    #4,sp        ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 2, 3, 2),
(28, 'Mediach', '', '', '<span class=\"bold\">Nom :</span> Vérification de changement de média<br>\n<span class=\"bold\">Opcode :</span> 9<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Mediach ( int16_t dev );<br>\n<br>\n<span class=\"bold\">Description :</span> La routine BIOS Mediach établit si le média du périphérique dev a été changé depuis la dernière opération de disque du lecteur en question. Les valeurs valides pour dev sont :<br>\ndev	Signification<br>\n0	Lecteur A<br>\n1	Lecteur B<br>\n2	Lecteur C (similairement pour les autres lecteurs)<br>\n<br>\n<div class=\"border-red\"><p>Note : Il ne faut jamais supposer que le média d\'un périphérique ne peut pas être échangé (cartouche de disque amovible, CD-ROM, lecteur de disquette, disque Floptical, etc.). La reconnaissance d\'un changement de disquette fonctionne généralement de manière fiable seulement si la disquette n\'est pas protégée en écriture. Il est également important de noter que lors du formatage d\'une disquette, différents numéros de série seront attribués.</p></div><br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne une valeur entière avec la signification suivante :<br>\n<br>\nValeur	Signification<br>\n0	Le média n\'a définitivement pas changé.<br>\n1	Le média pourrait avoir changé.<br>\n2	Le média a définitivement changé.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    dev,-(sp)    ; Offset 2<br>\nmove.w    #9,-(sp)     ; Offset 0<br>\ntrap      #13          ; Appel au BIOS<br>\naddq.l    #4,sp        ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 3, 3, 2),
(29, 'Rwabs', '', '', '<span class=\"bold\">Nom :</span> Lecture/Écriture absolue<br>\n<span class=\"bold\">Opcode :</span> 4<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Rwabs ( int16_t rwflag, VOID *buff, int16_t cnt, int16_t recnr, int16_t dev, int32_t lrecno );;<br>\n<br>\n<span class=\"bold\">Description :</span> Description : La routine BIOS Rwabs lit ou écrit des données directement depuis ou vers le lecteur spécifié par dev. Le paramètre rwflag est un vecteur de bits qui spécifie le type d\'opération. Les valeurs valides sont :<br>\n<br>\nBit du rwflag	Signification<br>\n0	0 = Lecture, 1 = Écriture<br>\n1	0 = Prendre en compte le changement de média, 1 = Ne pas lire ou affecter l\'état de changement de média<br>\n2	0 = En cas d\'erreur, redémarrer une tentative, 1 = Ne pas redémarrer une tentative<br>\n3	0 = Mode normal, 1 = Mode physique (1)<br>\n<br>\nPour cela, un pilote de disque dur compatible avec AHDI 3.0 est requis.<br>\n', 'cnt secteurs depuis le tampon buff seront transférés. Dans recnr, le secteur de départ sur le lecteur sera spécifié. lrecno ne sera utilisé que si recnr a la valeur -1, et un pilote de disque dur compatible avec AHDI 3.0 est disponible.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne 0 en cas de succès, ou un code d\'erreur en cas d\'échec.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.l    lrecno,-(sp)  ; Offset 14<br>\nmove.w    dev,-(sp)     ; Offset 12<br>\nmove.w    recnr,-(sp)   ; Offset 10<br>\nmove.w    cnt,-(sp)     ; Offset  8<br>\npea       buff          ; Offset  4<br>\nmove.w    rwflag,-(sp)  ; Offset  2<br>\nmove.w    #4,-(sp)      ; Offset  0<br>\ntrap      #13           ; Appel au BIOS<br>\nlea       $12(sp),sp    ; Correction de la pile</span><br>\n<br>\nGFA-Basic : <span class=\"code\">Fehler%=Bios(4,W:rwflag%,L:buff%,W:cnt%,W:recnr%,W:dev%,L:lrecno%)</span><br>\n', '', NULL, NULL, NULL, '', '', '', 3, 3, 2),
(30, 'Setexc', '', '', '<span class=\"bold\">Nom :</span> Définir le vecteur d\'exception<br>\n<span class=\"bold\"><span class=\"bold\">Opcode :</span> 5<br>\nSyntaxe : </span>int32_t Setexc ( int16_t number, VOID (*vec)() );<br>\n<br>\n<span class=\"bold\">Description :</span> La routine BIOS Setexc définit ou lit le contenu des vecteurs d\'exception. Les valeurs valides sont :<br>\n<br>\nParamètre	Signification<br>\nnumber	Numéro du vecteur<br>\nvec	Nouvelle adresse (ou -1)<br>\n<br>\n<div class=\"border-yellow\"><p>Note : Si vec est -1L, alors la valeur précédente du vecteur est retournée.<br>\nLe numéro du vecteur d\'exception à définir est, par ailleurs, identique à l\'adresse à définir divisée par 4.</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne la valeur précédente (ou actuelle) du vecteur.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">pea       exchdlr      ; Offset 4<br>\nmove.w    number,-(sp) ; Offset 2<br>\nmove.w    #5,-(sp)     ; Offset 0<br>\ntrap      #13          ; Appel au BIOS<br>\naddq.l    #8,sp        ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 3, 3, 2),
(31, 'Tickcal', '', '', '<span class=\"bold\">Nom :</span> Calcul de tick<br>\n<span class=\"bold\">Opcode :</span> 6<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Tickcal ( VOID );<br>\n<br>\n<span class=\"bold\">Description :</span> La routine BIOS Tickcal retourne le nombre de millisecondes écoulées entre deux appels du temporisateur système.', '<span class=\"bold\">Note :</span> Pour cela, la fonction accède à la variable système _timr_ms.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> Nombre de millisecondes correspondantes.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    #6,-(sp)     ; Offset 0<br>\ntrap      #13          ; Appel au BIOS<br>\naddq.l    #2,sp        ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 3, 3, 2),
(32, 'I. Émulateur ou Atari ST ?', '', '', 'Le premier outil, c’est bien évidemment la machine sur laquelle ce code est destiné. Il y a deux écoles, tu choisis la méthode que tu souhaites.<br>\n<br>\nSi tu as un Atari 520ST, c’est bien, mais tu seras vite bloqué dès que les choses deviendront sérieuses. <span class=\"bold\">Idéalement, je te conseille un 1040STe</span> pour sa compatibilité avec un périphérique appelé <span class=\"italic\">« Ultra Satan »</span>, qui permet de simuler un disque dur de l’époque.<br>\n<br>\nVoici sur la photo de droite à quoi çà ressemble : 2 lecteur de carte SD.<br>\n<br>\n<div class=\"border-red\"><p>Par contre vérifie que ton Atari est bien compatible avec ce périphérique, il va falloir lui ouvrir le ventre et vérifier la version de la puce DMA.</p></div><br>\n<br>\nJe ferai un petit article sur le sujet, ayant plusieurs machine en ma possession, mais ce n’est pas le sujet de cet article.', '', '', NULL, '1719525834993.png', NULL, '', '', '', 1, 1, 4),
(33, '', '', '', '', '', 'Si tu n’as pas de vraie machine chez toi, ce n’est pas très grave car il existe ce que l’on appelle des émulateurs, ce sont des  logiciels qui reproduisent l’interface et le comportement de l’Atari. <br>\n<br>\nIl en existe plusieurs, mais seuls deux sont réellement efficaces : <span class=\"hashtag\">Hatari 2.5</span> et <span class=\"hashtag\">Steem SSE</span> <span class=\"italic\">(personnellement, je ne suis pas à l’aise avec Steem SSE, je préfère Hatari, mais tu es libre de choisir celui qui te semble le plus adapté pour toi).</span><br>\nVoici où tu peux télécharger ces 2 émulateurs : <br>\n<a class=\"link\" href=\"https://hatari.tuxfamily.org/download.html\" target=\"blank\">Hatari download page</a><br>\n<a class=\"link\" href=\"https://sourceforge.net/projects/steemsse/\" target=\"blank\">STEem Sensei Software Edition</a><br>\n<br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 4),
(34, '', '', '', '', '', '', '1719525898053.png', '1719525898054.png', NULL, '', '', '', 1, 2, 4),
(35, 'II.L’éditeur / assembleur / débugger', '', '', '<span class=\"underline\">1 – L’assembleur</span><br>\n<br>\nLe premier outil est l\'assembleur lui-même. Il sert à prendre le code que tu as tapé et à le transformer <span class=\"bold\">dans le seul langage compréhensible par un ordinateur : le langage machine</span> <span class=\"italic\">(un langage composé uniquement de 0 et de 1, également appelé langage binaire, mais nous y reviendrons plus tard).</span><br>\n<br>\n<span class=\"underline\">2 – L’éditeur</span><br>\n<br>\nCet outil est muni d\'un éditeur de texte qui te permet de taper du code. C\'est précisément ce code qui est destiné à être assemblé pour être ensuite stocké dans un fichier source. Ce fichier une fois exécuté est envoyé  dans la mémoire de l\'ordinateur (la RAM), où il sera lu. Voici un schéma à droite qui représente les différentes étapes.<br>\n', '', '', NULL, '1719525934558.png', NULL, '', '', '', 2, 1, 4),
(36, '', '', '', '', '<span class=\"underline\">3 – Le débugger</span><br>\nCet assembleur est souvent accompagné d’un débugger, qui peut être utilisé pour voir ce qui se passe dans la mémoire de l’ordinateur. <br>\nPar exemple, ton programme, une fois assemblé, exécuté puis envoyé dans la RAM, peut tout à fait être visible par ce débugger ; il permet notamment de suivre pas à pas le comportement de ton programme.<br>\n<br>\nSur <span class=\"italic\">Atari ST</span>, l’assembleur le plus populaire est <span class=\"hashtag\">DevPac v3</span> de chez Hisoft<span class=\"italic\"> (jette un œil dans le menu de l’unité C du site)</span>. Sur PC, plusieurs solutions sont possibles pour les éditeurs, par exemple le tout simple mais efficace <span class=\"hashtag\">Notepad++</span> ou carrément des IDE comme <span class=\"hashtag\">VS Code</span>.', '', NULL, NULL, NULL, '', '', '', 2, 6, 4),
(37, '', '', '', '', '', 'Cette introduction est terminée, mais il va falloir encore patienter un tout petit peu avant de commencer à coder quelque chose. Il faut configurer ton émulateur et pour débuter je te propose l’utilisation de <span class=\"hashtag\">Hatari</span> et de l’assembleur <span class=\"hashtag\">DevPac v3</span>.', NULL, NULL, NULL, '', '', '', 2, 4, 4),
(38, '', '', 'III. Configuration de l’émulateur Hatari', '', '', '<span class=\"underline\">1 – Le TOS</span><br>\n<br>\nLa première fois que tu vas lancer <span class=\"bold\">Hatari</span>, tu n’auras pas le bureau de GEM traditionnel que tu connais, mais un autre, c’est <span class=\"hashtag\">EmuTOS</span> ! Pour faire court, c’est un TOS plus évolué que l’original avec des options supplémentaires dans les menus entre autres choses. Pour vulgariser, le TOS c\'est le programme qui fait tourner ton Atari ST, tout comme Microsoft avait le DOS pour faire tourner Windows. Le GEM c\'est le nom de l\'interface toute verte qui sert de bureau.', NULL, NULL, NULL, '', '', '', 3, 4, 4),
(39, '', '', '', '', '', '', NULL, NULL, '1719526300168.png', '', '', '', 3, 5, 4),
(40, '', '', '', '', '', '<div class=\"border-green\"><p>Si tu préfères un TOS original, je te propose le <span class=\"hashtag\">TOS 1.62</span> qui correspond à la gamme des <span class=\"italic\">Atari 1040 STe</span>. Tu trouveras ton bonheur dans l’unité C du site (je n’ai mis que les TOS ‘french’).</p></div><br>\n<br>\nSi tu souhaites en revanche garder <span class=\"hashtag\">EmuTOS</span>, pas de souci mais on va en choisir un qui est en français, c’est quand même mieux. Bref, choisis ton TOS du moment qu’il est compatible avec un STE (bah oui, qui peut le plus peut le moins).', NULL, NULL, NULL, '', '', '', 3, 4, 4),
(41, '', '', '', 'Tu copies le fichier à la racine du répertoire de <span class=\"bold\">HATARI</span> ou, si tu préfères, tu te fais un dossier. Dans <span class=\"bold\">HATARI</span>, tu fais :<br>\n<br>\n<span class=\"keyboard-key\">F12</span> -> <span class=\"color-green\">ROM</span> et dans la zone <span class=\"color-green\">TOS Setup</span> tu peux voir qu’actuellement c’est le fichier <span class=\"italic\">tos.img</span> qui est mis par défaut.<br>\nDonc tu cliques sur le bouton <span class=\"color-green\">Browse</span> pour choisir le TOS que tu as téléchargé.<br>\n<br>\nPuis <span class=\"color-green\">OK</span> -> <span class=\"color-green\">Back to main menu</span> -> <span class=\"color-green\">Save config</span> -> <span class=\"color-green\">OK</span> -> <span class=\"color-green\">Reset machine</span> -> <span class=\"color-green\">OK</span> … et là PAF ! <br>\nUn nouveau TOS ! Ou pas … si <span class=\"bold\">HATARI</span> détecte un nouveau TOS, il va configurer tout seul le reste pour être en adéquation avec le TOS que tu lui as mis.<br>\n<br>\nEn général, tu as le message suivant :', '', '', NULL, NULL, NULL, '', '', '', 3, 1, 4),
(42, '', '', '', '', '', '', NULL, NULL, '1719526461590.png', '', '', '', 3, 5, 4),
(43, '', '', '', '', '', 'Et voilà ta machine est prête !<br>\n<br>\nEnfin … presque, il y a deux trois petites choses à savoir. Quand tu vas commencer à coder, tu vas devoir enregistrer tes programmes ainsi que tes nombreux fichiers de sprites sur des disquettes … <div class=\"border-red\"><p>mais là je te déconseille de miser sur ce support d’autant plus qu’à l’époque on pouvait brancher un disque dur au cul de l’Atari !</p></div> Et donc c’est ce que l’on va faire … au moins virtuellement !', NULL, NULL, NULL, '', '', '', 3, 4, 4),
(44, '', '', '', '', '', '', NULL, NULL, '1719526592996.png', '', '', '', 3, 5, 4),
(45, '', '2 – Hard Drive Disk', '', '', 'Les disques durs ACSI (Atari Computer System Interface) étaient des périphériques de stockage utilisés avec les micro-ordinateurs Atari ST. <br>\n<br>\nL\'<span class=\"hashtag\">ACSI</span> est une interface propriétaire développée par Atari, basée sur une version simplifiée de l\'interface <span class=\"hashtag\">SCSI</span> <span class=\"italic\">(Small Computer System Interface)</span>.', '', '1719526666443.png', NULL, NULL, '', '', '', 3, 6, 4),
(46, '', '', '', '', '', 'Il te faut une image vierge de ce support pour l’utiliser avec l’émulateur <span class=\"bold\">HATARI</span>, en voici une <a class=\"file\" href=\"assets/files/ACSI_harddrive_image.80.zip\" target=\"blank\">ACSI_harddrive_image.80</a> qui fait 80 Mb. Colles-moi ça à la racine de ton dossier Hatari.<br>\n<br>\nUn petit <span class=\"keyboard-key\">F12</span> -> <span class=\"color-green\">Hard Disks</span> et on va dans <span class=\"color-green\">ACSI HD</span> -> <span class=\"color-green\">Browse</span> et choisis le fichier que tu viens de copier.<br>\nEnsuite, coche la case <span class=\"color-green\">Boot from hard disk</span>, puis la même chose que d’habitude : <br>\n<span class=\"color-green\">Back to main menu</span> -> <span class=\"color-green\">Save config</span> -> <span class=\"color-green\">OK</span> -> <span class=\"color-green\">Reset machine</span> -> <span class=\"color-green\">OK</span>.<br>\n<br>\nLà tu devrais voir ceci. : ', NULL, NULL, NULL, '', '', '', 3, 4, 4),
(47, '', '', '', '', '', '', NULL, NULL, '1719526785197.png', '', '', '', 3, 5, 4),
(48, '', '', '', '', '', 'Si tu ouvres le disque C, tu verras qu’il n’y a rien mis à part un fichier nommé <span class=\"bold\">SHDRIVER.SYS</span>.<br>\n<br>\n<div class=\"border-red\"><p> NE L’EFFACE JAMAIS SINON TU PEUX DIRE ADIEU À CE QUE CONTIENT TON DISQUE DUR !</p></div><br>\n<br>\nBref, dans ce disque dur tu pourras y mettre par exemple <span class=\"bold\">DevPac</span>, tes sources (c’est comme ça qu’on appelle le code que tu vas taper) et tous les outils qui ont besoin à l’origine de lire des disquettes : gros gain de temps et d’ergonomie !<br>\n<br>\n<br>\nMais ce n’est pas encore suffisant, il y a mieux. <br>\nJe t’explique, une fois tes sources enregistrées dans ce disque dur de type <span class=\"bold\">ACSI</span>, c’est mort pour que tu puisses y avoir accès une fois l’émulateur fermé. Imagine le scénario : ton pote a un <span class=\"bold\">Ultra Satan</span> et il veut tester ton code sur sa machine, pas pratique sans accès direct aux fichiers depuis ton PC. Donc je te montre une solution magique, tu vas créer un dossier à la racine de ton répertoire où se trouve ton émulateur. <br>\n', NULL, NULL, NULL, '', '', '', 3, 4, 4),
(49, '', '', '', '', 'Tu vas l’appeler « Hard Drive » ou ce que tu veux, on s’en fout. Et dans ce même répertoire, tu vas créer plusieurs sous-dossiers genre D, E, F, G, H, I, J … etc.<br>\n<br>\nDans ton émulateur : <span class=\"keyboard-key\">F12</span> -> <span class=\"color-green\">Hard disk</span> -> <span class=\"color-green\">GEMDOS Drive</span>, tu choisis le dossier hard_drive que tu as créé, puis n’oublie pas de cocher la case <span class=\"color-green\">Add GEMDOS HD after</span> blablabl …<br>\n<span class=\"color-green\">Back to main menu</span> -> <span class=\"color-green\">Save config</span> -> <span class=\"color-green\">OK</span> -> <span class=\"color-green\">Reset machine</span> -> <span class=\"color-green\">OK</span>.<br>\n<br>\nAlors là tu te dis « mais il a craqué <span class=\"bold\">HATARI</span>, pourquoi il marque que c’est une cartouche ? » … et bien j’en sais rien, je me suis dit la même chose que toi, on va le virer : <br>\n<br>\nTu sélectionnes C : Cartouche et dans le menu du GEM tu vas dans <span class=\"color-green\">Options</span> -> <span class=\"color-green\">Installer une unité de disque</span> -> <span class=\"color-green\">Enlever</span>.', '', '1719526928842.png', NULL, NULL, '', '', '', 3, 6, 4),
(50, '', '', '', '', '', 'Ensuite tu refais la même manipulation en sélectionnant C : Disque. Mais cette fois-ci tu mets « installer » au lieu d’enlever comme ceci :', NULL, NULL, NULL, '', '', '', 3, 4, 4),
(51, '', '', '', '', '', '', NULL, NULL, '1719527007777.png', '', '', '', 3, 5, 4);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(52, '', '', '', '', '', 'À partir de maintenant, tous les fichiers que tu copieras dans le dossier <span class=\"bold\">hard_drive/D</span> de ton PC seront visibles également dans le GEM de ton émulateur ! À toi d’en créer le nombre que tu veux du moment que ça te permette d’être organisé pour la suite !<br>\n<br>\n<br>\n<span class=\"underline\">3 – Le clavier</span><br>\n<br>\nPour finir, la configuration du clavier dans l’émulateur doit être réglée sur  <span class=\"color-green\">Scancode</span>. Cela te simplifiera l’écriture du code en utilisant les touches réelles de ton clavier PC.<br>\nVoilà, c’est terminé ! À partir de maintenant, tu possèdes un <span class=\"bold\">Atari 1040 ST</span> dans ton PC ! Nous allons pouvoir passer à la suite !', NULL, NULL, NULL, '', '', '', 3, 4, 4),
(53, '', '', '', '', '', '', NULL, NULL, '1719527081890.png', '', '', '', 3, 5, 4),
(54, '', '', '', '', '', 'Dans ton premier cours <span class=\"italic\">« Savoir configurer ses outils de développement »</span>, je te parlais de la transformation de ton code source assembleur en <span class=\"color-red\">langage machine</span>, c\'est-à-dire en <span class=\"color-red\">binaire</span>. Le binaire est une suite de 0 et de 1. <span class=\"color-red\">Chaque 0 et chaque 1 sont ce que l\'on appelle un bit</span>.<br>\nPour faciliter la gestion des informations, ces valeurs binaires sont regroupées en ensembles de 8 bits, appelés octets. Un bit est la plus petite unité d\'information et peut être soit 0 soit 1. Un octet, contenant 8 bits, peut représenter 256 valeurs différentes, allant de 0 à 255. Nous explorerons plus en détail comment ces bits se combinent pour former des valeurs et comment ces valeurs sont utilisées par l\'ordinateur.<br>\n<br>\n<div class=\"border-yellow\"><p>Donc, pour résumer, retiens ceci :<br>\n* Langage machine = langage binaire<br>\n* Langage binaire = une suite de 0 et de 1 (appelés bits)<br>\n* Un octet = 8 bits<br>\n* La valeur d\'un octet peut aller de 0 à 255</p></div><br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 5),
(56, '', '', '', 'Chaque position numérotée de 0 à 7, de droite à gauche, peut contenir un 0 ou un 1, formant ainsi un octet.<br>\nPourquoi est-ce important ? <span class=\"bold\">Parce que le processeur lit ces octets en mémoire vive (RAM) comme des instructions</span>. Pour lui, cette séquence d\'octets constitue un langage de commande. Chaque octet (ou ensemble d\'octets) est associé à une action spécifique que le processeur exécute.', '', '', NULL, '1721478870274.png', NULL, '', '', '', 1, 1, 5),
(57, '', '', '', '', '', 'Considérons l\'exemple de l\'instruction <span class=\"bold\">NOP</span>, l\'une des plus simples pour le processeur 68000. <span class=\"bold\">NOP</span> signifie \"ne rien faire\". Lorsque tu écris <span class=\"bold\">NOP</span> dans ton éditeur de code assembleur, cela se traduit par 2 octets consécutifs dont les valeurs sont respectivement 78 et 113. <span class=\"bold\"><span class=\"color-red\">Ces deux valeurs de 8 bits (autrement dit, \"ces deux octets de 8 bits\") combinées ensemble forment une instruction de 16 bits</span></span>. Cette instruction est appelée <span class=\"bold\">opcode</span>. Ces deux octets sont ensuite placés en RAM (mémoire vive) ou sauvegardés dans un fichier, selon tes besoins.<br>\nAinsi, lorsque le 68000 rencontre ces deux octets avec les valeurs 78 et 113, il les interprète comme l\'instruction <span class=\"bold\">NOP</span>. D\'autres valeurs auront des significations différentes, bien sûr.<br>\nPour compléter voici ci-dessous un aperçu d\'un mot (16bits) et d\'un mot long (32bits) : ', NULL, NULL, NULL, '', '', '', 1, 4, 5),
(58, 'Le Système Décimal', 'Le Système Binaire', '', 'Lorsque nous utilisons des chiffres dans la vie quotidienne, nous utilisons <span class=\"color-red\">le système décimal</span>. Ce système utilise dix symboles : 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9. Par exemple, les nombres que nous connaissons et utilisons couramment sont écrits en décimal : 1, 2, 3, 10, 100, 150, 200, etc.', 'Contrairement au système décimal, il n\'utilise que deux symboles : 0 et 1. Comment je te l\'ai déjà dit à la page précédente chaque 0 ou 1 est appelé un \"bit\"  et un groupe de 8 bits forme un \"octet\" <span class=\"italic\">(oui je sais ... je me répète mais c\'est comme çà que çà va finir par rentrer dans ta tête)</span>. <br>\nVoici un exemple d\'un nombre en binaire : <span class=\"bold\">%10100111</span>. <br>\n<span class=\"color-red\">Le caractère % avant la suite de bits indique que le nombre est écrit en binaire.</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 5),
(60, 'Conversion binaire en décimale', '', '', 'Revenons à notre octet. La valeur d\'un octet dépend de ce qu\'il contient. Par exemple, l\'octet <span class=\"bold\">%10100111</span> en binaire peut être converti en décimal. Pour comprendre cela, nous devons connaître la valeur de chaque bit. Chaque position de bit a une valeur spécifique <span class=\"bold\">qui se compte toujours de la droite vers la gauche</span> : Le bit le plus à droite (bit 0) a une valeur de 1, le suivant (bit 1) a une valeur de 2, le suivant (bit 2) a une valeur de 4 etc.<br>\nEn additionnant les valeurs des bits qui sont à 1, nous obtenons la valeur décimale de l\'octet. Pour <span class=\"bold\">%10100111</span>, nous avons : 128 + 32 + 4 + 2 + 1 = <span class=\"bold\">167</span><br>\nLe schéma de droite est assez facile à comprendre <span class=\"italic\">(que j\'ai d\'ailleurs emprunté au site <a class=\"link\" href=\"https://asmtradcpc.zilog.fr/\" target=\"blank\">https://asmtradcpc.zilog.fr/</a>).</span>', '', '', NULL, '1721577202083.png', NULL, '', '', '', 2, 1, 5),
(61, '', '', 'Le Système Hexadécimal', '', '', 'Il existe également un système de numération appelé hexadécimal, qui est souvent utilisé en informatique, sans une compréhension parfaite de ce système tu n\'iras pas bien loin. Ce système utilise seize symboles : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E et F.<br>\nVoici comment cela fonctionne :<br>\n* En décimal, nous comptons de 0 à 9, puis passons à 10.<br>\n* En hexadécimal, nous comptons de 0 à 9, puis nous continuons avec A (10 en décimal), B (11 en décimal), et ainsi de suite jusqu\'à F (15 en décimal).<br>\nVoici une séquence hexadécimale : <span class=\"bold\">$0, $1, $2, ..., $9, $A, $B, $C, $D, $E, $F</span><br>\nAprès $F, nous passons à $10 (16 en décimal), puis $11, $12, ... jusqu\'à $1F. Ce processus continue jusqu\'à $FF, qui équivaut à 255 en décimal.<br>\n<span class=\"color-red\">Le caractère $ avant la suite de bits indique que le nombre est écrit en hexadécimal.</span>', NULL, NULL, NULL, '', '', '', 3, 4, 5),
(62, '', 'Conversion décimal en binaire', '', '', 'C\'est tout aussi simple de convertir un nombre décimal en binaire. Prenons l\'exemple du nombre décimal 167. Le principe est simple : <span class=\"bold\"><span class=\"color-red\">on soustrait la valeur du bit la plus grande possible</span></span>. Donc, pour 167, on peut soustraire 128, et on met ce bit à \"1\". <br>\nTu vas me dire <span class=\"italic\">\"oui, mais on peut aussi utiliser 64\"</span>. Oui, mais NON, <span class=\"bold\">il faut que ce soit la valeur la plus grande possible</span>, donc 128.<br>\nOn doit procéder ainsi jusqu\'à ce que l\'on obtienne un reste de 0. Regarde à nouveau le schéma de gauche, c\'est assez simple à comprendre.', '', '1721579115783.png', NULL, NULL, '', '', '', 2, 6, 5),
(63, 'Conversion binaire en hexadécimal', '', '', 'Cette fois-ci, nous allons convertir notre octet binaire en hexadécimal. Je te rappelle que l\'hexadécimal est le système de numération que tu verras, par exemple, dans le débogueur de l\'assembleur DevPac.<br>\n<br>\nPour convertir un nombre binaire en hexadécimal (qu\'on appellera \"hexa\"), il suffit de <span class=\"color-red\">diviser l\'octet en deux parties</span>. Chaque partie est appelée un <span class=\"bold\">\"quartet\"</span> <span class=\"italic\">(oui, \"quartet\" comme \"4\" et \"octet\" comme \"8\", au cas où tu ne l\'aurais pas remarqué ;) )</span>. À gauche, en <span class=\"color-green\">vert</span>, tu as ce que l\'on appelle le <span class=\"color-green\">quartet de poids fort</span>, et à droite, en <span class=\"color-red\">rouge</span>, le <span class=\"color-red\">quartet de poids faible</span>. <br>\nEnsuite c\'est tout simple : il suffit d\'additionner les valeurs des bits de chaque quartet. Leur somme te donnera 2 valeurs <span class=\"italic\">(rappelle-toi que 10 en décimal correspond à $A en hexa)</span>.', '', '', NULL, '1721580830113.png', NULL, '', '', '', 3, 1, 5),
(64, '', '', 'Les valeurs supérieures à 255', '', '', 'Un octet est une série de 8 bits <span class=\"italic\">(oui, je sais, je le répète encore, et je comprends si tu commences à te lasser ! C\'est bon signe !)</span>. La valeur maximale d\'un octet est 255 <span class=\"italic\">(n\'oublie pas que 0 compte aussi comme une valeur)</span>. Mais on peut représenter des valeurs plus grandes en combinant plusieurs octets.<br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Voici quelques définitions :</span></span><br>\n<div class=\"border-yellow\"><p>Une \"valeur 8 bits\" est un nombre entre 0 et 255 et utilise 1 octet.<br>\nUne \"valeur 16 bits\" est un nombre entre 0 et 65 535 et utilise 2 octets.<br>\nLorsque la valeur dépasse 255, elle utilise deux octets.</p></div><br>\nDans ce cas, <span class=\"bold\"><span class=\"color-red\">l\'octet de gauche est appelé le \"poids fort\" et l\'octet de droite est appelé le \"poids faible\"</span></span>.<br>\nLe poids faible représente une valeur de 0 à 255, tandis que le poids fort multiplie cette valeur par 256.<br>\n<br>\n<span class=\"underline\">Mais que se passe-t-il lorsque l\'on dépasse 255 ?</span><br>\nEh bien, la valeur décimale 255 étant la plus grande pour 1 octet signifie que tous ses bits sont à 1 : <span class=\"bold\">%<span class=\"color-green\">11111111</span></span>. Si on fait la somme de la valeur de tous les bits, on obtient bien : <span class=\"bold\">128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255</span>.<br>\nOn peut aussi noter cette valeur en binaire <span class=\"underline\">en utilisant 2 octets</span> : <span class=\"bold\">%<span class=\"color-red\">00000000</span> <span class=\"color-green\">11111111</span> = 255</span>. <span class=\"color-red\">À gauche, tu as l\'octet de poids fort</span>, qui est égal à 0, et <span class=\"color-green\">à droite, le poids faible</span>, qui est à 255 pour le moment.<br>\n<br>\n<span class=\"bold\">Mais que se passe-t-il si tu ajoutes 1 à l\'octet de poids faible ?</span><br>\nTu obtiens <span class=\"bold\">%<span class=\"color-red\">00000001</span> <span class=\"color-green\">00000000</span></span>. Tous les bits qui étaient à \"1\" dans l\'octet de poids faible sont passés à \"0\"! De plus, tu remarques que le bit le plus faible de l\'octet de poids fort passe de \"0\" à \"1\".', NULL, NULL, NULL, '', '', '', 3, 4, 5),
(65, 'Éléments de Gameplay', '', '', 'Le jeu tourne à 25Hz, avec des sprites de grande taille, le héros, et le défilement. Le jeu est conçu pour être compatible avec le clavier et le joystick. Trois boutons sont nécessaires : un pour l\'épée, un pour les actions magiques, et un pour afficher un tableau de choix d\'équipements. <span class=\"bold\">Samuel Blanchard</span> <span class=\"italic\">(l\'auteur de cette futur pépite)</span> a également introduit des éléments de gameplay tels que des sprites pré-calculés et des récompenses aléatoires pour maintenir l\'intérêt des joueurs.<br>\n<span class=\"italic\">(superbe titre \"Monster Boy In Dragon Land\" par <span class=\"bold\">Pépé Peek-poke</span>)</span>', '', '', NULL, '1721664825215.webp', NULL, '', '', '', 1, 1, 6),
(66, '', '', 'Développement des Niveaux', '', '', 'Le premier niveau du jeu, situé dans le pays des elfes, a commencé à prendre forme. Ce niveau test a été crucial pour permettre au héros de gagner une armure. Les retours sur ce niveau ont été positifs, notamment en ce qui concerne le rendu graphique. Mais les retour de quoi, de qui ??? Ah je vous ai pas dit, <span class=\"bold\">Samuel</span> a également partagé des vidéos et des démos jouables pour permettre aux membres de suivre les progrès en temps réel !<br>\nD\'ailleurs une discussion a été lancée sur le groupe pour déterminer si le jeu devrait avoir un monde ouvert ou fermé. Les membres ont exprimé des avis partagés, certains préférant un chemin linéaire tandis que d\'autres favorisaient une progression plus libre.', NULL, NULL, NULL, '', '', '', 1, 4, 6),
(68, '', '', '', '', '', '', '1721665306169.webp', '1721665306170.webp', NULL, '', '', '', 1, 2, 6),
(69, '', 'Fonctionnalités et Ajustements Techniques', '', '', 'Les progrès sont réguliers et impressionnants. Parmi les fonctionnalités récemment ajoutées figurent la gestion des points de vie des monstres, un système de récompenses aléatoires, et diverses améliorations de l\'animation et des interactions des objets. Par exemple, des pièces et des cœurs miniatures peuvent maintenant sauter avec ou sans rebond, et une nouvelle poussière apparaît après la mort d\'un monstre.', '', '1721665616834.webp', NULL, NULL, '', '', '', 1, 6, 6),
(73, 'Raster Studio', '', '', '<span class=\"bold\">Samuel</span> ne se contente pas de développer le jeu; il crée également ses propres outils pour optimiser le développement et faciliter / améliorer le processus de création. Récemment, il a introduit <span class=\"bold\"><a class=\"link\" href=\"https://apps.microsoft.com/detail/9n52p0rm4gvm\" target=\"blank\">Raster Studio</a></span>, une application dédiée à la génération de rasters pour Atari ST. <br>\nLes rasters sont essentiels pour créer des effets visuels dynamiques, comme les fondus et les dégradés de couleurs. Ce nouvel outil vise à simplifier et perfectionner l\'intégration de ces effets dans le jeu.<br>\n<br>\nConcernant la gestion des interruptions, essentielle pour les performances et la fluidité du jeu, <span class=\"bold\">Samuel</span> travaille à optimiser les cycles de l\'écran vertical (VBL). Le jeu tourne actuellement à 25Hz avec quelques grands sprites pour les méchants, les animations et le scrolling... et .... la musique ? Pas grave il est attentif à la consommation de VBL par la musique, afin de réduire cette consommation pour libérer des ressources CPU pour d\'autres fonctionnalités du jeu, mais quand on voit ce qu\'il est capable de réaliser je n\'ai aucun doute sur le résultat final !', '', '', NULL, '1721667548631.webp', NULL, '', '', '', 1, 1, 6),
(74, '', '', '', '', '', 'L\'enthousiasme autour de Miracle Boy in Dragon Land est palpable au sein de la communauté. Chaque mise à jour et nouvelle fonctionnalité est accueillie avec des éloges et des suggestions constructives, témoignant de l\'engagement et de l\'excitation collective pour ce projet qui, sans aucun doute, deviendra une référence pour les amateurs de jeux rétro sur Atari ST.<br>\n<br>\n<a class=\"link\" href=\"https://www.facebook.com/groups/383252337204206/user/1041409691\" target=\"blank\">Facebook de Samuel Blanchard</a><br>\n<a class=\"link\" href=\"https://www.facebook.com/groups/383252337204206\" target=\"blank\">Facebook du groupe Miracle Boy In Dragon Land</a><br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 6),
(75, '', '', 'BIOS (& XBIOS)', '', '', '<span class=\"bold\"><span class=\"color-red\">0</span> E_OK</span> <span class=\"italic\">OK. Aucun problème n\'est survenu.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-1</span> ERROR</span> <span class=\"italic\">Erreur générique (non précisée exactement).</span><br>\n<span class=\"bold\"><span class=\"color-red\">-2</span> EDRVNR</span> <span class=\"italic\">Dispositif/lecteur adressé non prêt.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-3</span> EUNCMD</span> <span class=\"italic\">Commande spécifiée inconnue.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-4</span> E_CRC</span> <span class=\"italic\">Erreur lors de la lecture d\'un secteur / Erreur CRC.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-5</span> EBADRQ</span> <span class=\"italic\">Mauvaise demande / Le dispositif ne peut pas exécuter la commande.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-6</span> E_SEEK</span> <span class=\"italic\">Le lecteur n\'a pas pu atteindre la piste spécifiée.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-7</span> EMEDIA</span> <span class=\"italic\">Erreur de lecture (le support a un mauvais secteur de démarrage).</span><br>\n<span class=\"bold\"><span class=\"color-red\">-8</span> ESECNF</span> <span class=\"italic\">Secteur non trouvé.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-9</span> EPAPER</span> <span class=\"italic\">Imprimante non prête / Plus de papier.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-10</span> EWRITF</span> <span class=\"italic\">Erreur lors d\'une opération d\'écriture.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-11</span> EREADF</span> <span class=\"italic\">Erreur lors d\'une opération de lecture.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-12</span> EGENRL</span> <span class=\"italic\">Erreur générale.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-13</span> EWRPRO</span> <span class=\"italic\">Le support est protégé en écriture.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-14</span> E_CHNG</span> <span class=\"italic\">Le support a été changé après une opération d\'écriture.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-15</span> EUNDEV</span> <span class=\"italic\">Dispositif inconnu du système d\'exploitation.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-16</span> EBADSF</span> <span class=\"italic\">Secteurs défectueux détectés lors du formatage.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-17</span> EOTHER</span> <span class=\"italic\">Un autre disque doit être inséré.</span><br>\n<div class=\"border-red\"><p>Cette erreur apparaît uniquement si le lecteur B est accédé sans qu\'il ne soit connecté.<br>\nDans ce cas, l\'utilisateur est invité à insérer un disque dans le premier lecteur.</p></div><br>\n<br>\n<span class=\"bold\"><span class=\"color-red\">-18</span> EINSERT</span> <span class=\"italic\">Erreur MetaDOS : Insérez le support.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-19</span> EDVNRSP</span> <span class=\"italic\">Erreur MetaDOS : Le dispositif ne répond pas.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-128</span> SNDNOTLOCK</span> <span class=\"italic\">XBIOS Falcon : Système sonore non réservé.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-129</span> SNDLOCKED</span> <span class=\"italic\">XBIOS Falcon : Système sonore déjà réservé.</span><br>\n<br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 7),
(76, 'GEMDOS', '', '', '<span class=\"bold\"><span class=\"color-red\">0</span> E_OK</span> <span class=\"italic\">OK. Aucun problème n\'est survenu.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-32</span> EINVFN</span> <span class=\"italic\">Numéro de fonction inconnu.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-33</span> EFILNF</span> <span class=\"italic\">Fichier non trouvé.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-34</span> EPTHNF</span> <span class=\"italic\">Répertoire (dossier) non trouvé.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-35</span> ENHNDL</span> <span class=\"italic\">Plus de poignées disponibles.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-36</span> EACCDN</span> <span class=\"italic\">Accès refusé.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-37</span> EIHNDL</span> <span class=\"italic\">Identifiant de fichier invalide.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-39</span> ENSMEM</span> <span class=\"italic\">Mémoire insuffisante.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-40</span> EIMBA</span> <span class=\"italic\">Adresse de bloc mémoire invalide.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-46</span> EDRIVE</span> <span class=\"italic\">Spécification de lecteur invalide.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-47</span> ECWD</span> <span class=\"italic\">Le répertoire courant ne peut pas être supprimé.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-48</span> ENSAME</span> <span class=\"italic\">Fichiers sur des lecteurs logiques différents.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-49</span> ENMFIL</span> <span class=\"italic\">Plus de fichiers ne peuvent être ouverts.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-58</span> ELOCKED</span> <span class=\"italic\">Segment d\'un fichier protégé (réseau).</span><br>\n<span class=\"bold\"><span class=\"color-red\">-59</span> ENSLOCK</span> <span class=\"italic\">Demande de suppression de verrou invalide.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-64</span> ERANGE</span> <span class=\"italic\">Pointeur de fichier dans un segment invalide (voir aussi message FreeMiNT -88).</span><br>\n<span class=\"bold\"><span class=\"color-red\">-65</span> EINTRN</span> <span class=\"italic\">Erreur interne de GEMDOS.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-66</span> EPLFMT</span> <span class=\"italic\">Format de chargement de programme invalide.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-67</span> EGSBF</span> <span class=\"italic\">Bloc mémoire alloué ne peut pas être agrandi.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-68</span> EBREAK</span> <span class=\"italic\">Interruption du programme par Control-C.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-69</span> EXCPT</span> <span class=\"italic\">Exception 68000 (bombes).</span><br>\n<span class=\"bold\"><span class=\"color-red\">-70</span> EPTHOV</span> <span class=\"italic\">Dépassement de chemin.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-80</span> ELOOP</span> <span class=\"italic\">Boucle infinie avec liens symboliques.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-81</span> EPIPE</span> <span class=\"italic\">Ecriture dans un pipe cassé.</span>', '<span class=\"bold\"><span class=\"color-red\">-82</span> EMLINK</span> <span class=\"italic\">Trop de liens.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-83</span> ENOTEMPTY</span> <span class=\"italic\">Répertoire non vide.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-85</span> EEXIST</span> <span class=\"italic\">Fichier existe déjà.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-86</span> ENAMETOOLONG</span> <span class=\"italic\">Nom trop long.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-87</span> ENOTTY</span> <span class=\"italic\">Pas un TTY.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-88</span> ERANGE</span> <span class=\"italic\">Erreur de plage.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-89</span> EDOM</span> <span class=\"italic\">Erreur de domaine.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-90</span> EIO</span> <span class=\"italic\">Erreur d\'entrée/sortie.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-91</span> ENOSPC</span> <span class=\"italic\">Plus d\'espace disponible sur le dispositif.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-100</span> EPROCLIM</span> <span class=\"italic\">Trop de processus pour l\'utilisateur.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-101</span> EUSERS</span> <span class=\"italic\">Trop d\'utilisateurs.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-102</span> EDQUOT</span> <span class=\"italic\">Quota dépassé.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-103</span> ESTALE</span> <span class=\"italic\">Descripteur de fichier NFS obsolète.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-104</span> EREMOTE</span> <span class=\"italic\">Objet distant.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-105</span> EBADRPC</span> <span class=\"italic\">Structure RPC invalide.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-106</span> ERPCMISMATCH</span> <span class=\"italic\">Version RPC incorrecte.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-107</span> EPROGUNAVAIL</span> <span class=\"italic\">Programme RPC non disponible.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-108</span> EPROGMISMATCH</span> <span class=\"italic\">Version de programme RPC incorrecte.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-109</span> EPROCUNAVAIL</span> <span class=\"italic\">Procédure RPC incorrecte pour le programme.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-110</span> ENOLCK</span> <span class=\"italic\">Aucun verrou disponible.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-111</span> EAUTH</span> <span class=\"italic\">Erreur d\'authentification.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-112</span> ENEEDAUTH</span> <span class=\"italic\">Authentificateur requis.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-113</span> EBACKGROUND</span> <span class=\"italic\">Opération inappropriée pour un processus en arrière-plan.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-114</span> EBADMSG</span> <span class=\"italic\">Pas un message de données.</span><br>\n<span class=\"bold\"><span class=\"color-red\">-115</span> EIDRM</span> <span class=\"italic\">', '', NULL, NULL, NULL, '', '', '', 1, 3, 7),
(77, 'Installation de DevPac 3.10', '', '', 'C\'est parti ! Tu vas commencer par télécharger l\'assembleur dont je t\'ai déjà parlé. Tu le trouveras sur ce site <span class=\"bold\">en cliquant sur les unités de disque</span>. Décompresse le contenu de l\'archive dans ton dossier <span class=\"bold\">Hatari</span> <span class=\"italic\">(ce sera plus simple à retrouver)</span>. D\'ailleurs, je crois qu\'<span class=\"bold\">Hatari</span> est capable de lire le fichier <span class=\"bold\">.st</span> contenu dans le <span class=\"bold\">.zip</span> sans avoir besoin de décompresser l\'archive.<br>\n<br>\nEnsuite, lance ton émulateur (pour ceux qui n\'ont pas de vraies machines) et charge ton fichier <span class=\"bold\">.st</span> <span class=\"color-red\">dans le lecteur de disquette A.</span><br>\n<br>\nAppuie sur <span class=\"keyboard-key\">F12</span> -> <span class=\"color-green\">Floppy disks</span> -> <span class=\"color-green\">Drive A: Browse</span> -> et cherche ton fichier. Pour quitter la configuration de l\'émulateur, tu es censé savoir comment faire désormais, je ne te l\'expliquerai plus.', '', '', NULL, '1721932618232.png', NULL, '', '', '', 1, 1, 8),
(78, '', '', '', '', '', '', '1721933424275.png', '1721933424278.png', NULL, '', '', '', 1, 2, 8),
(79, '', '', '', '', '', 'Tu vas devoir regarder dans la disquette et rechercher un programme appelé <span class=\"bold\">DEVINST.PGR</span>. C\'est le programme d\'installation de Devpac. Réponds <span class=\"bold\">YES</span> lorsqu\'il te demandera si tu possèdes un disque dur. (<span class=\"italic\">Alors oui, tout est en anglais, arrête de te plaindre ! Si tu es un vrai, tu lis EN ANGLAIS ! Et si ça ne te plaît pas, retourne glander sur TikTok !).</span> Normalement, tu laisses tout par défaut. Tu peux changer le C:/ si tu veux l\'installer ailleurs, par exemple sur D:/ ou E:/ ... bref, fais comme bon te semble, cela ne change absolument rien. <br>\n<br>\n<div class=\"border-red\"><p>Attention, il est possible que le programme d\'installation te sorte des erreurs comme d\'insérer le disque maître de Devpac. Ignore ces messages, ça fonctionnera.</p></div><br>\n<br>\nVoilà, <span class=\"bold\">DevPac 3.10</span> est installé sur ton disque dur. Cela te permettra d\'avoir un accès rapide à ton éditeur.', NULL, NULL, NULL, '', '', '', 1, 4, 8),
(81, '', 'Associer les fichiers sources', '', '', 'Dernière petite chose qui va te faire gagner du temps. Les fichiers sources contenant ton code assembleur se terminent par <span class=\"bold\">.S</span> (comme source). Il peut être pénible d\'ouvrir DevPac, puis de naviguer dans la fenêtre de chargement pour cliquer sur le fichier source à ouvrir.<br>\n<br>\nD\'autant plus que si tu stockes tes sources sur l\'unité <span class=\"bold\">D:/</span> ou <span class=\"bold\">E:/</span> <span class=\"italic\">(ce que je te conseille fortement afin de pouvoir y accéder depuis l\'extérieur de l\'émulateur)</span>, tu risques d\'avoir à faire un certain nombre de clics pour les atteindre.<br>\n<br>\nDonc, c\'est simple, cela se passe dans le bureau du GEM <span class=\"italic\">(le menu que tu vois sur ma capture d\'écran, c\'est le GemTos et non le TOS original)</span>. Va dans ton dossier <span class=\"bold\">Devpac</span> et sélectionne le programme <span class=\"bold\">DEVPAC.PRG</span> que tu viens d\'installer sur ton disque dur. Ensuite, vas dans <span class=\"color-green\">Option</span> -> <span class=\"color-green\">Installer application...</span><br>\n<br>\nTu n\'as qu\'à remplir le champ \"Type de document\" en saisissant S.', '', '1721935128031.png', NULL, NULL, '', '', '', 1, 6, 8),
(82, 'Configuration de DevPac', '', '', 'Tu vas créer ton premier fichier source ! Cela te permettra de naviguer un peu dans les menus de configuration de DevPac. Allez hop, tu exécutes <span class=\"bold\">DEVPAC.PRG</span>, et la première fenêtre que tu vois, c\'est ton éditeur de code ! C\'est là que tu devras saisir les instructions de tes programmes. Je vais te demander de saisir le texte suivant :<br>\n<span class=\"code\">;* Mon premier code source *<br>\n<br>\n; author : Mets ton nom<br>\n; creation date : Mets la date d\'aujourd\'hui<br>\n; ©2024</span><br>\n<br>\nRencontres-tu des problèmes pour saisir certains symboles ? Le pavé numérique te pose-t-il des soucis, par exemple ?', '', '', NULL, '1721936535237.png', NULL, '', '', '', 1, 8, 8),
(84, '', '', '', '', '', 'Pour le problème que tu rencontres avec le pavé numérique, rends-toi dans le menu <span class=\"color-green\">Options</span> -> <span class=\"color-green\">Preferences</span> ou bien <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">T</span>, décoche la case <span class=\"bold\">\"Cursor mode numeric keypad\"</span>, puis clique sur <span class=\"bold\">OK</span>. De retour dans ton éditeur de code, tu pourras utiliser le pavé numérique.<br>\n<div class=\"border-yellow\"><p>À noter que ces options de configuration doivent être sauvegardées avec le bouton <span class=\"bold\">Save As...</span> sous la forme d\'un fichier nommé <span class=\"bold\">HISOFTED.INF</span>, que DevPac range dans son dossier d\'installation. Sinon, à chaque ouverture de DevPac, les options se réinitialiseront.</p></div><br>\n<br>\nPour le symbole copyright ©, tu peux le trouver dans les caractères spéciaux. Ils se trouvent dans le menu <span class=\"color-green\">Edit</span> -> <span class=\"color-green\">ASCII Table... </span> ou bien <span class=\"keyboard-key\">Shift</span> + <span class=\"keyboard-key\">Ins</span>). Il te suffit de cliquer sur le caractère de ton choix pour l\'insérer dans ta fenêtre d\'édition.', NULL, NULL, NULL, '', '', '', 1, 4, 8),
(85, '', '', '', '', '', '', '1721938170145.png', '1721938170148.png', NULL, '', '', '', 1, 2, 8),
(86, '', '', '', 'Aller, c\'est fini ! Tu vois, ce n\'était ni long ni compliqué, mais ça fait partie des choses qu\'il faut savoir faire, comme sauvegarder ton fichier avant de quitter le programme. Menu <span class=\"color-green\">File</span> -> <span class=\"color-green\">Save</span> ou <span class=\"color-green\">Save As...</span><br>\n<br>\nD\'ailleurs, essaie de mémoriser les raccourcis clavier, <span class=\"underline\"><span class=\"bold\">tu gagneras énormément de temps</span></span>, et ça fait partie de ton apprentissage ... je dis ça, je ne dis rien ...<br>\n<span class=\"bold\">Save</span> c\'est <span class=\"keyboard-key\">Shift</span> + <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">S</span><br>\n<span class=\"bold\">Save As ...</span> c\'est juste <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">S</span><br>\n<br>\nBon, je te laisse fermer DevPac et double-cliquer sur ton fichier <span class=\"bold\">TEST.S</span>. Il va s\'ouvrir et lancer DevPac en même temps : une pierre, deux coups !', '', '', NULL, '1721938808562.png', NULL, '', '', '', 1, 1, 8),
(87, '', '', '', '', '', 'Je tiens à insister sur le fait que créer <span class=\"bold\"><span class=\"color-red\">un RAM Disk ne remplacera jamais un vrai disque dur</span></span>, même si ton Atari ST est équipé de 4 Mo de RAM. Cette utilisation n\'est pertinente que si l\'on souhaite, par exemple, travailler sur plusieurs fichiers, que ce soient des fichiers MIDI pour la musique, des fichiers textes pour croiser plusieurs courriers, ou, pire encore, plusieurs images à retoucher. Les accès aux fichiers sur un support tel que la disquette demandent un certain temps de chargement. En cela, créer un RAM Disk peut faire gagner du temps :<br>\n<br>\n * On copie une seule fois tous les fichiers dont on a besoin (quelque part dans la RAM).<br>\n * On travaille autant de fois que nécessaire sur ces fichiers.<br>\n * Une fois le travail terminé, on n\'oublie surtout pas de les sauvegarder à nouveau sur un support disquette.<br>\n<br>\n<div class=\"border-red\"><p><span class=\"underline\">Attention :</span> placer tes fichiers dans un RAM Disk n\'est pas sans risque. <span class=\"bold\">Cela peut entraîner une perte totale du travail réalisé !</span> Par exemple, si tu subis un gros plantage logiciel qui t\' obliges à redémarrer ta machine ... il faut y penser ! La RAM est une mémoire temporaire, donc tu es prévenu faudra pas venir pleurer !.</p></div>', NULL, NULL, NULL, '', '', '', 1, 4, 9),
(88, 'M-Disk, un outil très pratique !', '', '', 'C\'est un outil que tu trouveras dans <span class=\"bold\">l\'unité de disque E:/ </span>du site, appelé <span class=\"bold\">\"Utilitaires\"</span>. Tu le télécharges et tu insères cette disquette dans le lecteur A de ton émulateur ou de ton Atari. Ensuite, tu redémarres ta machine avec la disquette dans le lecteur pour booter dessus.<br>\n<br>\nLa disquette contient un fichier <span class=\"bold\">.ACC</span> (un fichier accessoire). Une fois que ton bureau GEM est affiché à l\'écran, va dans le menu Bureau, tu y verras <span class=\"bold\">M-Disk 6.0</span>. Clique dessus et nous allons configurer ton RAM Disk !', '', '', NULL, '1722028034199.png', NULL, '', '', '', 1, 1, 9),
(89, '', 'Configuration de M-Disk', '', '', 'Jette un œil sur la première ligne, c\'est la plus importante : <span class=\"bold\">\"Ram disk size\"</span>. C\'est ici que tu vas déterminer la taille de ta RAM Disk <span class=\"underline\">en octets</span>. Si tu possèdes un Atari avec 4 Mo de RAM, tu peux mettre, par exemple, 1 Mo ou même 2 Mo pour être tranquille, à toi de voir. Clique sur le bouton <span class=\"bold\">\"Remove\"</span>, puis saisis une valeur (<span class=\"italic\">en octets : 1000 pour 1 Mo, 2000 pour 2 Mo, etc.).</span><br>\n<br>\nTout en bas, c\'est écrit <span class=\"bold\">\"Label\"</span>. Moi, j\'ai déjà tout un tas d\'unités de disque dur, donc <span class=\"bold\">M-Disk</span> a détecté que l\'unité suivante disponible était <span class=\"bold\">M</span>. Mais si tu n\'as aucun disque dur, tu auras probablement <span class=\"bold\">C</span>. Clique sur <span class=\"bold\">OK</span>, et c\'est terminé !', '', '1722028542448.png', NULL, NULL, '', '', '', 1, 6, 9),
(90, '', '', '', '', '', 'De retour sur le bureau, tu dois ajouter cette nouvelle unité que l\'on vient de créer à l\'intérieur de la RAM. Pour cela, <span class=\"bold\">sélectionne l\'unité A</span> et dans le menu <span class=\"color-green\">Options</span>  -> <span class=\"color-green\">Installer une unité disque</span>.<br>\n<br>\nUne fenêtre de dialogue te demandera de préciser l\'unité. Tu dois choisir <span class=\"color-red\"><span class=\"bold\">C si M-Disk t\'a proposé C, ou une autre lettre selon ce que M-Disk t\'aura proposé</span></span> <span class=\"italic\">(dans mon cas c\'était M)</span>. Ensuite, indique un nom, celui que tu veux, ça n\'a pas d\'importance.', NULL, NULL, NULL, '', '', '', 1, 4, 9),
(91, '', '', '', '', '', '', '1722028991710.png', '1722028991714.png', NULL, '', '', '', 1, 2, 9),
(92, '', '', '', '', '', '', NULL, NULL, '1722029173503.png', '', '', '', 1, 5, 9),
(93, 'La RAM', '', '', 'La RAM est avant tout un composant électronique qui, selon le modèle d\'Atari, est soit soudé, soit clipsé dans des slots comme le montre la photo. Sur un <span class=\"bold\">Atari 1040STe</span>, il y a 4 slots. Il est donc possible d\'obtenir différentes combinaisons de RAM : <span class=\"bold\">512 Ko, 1 Mo, 2 Mo, 2,5 Mo ou 4 Mo</span>.<br>\n<br>\nLes 4 slots sont répartis sur <span class=\"underline\">deux banques de mémoire</span>. Chacune peut avoir une capacité de <span class=\"underline\">512 Ko ou 2 Mo</span>. Voici quelques combinaisons possibles :<br>\n<br>\n* Une banque de 512 Ko (512Ko au total),<br>\n* Deux banques de 512 Ko (1Mo au total),<br>\n* Une banque de 2 Mo (2Mo au total),<br>\n* Une banque de 2 Mo et une de 512 Ko (2.5Mo au total),<br>\n* Deux banques de 2 Mo (4Mo au total).<br>\n', '', '', NULL, '1722073300973.webp', NULL, '', '', '', 1, 1, 10),
(94, '', '', '', '', '', 'La mémoire (<span class=\"bold\">RAM</span> ou <span class=\"bold\">ROM</span> peut importe) est divisée en petits blocs appelés <span class=\"bold\">\"octets\"</span>. Pense aux octets comme des boîtes aux lettres dans une grande rue. Chaque boîte aux lettres (octet) a une adresse unique, ce qui permet à l\'ordinateur de trouver rapidement les informations stockées à cette adresse.<br>\nLa <span class=\"bold\">RAM</span> et la <span class=\"bold\">ROM</span> sont beaucoup plus rapide que les autres types de mémoire (comme les disques durs).', NULL, NULL, NULL, '', '', '', 1, 4, 10),
(95, 'RAM', 'ROM', '', 'RAM <span class=\"italic\">(Random Access Memory)</span> : Mémoire vive qui stocke temporairement les données que l\'ordinateur utilise pendant son fonctionnement. <span class=\"bold\"><span class=\"color-red\">On peut lire, écrire et effacer des données dans la RAM.</span></span><br>\n<span class=\"underline\">La RAM est volatile</span>, ce qui signifie que toutes les données qu\'elle contient sont perdues lorsque l\'ordinateur est éteint.<br>\nElle est utilisée pour charger et exécuter des programmes et des données temporaires. Par exemple, lorsqu\'un jeu est en cours d\'exécution, il utilise la RAM.<br>\nDe même que tout ce qui est visible à l\'écran c\'est un endroit spécifique de la RAM qui est visible', 'ROM <span class=\"italic\">(Read-Only Memory)</span> : Mémoire morte qui contient des données permanentes que l\'ordinateur <span class=\"bold\"><span class=\"color-red\">ne peut pas modifier ou effacer.</span></span><br>\n<span class=\"underline\">La ROM est non-volatile</span>, ce qui signifie que les données restent intactes même lorsque l\'ordinateur est éteint.<br>\nElle est utilisée pour stocker le firmware ou le BIOS de l\'ordinateur, c\'est-à-dire les programmes essentiels au démarrage et au fonctionnement de base de l\'ordinateur. <span class=\"underline\">Sur un Atari, le système d\'exploitation TOS est stocké en ROM.</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 10),
(96, 'Représentation de la RAM de l\' Atari', '', '', 'Voici une représentation incomplète mais simple, contenant juste ce qu\'il faut savoir pour commencer à comprendre ce qui se passe.<br>\n<br>\nComme je te l’ai dit précédemment, chaque octet de la RAM possède une adresse. Le premier octet est à l\'adresse <span class=\"bold\"><span class=\"color-green\">$000</span></span> <span class=\"italic\">(les adresses sont toujours en hexadécimal)</span> et les derniers octets sont aux adresses :<br>\n<br>\n* <span class=\"bold\"><span class=\"color-green\">$3FFFFF</span></span> pour une RAM de <span class=\"bold\">4 Mo</span><br>\n* <span class=\"bold\"><span class=\"color-green\">$27FFFF</span></span> pour une RAM de <span class=\"bold\">2,5 Mo</span><br>\n* <span class=\"bold\"><span class=\"color-green\">$0FFFFF</span></span> pour une RAM de <span class=\"bold\">1 Mo</span><br>\n* <span class=\"bold\"><span class=\"color-green\">$7FFFF</span></span> pour une RAM de <span class=\"bold\">512 Ko</span><br>\n<br>\nEntre <span class=\"bold\"><span class=\"color-green\">$000</span></span> et <span class=\"bold\"><span class=\"color-green\">$7FF</span></span>, il y a tout un tas de choses utilisées par le TOS, comme des variables et d\'autres vecteurs système. Ces adresses sont protégées et tu n’y as pas accès. Nous verrons plus tard qu\'il est possible d\'activer un mode spécifique pour y accéder.<br>\n<br>\nEntre <span class=\"bold\">$100000</span> et <span class=\"bold\">$1FFFFF</span>, et jusqu\'à <span class=\"bold\">$3F8000</span>, il n\'y a rien, enfin pas grand-chose. Pour le moment, on s\'en moque.<br>\n<br>\nCe qui est important, c\'est de comprendre que l\'écran logique <span class=\"italic\">(appelé frame buffer, c\'est-à-dire la partie de la RAM visible à l\'écran)</span>, quelle que soit la quantité de mémoire, <span class=\"underline\">se positionnera toujours en fin de RAM</span> :<br>\n<br>\nAvec <span class=\"bold\">4 Mo</span>, l\'écran sera placé à l\'adresse <span class=\"bold\"><span class=\"color-green\">$3F8000</span></span>.<br>\nAvec <span class=\"bold\">2,5 Mo</span>, il sera placé à l\'adresse <span class=\"bold\"><span class=\"color-green\">$278000</span></span>.<br>\nAvec <span class=\"bold\">2 Mo</span>, il sera placé à l\'adresse <span class=\"bold\"><span class=\"color-green\">$1F8000</span></span>.<br>\nAvec <span class=\"bold\">1 Mo</span>, il sera placé à l\'adresse <span class=\"bold\"><span class=\"color-green\">$0F8000</span></span>.<br>\nAvec <span class=\"bold\">512 Ko</span>, il sera placé à l\'adresse <span class=\"bold\"><span class=\"color-green\">$78000</span></span>.<br>\nPour donner une idée de la proportion, avec par exemple 1 Mo de RAM, le frame buffer ne représente que 3,2 % de la mémoire totale, c\'est très peu ! Donc, il y a beaucoup de place disponible.<br>\n<br>', '', '', NULL, '1722077439752.png', NULL, '', '', '', 2, 1, 10),
(98, '', '', 'Outil de Visualisation de la RAM', '', '', '<span class=\"bold\">The Ripper v3.1</span>, que tu peux dès maintenant télécharger depuis le site dans l\'unité de disque E (Utilitaire). Il va te permettre d\'explorer ce qui se passe dans la RAM de ton Atari. Il est important d\'apprendre à être curieux, et je t\'encourage à utiliser ce genre d\'outil très pratique.<br>\n<br>\nExécute simplement le fichier<span class=\"bold\"> .PRG</span> et observe bien ce que tu vois à l\'écran. Les couleurs que tu vois représentent les données sous forme d\'octets, qui, selon leur valeur, vont apparaître avec l\'une des 16 couleurs que possède l\'Atari ST. Tu peux faire défiler la mémoire pour voir plus loin en utilisant la combinaison des touches <span class=\"keyboard-key\">Shift</span> + Curseur Haut / Bas. Voilà je te laisse t\'amuser avec cet outil très pratique.', NULL, NULL, NULL, '', '', '', 2, 4, 10),
(99, '', '', '', '', '', '', NULL, NULL, '1722078306191.png', '', '', '', 2, 5, 10),
(101, '', '', '', '<span class=\"italic\">(ici on arrive au niveau du frame buffer, en fait on verra çà plus tard mais on peut s\'amuser à déplacer l\'écran physique. C\'est en fait ce que fait Ripper pour visualiser la RAM)</span>', '<span class=\"italic\">(les bandes verticales multicolores représentent la mémoire non accessible, j\'ai 4Mo de RAM, donc au delà, la mémoire n\'existe pas)</span>', '', NULL, NULL, NULL, '', '', '', 2, 2, 10),
(102, '', '', '', '', '', '', '1722079765282.png', '1722079765283.png', NULL, '', '', '', 2, 2, 10),
(103, '', 'Le contenu de la RAM avec un debugger', '', '', 'À ce stade de ton apprentissage, tu es censé avoir déjà installé et configuré <span class=\"bold\">DevPac</span>. Si ce n\'est pas encore fait, consulte le cours <span class=\"italic\">\"Savoir configurer les outils de développement - Partie 2\".</span><br>\n<br>\nC\'est très simple : démarre le programme DevPac et, une fois arrivé dans l\'éditeur, sans avoir besoin de saisir quoi que ce soit, appuie sur <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">A</span> pour assembler ton code <span class=\"italic\">(même si le code est vide, il est nécessaire d\'assembler quelque chose pour accéder au débogueur de DevPac).</span><br>\n<br>\nPour ouvrir le débogueur <span class=\"italic\">(qui, au passage, s\'appelle Monst... oui, c\'est un nom un peu étrange)</span>, utilise le raccourci <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">D</span>.', '', '1722080617316.png', NULL, NULL, '', '', '', 2, 6, 10),
(104, '', '', '', '', '', 'Tu remarques trois fenêtres : <span class=\"bold\">Registers, Disassembly PC et Memory.</span> Observe les fenêtres 2 et 3 : <span class=\"bold\"><span class=\"color-red\">dans la colonne de gauche, ce sont les adresses de la mémoire</span></span>. Le symbole $ n\'est pas présent, mais il s\'agit de valeurs hexadécimales.<br>\n<br>\nJe vais te faire réaliser une manipulation qui sera très utile pour plus tard. Utilise le raccourci <span class=\"keyboard-key\">TAB</span> pour naviguer entre les trois fenêtres et arrête-toi sur la fenêtre n°3 (Memory) et utilise le raccourci <span class=\"keyboard-key\">M</span>.<br>\nUne fenêtre s\'ouvre avec l\'invite <span class=\"bold\">\"Window start address?\"</span>... Pas besoin de détails supplémentaires ici, je crois que tu viens de comprendre.<br>\n<br>\nSaisis l\'adresse <span class=\"bold\">$44E</span> et valide. Maintenant, regarde la fenêtre Memory ; ton débogueur pointe désormais sur l\'adresse que tu viens de saisir !<br>\nJuste à droite de la colonne des adresses, tu verras <span class=\"bold\"><span class=\"color-red\">la colonne des octets contenus à cette adresse</span></span>, c\'est-à-dire : <span class=\"bold\">$00 $3F $80 $00</span>, <span class=\"bold\">quatre octets qui, regroupés, forment un long word </span>: <span class=\"bold\">$003F8000</span>. Cette valeur te dit-elle quelque chose ?<br>\n<br>\n... Réfléchis bien ...<br>\n<br>\nJe te donne la réponse : cette valeur correspond à l\'adresse de ton <span class=\"bold\">framebuffer</span> <span class=\"underline\">pour une configuration de 4 Mo</span>. Oui, beaucoup de choses intéressantes sont stockées dans cette partie de la RAM !<br>\n<br>\nTu peux quitter le débogueur en utilisant deux fois le raccourci <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">C</span> <span class=\"italic\">(la première fois, cela termine le programme, et la deuxième fois, cela quitte Monst)</span>', NULL, NULL, NULL, '', '', '', 2, 4, 10),
(105, '', '', '', '', '', 'Je vais commencer par te parler d\'une instruction, probablement la plus importante : l\'instruction <span class=\"bold\"><span class=\"color-blue\">move</span></span>. En anglais, <span class=\"bold\">move</span> signifie bouger ou déplacer. Donc, l\'utilisation de cette instruction nous amène à devoir déplacer ou charger quelque chose quelque part. En assembleur 68000, avec cette instruction, nous chargerons parfois <span class=\"bold\"><span class=\"underline\">des adresses</span></span>, parfois <span class=\"bold\"><span class=\"underline\">des valeurs</span></span>. Et où met-on cela ? <span class=\"bold\"><span class=\"underline\">Dans des registres</span></span> !<br>\nUn registre, c\'est comme un tiroir <span class=\"underline\">où l\'on stocke des valeurs ou on fait des opérations</span>. On peut aussi le voir comme une variable en mathématiques, par exemple y = 12. Dans ce cas, \"y\" serait le nom du registre et 12 la valeur qu\'il contient.<br>\nLes registres sont propres au microprocesseur, donc on ne choisit pas leur nom. Il en existe 16, répartis en deux catégories :<br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Registres de données (d0 à d7) :</span></span><br>\nIl y a 8 registres de données : d0, d1, d2, d3, d4, d5, d6, d7.<br>\n<span class=\"color-red\"><span class=\"bold\">Ils servent à stocker des données numériques</span></span>.<br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Registres d\'adresses (a0 à a7) :</span></span><br>\nIl y a 8 registres d\'adresses : a0, a1, a2, a3, a4, a5, a6, a7.<br>\n<span class=\"bold\"><span class=\"color-red\">Ils servent à stocker des adresses.</span></span><br>\n<br>\nCertains registres sont particuliers, comme le registre a7, aussi appelé <span class=\"bold\">SP</span> (Stack Pointer), qui est le registre de pile <span class=\"italic\">(ne pense pas à une pile de 9 volts, mais plutôt à une pile d\'assiettes).</span> Les trois premiers registres de chaque catégorie (d0, d1, d2 et a0, a1, a2) sont appelés <span class=\"bold\">\"crash registers\"</span>. Ils peuvent recevoir des renvois de données suite à des appels GEMDOS ou XBIOS, mais on verra cela plus tard.', NULL, NULL, NULL, '', '', '', 1, 4, 11);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(106, '', '', 'move <#value>, reg', '', '', 'Pour commencer, voici deux petites choses : il est possible <span class=\"color-green\">de mettre des commentaires</span> dans ton code pour décrire ce qu\'il fait, si besoin. Pour cela il suffit de saisir <span class=\"keyboard-key\">;</span> et tout ce qui sera écrit après, sera ignoré. Et enfin, pour écrire une instruction en assembleur 68000, il faut indenter chaque ligne de code en utilisant la touche <span class=\"keyboard-key\">Tab</span>.<br>\nSaisis le code suivant dans l\'éditeur :<br>\n<span class=\"code\">; je charge la valeur décimale 128 dans le registre d0<br>\n          move    #128,d0</span><br>\n<div class=\"border-green\"><p>A retenir:<br>\nmove est une instruction<br>\n#128 et d0 sont des opérandes (la source et la destination)</p></div><br>\n<div class=\"border-red\"><p>Attention:<br>\nLe # juste avant la valeur 128 indique que 128 est bien une valeur et non une adresse !</p></div>', NULL, NULL, NULL, '', '', '', 1, 1, 11),
(107, '', '', '', 'Ensuite, regardons comment les choses se passent dans la RAM. Assemble ton programme avec <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">A</span>. Si tu n\'as pas fait d\'erreur <span class=\"italic\">(DevPac vérifiera ton code et te le signalera si c\'est le cas)</span>, tu pourras passer à l\'étape suivante.<br>\nPour cela, dirige-toi vers le débogueur avec <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">D</span>. <br>\n<br>\n<div class=\"border-yellow\"><p>Remarques : <br>\nDans la fenêtre <span class=\"bold\">\'Registers\'</span> tu vois le nom de tes registres et ce qu\'il y a dedans !</p></div><br>\n<br>', '', '', NULL, '1722107822442.png', NULL, '', '', '', 1, 1, 11),
(108, '', '', '', '', '', 'Dans la fenêtre <span class=\"bold\">\'Disassembly pc\'</span>, tu lis <span class=\"bold\">move.w #$80,d0</span>. <span class=\"underline\">Le programme a traduit automatiquement la valeur décimale 128 en valeur hexadécimale</span>, donc <span class=\"bold\">$80</span>.<br>\n<br>\nLe programme a également ajouté le suffixe <span class=\"bold\">.w</span> après l\'instruction <span class=\"bold\">move</span>. DevPac est configuré par défaut pour ajouter l\'indication de la longueur de donnée que l\'on manipule, autrement dit, un word (2 octets). À partir de maintenant, nous ajouterons toujours de suffixe:<br>\n<span class=\"bold\"><span class=\"color-red\">.b</span></span> (byte) : 1 octet / 8 bits <span class=\"italic\">(valeurs de <span class=\"color-red\">0</span> à <span class=\"color-red\">255</span> ou $0 à $FF)</span><br>\n<span class=\"bold\"><span class=\"color-red\">.w</span></span> (word) : 2 octets / 16 bits <span class=\"italic\">(valeurs de <span class=\"color-red\">256</span> à <span class=\"color-red\">65 535</span> ou $0100 à $FFFF)</span><br>\n<span class=\"bold\"><span class=\"color-red\">.l</span></span> (long word) : 4 octets / 32 bits (valeur de <span class=\"color-red\">65 536</span> à <span class=\"color-red\">4 294 967 295</span> ou $010000 à $FFFFFFFF)<br>\nTrès bien, ensuite c\'est facile. Tu vas pouvoir exécuter ton programme \"pas à pas\" : on appelle ça le mode \"trace\", comme si on disait \"tracer le code\", en appuyant sur <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">Z</span>.<br>\nEt à présent regarde le registre <span class=\"bold\">d0</span>. La valeur <span class=\"bold\">$80</span> a été stocké dedans.<br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 11),
(109, '', 'Les messages d\'erreurs', '', '', 'Mais alors, que se passe-t-il si je génère une erreur avec ce code, par exemple ?<br>\nCopier ce code :<br>\n<span class=\"code\">; test de message d\'erreur<br>\nmove.b     #1794, d0</span><br>\nDans cet exemple, j\'ai ajouté <span class=\"bold\"><span class=\"color-red\">.b</span></span> après mon instruction <span class=\"bold\">move</span> pour indiquer qu\'elle va manipuler une valeur de la taille d\'un octet. Cependant, la valeur indiquée (1794) est trop grande pour un octet et nécessite plutôt 2 octets (un \"word\").<br>\n<br>\nDevPac est équipé d\'un système de gestion des erreurs qui utilise 2 passes :<br>\n<br>\n<span class=\"underline\">Pass 1 :</span> Il vérifie la syntaxe. Dans notre exemple, la syntaxe est correcte.<br>\n<span class=\"underline\">Pass 2 :</span> Il vérifie la cohérence. Dans ce cas, l\'erreur \"data too large\" (données trop grandes) est générée.<br>\n<br>\nDe plus, DevPac donne des précisions comme le numéro de la ligne et le nom du fichier où l\'erreur a été trouvée. Il peut même automatiquement te montrer l\'erreur en plaçant le curseur directement dessus !', '', '1722168504603.png', NULL, NULL, '', '', '', 1, 6, 11),
(111, '', '', 'Afficher un truc à l\'écran', '', '', 'Si tu te rappelles du cours précédent, je t\'avais parlé d\'une adresse importante : <span class=\"bold\">$44E</span>. Cette adresse se situe au début de la RAM et contient un long mot (4 octets) <span class=\"bold\">correspondant à l\'adresse du frame buffer</span> (ton écran).<br>\n<br>\nCette adresse, comme toutes celles du système, tu ne peux pas l\'utiliser dans ton code, elle est protégée<span class=\"italic\"> (si tu essaies, tu obtiendras un joli \"bus error\" dans ton débogueur)</span>. En revanche, tu peux voir ce qu\'elle contient en utilisant la fenêtre <span class=\"bold\">Memory</span> et la touche <span class=\"keyboard-key\">M</span> <span class=\"italic\">(nous avons déjà vu cela dans le cours précédent, donc je pars du principe que tu maîtrises cette option).</span><br>\n<br>\nNote la valeur que cette adresse contient. Pour un Atari avec 4 Mo de RAM, tu devrais trouver : <span class=\"bold\">$3F8000</span>.', NULL, NULL, NULL, '', '', '', 2, 4, 11),
(112, '', '', '', 'Allez, on envoie un octet à l\'adresse de l\'écran :<br>\n<span class=\"code\">; afficher un octet à l\'écran<br>\nmove.b #255, $3F8000</span><br>\nEnsuite, comme d\'habitude :<br>\n* <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">A</span> pour assembler<br>\n* <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">D</span> pour lancer le débogueur (c\'est la dernière fois que je précise ces raccourcis)<br>\n* <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">Z</span> pour tracer le code (je considère que c\'est acquis).<br>\n<br>\nPour avoir un aperçu de ce qui se passe à l\'écran, utilise la touche <span class=\"keyboard-key\">V</span>. Utilise la même touche pour revenir au débogueur.', '', '', NULL, '1722171073560.png', NULL, '', '', '', 2, 1, 11),
(113, '', '', '', '', '', 'Bravo ! Tu as réussi à afficher un octet <span class=\"underline\">sur la première ligne de l\'écran</span> ! Tu peux évidemment t\'amuser à tester différents endroits de l\'écran en changeant l\'adresse à $3F8001, $3F8002, $3F8003, $3F8004, etc. Je te laisse chercher un peu. Tu vas trouver par toi-même l\'adresse de la ligne suivante, et ainsi, tu connaîtras la valeur en octets de la longueur d\'une ligne.<br>\n<br>\n<div class=\"border-yellow\"><p>Astuce :<br>\nAu lieu d\'afficher 1 seul octet sur chaque adresse, le 68000 permet d\'envoyer 4 octets d\'un coup en utilisant des mots longs :<br>\n<span class=\"code\">move.l #$FFFFFFFF, $3F8000</span><br>\nCela permet un envoi à l\'écran tous les 4 octets. Donc, le prochain sera à l\'adresse $3F8004, puis $3F8008, etc.</p></div>', NULL, NULL, NULL, '', '', '', 2, 4, 11),
(114, 'Et si on utilisait les registres ?', 'add <#valeur>,reg', '', 'Tu as trouvé l\'adresse de la ligne suivante ? Et tu as vu à quel point c\'est laborieux ? Eh bien, c\'était pour te montrer ce qu\'il ne faut pas faire. Avec les registres, c\'est beaucoup plus pratique et ton code sera également plus facile à relire. Car sinon ton code risque fortement de ressemble à ceci :<br>\n<span class=\"code\">; mauvais exemple<br>\n          move.l #$FFFFFFFF,$3F8000<br>\n          move.l #$FFFFFFFF,$3F8004<br>\n          move.l #$FFFFFFFF,$3F8008<br>\n          move.l #$FFFFFFFF,$3F800C<br>\n          move.l #$FFFFFFFF,$3F8010<br>\n          move.l #$FFFFFFFF,$3F8014<br>\n          move.l #$FFFFFFFF,$3F8018<br>\n          move.l #$FFFFFFFF,$3F801C<br>\n          move.l #$FFFFFFFF,$3F8020<br>\n          move.l #$FFFFFFFF,$3F8024<br>\n          move.l #$FFFFFFFF,$3F8028</span><br>\n<br>\nOn va transférer toutes nos valeurs et adresses dans les registres adéquats :<br>\n<span class=\"code\">          move.l #$FFFFFFFF, d0   ; on charge une donnée dans d0<br>\n          move.l #$3F8000, a0     ; on charge une autre donnée dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          move.l #$3F8004, a0     ; on charge l\'adresse suivante dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          move.l #$3F8008, a0     ; on charge l\'adresse suivante dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          move.l #$3F800C, a0     ; on charge l\'adresse suivante dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0</span><br>\n<br>\n<div class=\"border-red\"><p>Attention:<br>\nIl ne faut pas oublier les parenthèses autour de a0. Si on écrit <span class=\"bold\">move.l d0, a0</span>, cela signifie que l\'on copie la valeur contenue dans d0 à l\'intérieur du registre a0 <span class=\"italic\">(donc d0 = a0)</span>, et non à l\'adresse contenue dans a0.</p></div><br>\n', 'L\'utilisation des registres permet entre autre <span class=\"underline\">de faire des opérations mathématiques</span>, ce qui, dans notre cas, va être pratique, car on ne va tout de même pas se taper toutes les adresses de l\'écran à la main ! Donc, on va apprendre une nouvelle instruction : <span class=\"bold\">add</span>, qui, comme son nom l\'indique, permet de faire <span class=\"bold\">une addition</span>.<br>\n<span class=\"italic\">Exemple :</span><br>\n<span class=\"code\">add.l #4, a0   ; on additionne 4 au mot long contenu dans a0</span><br>\nSi <span class=\"bold\">a0</span> contenait <span class=\"bold\">$3F8000</span>, une fois cette instruction exécutée, <span class=\"bold\">a0</span> contient <span class=\"bold\">$3F8004</span> ! Ton code va donc ressembler à ceci :<br>\n<span class=\"code\">; faire une addition sur l\'adresse écran<br>\n          move.l #$FFFFFFFF, d0   ; on charge une donnée dans d0<br>\n          move.l #$3F8000, a0     ; on charge une adresse dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          add.l #4, a0            ; on additionne 4 au mot long contenu dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          add.l #4, a0            ; on additionne 4 au mot long contenu dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          add.l #4, a0            ; on additionne 4 au mot long contenu dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          add.l #4, a0            ; on additionne 4 au mot long contenu dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n; etc ...</span><br>\n<div class=\"border-yellow\"><p>Astuce :<br>\nDevPac propose des directives comme <span class=\"bold\">REPT</span> et <span class=\"bold\">ENDR</span> qui permettent de répéter plusieurs fois une section du code. Ces directives <span class=\"bold\"><span class=\"underline\">NE SONT PAS DES INSTRUCTIONS</span></span> que le 68000 comprend ; c\'est propre à DevPac et à son langage d\'assembleur.</p></div><br>\nMaintenant on va faire un tour de magie, regarde ce que ton code va devenir grâce à ces directives : <br>\n<span class=\"code\">; faire une addition sur l\'adresse écran<br>\n          move.l #$FFFFFFFF, d0   ; on charge une donnée dans d0<br>\n          move.l #$3F8000, a0     ; on charge une adresse dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          REPT 16          ; on va boucle 16 fois le code suivant<br>\n          add.l #4, a0            ; on additionne 4 au mot long contenu dans a0<br>\n          move.l d0, (a0)         ; on charge ce que contient d0 à l\'adresse contenue dans a0<br>\n          ENDR          ; fin de la boucle</span><br>\n<br>\n', '', NULL, NULL, NULL, '', '', '', 2, 3, 11),
(115, '', '', '', '', '', 'Considérons l\'exemple de l\'instruction <span class=\"bold\">NOP</span>, l\'une des plus simples pour le processeur 68000. <span class=\"bold\">NOP</span> signifie \"ne rien faire\". Lorsque tu écris <span class=\"bold\">NOP</span> dans ton éditeur de code assembleur, cela se traduit par 2 octets consécutifs dont les valeurs sont respectivement 78 et 113. <span class=\"bold\"><span class=\"color-red\">Ces deux valeurs de 8 bits (autrement dit, \"ces deux octets de 8 bits\") combinées ensemble forment une instruction de 16 bits</span></span>. Cette instruction est appelée <span class=\"bold\">opcode</span>. Ces deux octets sont ensuite placés en RAM (mémoire vive) ou sauvegardés dans un fichier, selon tes besoins.<br>\nAinsi, lorsque le 68000 rencontre ces deux octets avec les valeurs 78 et 113, il les interprète comme l\'instruction <span class=\"bold\">NOP</span>. D\'autres valeurs auront des significations différentes, bien sûr.<br>\nPour compléter voici ci-dessous un aperçu d\'un mot (16bits) et d\'un mot long (32bits) : ', NULL, NULL, NULL, '', '', '', 1, 5, 5),
(117, '', '', 'L\' adressage', '', '', 'Tu sais maintenant que la mémoire est codée en binaire et qu\'on peut la regrouper en <span class=\"bold\">Octet</span> <span class=\"italic\">(Bytes)</span>, <span class=\"bold\">Mot</span> <span class=\"italic\">(Word)</span> et <span class=\"bold\">Long Mot</span> <span class=\"italic\">(Long Word)</span>. Cependant, on ne peut pas mettre n\'importe quoi à n\'importe quelle adresse : <span class=\"bold\"><span class=\"color-red\"><span class=\"underline\">il faut tenir compte de la parité des adresses</span> </span></span>(paire ou impaire).<br>\nComme sur le schéma de la page précédente, la structure de la mémoire ressemble à une bande avec un début et une fin. Mais on va ajouter un détail à cette représentation : <span class=\"bold\"><span class=\"color-red\">elle a une largeur de 16 bits !</span></span>', NULL, NULL, NULL, '', '', '', 3, 4, 10),
(118, '', '', '', 'Si on regarde attentivement le schéma <span class=\"italic\">(que j\'ai emprunté à Laurent Piechocki)</span>, la mémoire peut être représentée comme un puits dans lequel on jette des données : bits, octets, mots ou long mots.<br>\n<br>\n<div class=\"border-red\"><p>Attention :<br>\nLa largeur de ce puits est d\'un <span class=\"bold\">MOT</span> (soit 16 bits).<br>\nLa profondeur dépend de la taille de la mémoire.<br>\nLe but du jeu : Jeter nos données dans le puits <span class=\"bold\">sans déformer les données</span>.</p></div><br>\n<br>\nSi tu y jettes un MOT (comme dans le schéma) : <span class=\"bold\">%1010010110001000</span>, c\'est-à-dire 2 octets <span class=\"italic\">(1 de poids fort à droite et 1 de poids faible à gauche)</span> à une adresse paire :<br>\n<br>\nLe <span class=\"bold\">MOT</span> a été posé à <span class=\"bold\">une adresse paire</span> <span class=\"italic\">($3F8002)</span>.<br>\nL\'octet de <span class=\"bold\">poids fort</span> est à l\'adresse <span class=\"bold\">paire</span> <span class=\"italic\">($3F8002)</span>.<br>\nL\'octet de <span class=\"bold\">poids faible</span> est à l\'adresse <span class=\"bold\">impaire</span> <span class=\"italic\">($3F8003)</span>.', '', NULL, NULL, '1722249202268.png', NULL, '', '', '', 3, 1, 10),
(119, '', '', '', '<div class=\"border-red\"><p>A<span class=\"bold\">ttention :</span><br>\nSi vous jetez ce mot à une adresse impaire :<br>\nL\'octet de poids fort se trouve à une adresse impaire ($3F8001).<br>\nL\'octet de poids faible se trouve à une adresse paire ($3F8002).</p></div><br>\n<br>\nDans ce cas, vous ne respectez plus les règles du « jeu » <span class=\"italic\">(qui sont en fait celles du processeur 68000)</span>. Pour placer des mots <span class=\"italic\">(ou long mots)</span> dans la mémoire, <span class=\"bold\"><span class=\"color-red\">il faut veiller à ce que l\'adresse de destination soit paire !</span></span><br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nPour un octet seul, la parité n\'a plus d\'importance.</p></div>', '', '', NULL, '1722250577845.png', NULL, '', '', '', 3, 1, 10),
(120, '', '', '', '', '', '<div class=\"border-green\"><p>A retenir : <br>\nDans une <span class=\"underline\"><span class=\"bold\">registre d\'adresse</span></span> : on ne peut transférer que des <span class=\"bold\">Word</span> ou <span class=\"bold\">Long Word</span>. <span class=\"bold\"><span class=\"underline\">PAS D\'OCTET</span></span>, c\'est très important !</p></div>', NULL, NULL, NULL, '', '', '', 1, 4, 11),
(121, '', '', '', '', '', '<div class=\"border-red\"><p>Attention :<br>\nLes directives <span class=\"bold\">REPT <span class=\"italic\"><nombre></span></span> et <span class=\"bold\">ENDR</span> dupliquent la portion de code dans la mémoire autant de fois que demandé. Cela ne réduit pas la place utilisée en mémoire, mais permet plutôt de gagner de la place dans ton code source.</p></div>', NULL, NULL, NULL, '', '', '', 2, 4, 11),
(122, 'Le registre de la pile', '', '', 'Quand on parle de pile en informatique, il ne s\'agit pas d\'une pile de piles de 9V ni de celles que l\'on trouve sur les cartes mères des PC. Il s\'agit plutôt d\'une pile comme une pile d\'assiettes ou d\'objets, <span class=\"underline\">l\'idée étant de visualiser des éléments empilés les uns sur les autres.</span><br>\n<br>\nUne pile est un registre d\'adresse, sur notre 68000 appelé registre <span class=\"bold\">A7</span>. Ce registre contient une valeur qui représente une adresse précise en mémoire. C\'est à cette adresse que des valeurs sont stockées.<br>\n<br>\nLa pile se trouve en mémoire juste avant le framebuffer. Vous pouvez vérifier cela de deux manières :<br>\n<br>\n<span class=\"underline\">Avec le débogueur de DevPac.</span><br>\nEn regardant la valeur du registre A7. Par exemple, avec 4 Mo de RAM, chez moi, la valeur est <span class=\"bold\">$3F7FF8</span>.<br>\n<br>\n<span class=\"underline\">Avec l\'outil <span class=\"bold\">The Ripper</span></span> comme l\'image le montre <span class=\"italic\">(outil disponible au téléchargement dans le site dans l\'unité de disk E)</span>', '', '', NULL, '1722256001246.png', NULL, '', '', '', 3, 1, 11),
(123, '', '', '', '', 'Maintenant, nous allons envoyer des données dans la pile <span class=\"italic\">(donc le registre a0)</span>. C\'est similaire à l\'utilisation des autres registres :<br>\n<span class=\"code\">; Envoyer des données dans la pile<br>\n          move.l #$1234ABCD, (a7)<br>\n          move.l #$5687ABEF, (a7)</span><br>\n<br>\nTu connais la procédure : assemble ton code et observe dans le débogueur. En suivant l\'exécution de ton code, tu pourras voir où se trouvent les données que tu as envoyées.', '', '1722256582383.png', NULL, NULL, '', '', '', 3, 6, 11),
(124, '', '', '', '', '', 'Alors, ce que nous avons fait précédemment n’était pas très utile car nous avons écrasé les valeurs précédentes. Profitons de cette occasion pour apprendre un nouveau mode d’adressage : <span class=\"bold\">l’incrémentation et la décrémentation</span>.<br>\n<span class=\"bold\">Incrémenter</span> signifie <span class=\"underline\">augmenter une valeur de 1</span>, tandis que <span class=\"bold\">décrémenter</span> signifie la <span class=\"underline\">diminuer de 1</span>. En programmation, on distingue aussi entre :<br>\n<span class=\"bold\"><span class=\"underline\">Post-incrémentation / Post-décrémentation :</span></span> L\'opération se fait après l\'utilisation de la valeur.<br>\n<span class=\"bold\"><span class=\"underline\">Pré-incrémentation / Pré-décrémentation :</span></span> L\'opération se fait avant l\'utilisation de la valeur.<br>\nExemple simple, tu te souviens de ce code, quelques pages en arrière ?<br>\n<span class=\"code\">; Faire une addition sur l\'adresse écran<br>\n          move.l #$FFFFFFFF, d0   ; On charge une donnée dans d0<br>\n          move.l #$3F8000, a0     ; On charge une adresse dans a0<br>\n          move.l d0, (a0)         ; On stocke ce que contient d0 à l\'adresse contenue dans a0<br>\n          add.l #4, a0            ; On additionne 4 à l\'adresse contenue dans a0</span><br>\nLe but était d’obtenir une valeur dans <span class=\"bold\">a0</span> qui augmente de 4 en 4. Mais le processeur 68000 permet ce mode d’adressage :<br>\n<span class=\"code\">move.l d0, (a0)+        ; On stocke ce que contient d0 à l\'adresse contenue dans a0, <span class=\"bold\"><span class=\"color-green\">puis on incrémente a0 d\'un Long Word</span></span></span><br>\nIci, le symbole + est placé après les parenthèses. Cela signifie que l\'incrémentation de 4 octets <span class=\"italic\">(la taille d\'un Long Word)</span> se fait après l\'opération de stockage. C’est ce qu’on appelle post-incrémentation.<br>\n<br>\nTiens, teste ce petit programme. J\'ai pris soin de le commenter. Regarde ensuite dans <span class=\"bold\">Monst</span> <span class=\"italic\">(dernière fois que je le rappelle, c\'est le débogueur de DevPac)</span>  en alternant avec <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">V</span> à chaque ligne d\'instruction<br>\n<span class=\"code\">; incrémentation / décrémentation<br>\n          move.l #$FFFFFFFF, d0     ; valeur no1<br>\n          move.l #$12345678, d1     ; valeur no2<br>\n          move.l #$3F8000, a0       ; adresse framebuffer<br>\n<br>\n; On envoie le contenu de d0 à l\'adresse contenue dans a0, puis on incrémente a0<br>\n          REPT 4<br>\n          move.l d0, (a0)+<br>\n          ENDR<br>\n; Arrivé ici, a0 = $3F8010<br>\n<br>\n; On décrémente d\'abord le contenu de a0, puis on envoie ce que contient d1 à l\'adresse décrémentée de a0<br>\n          REPT 4<br>\n          move.l d1, -(a0)<br>\n          ENDR<br>\n; Arrivé ici, a0 = $3F8000</span><br>\n', NULL, NULL, NULL, '', '', '', 3, 4, 11),
(125, '', '', '', 'Maintenant que tu as compris ce principe, il est temps de l\'appliquer à la pile ! Ah tiens, je ne t\'ai pas dit, mais la pile en anglais, c\'est <span class=\"bold\">\"Stack Pointer\"</span>, et dans ton code, tu peux écrire <span class=\"bold\">sp</span> à la place de <span class=\"bold\">a7</span>, c\'est exactement la même chose. <span class=\"bold\">Désormais, nous utiliserons sp car c\'est plus explicite.</span><br>\n<br>\nMais pourquoi est-il important d\'utiliser la décrémentation spécifiquement pour la pile ? La première raison est que le système l\'utilise déjà de cette façon, mais nous verrons cela plus tard. L\'autre raison, qui relève du bon sens : la pile étant située juste avant l\'écran dans la mémoire, elle finira tôt ou tard par déborder dans les adresses de l\'écran ! Donc, nous stockons dans la pile \"à l\'envers\".<br>\n<br>\nTeste ce bout de code et regarde attentivement les valeurs que tu envoies dans la pile ainsi que l\'adresse du registre <span class=\"bold\">a7</span> (donc sp). Le schéma de droite représente visuellement ce que tu devrais voir.<br>\n<br>\n<span class=\"code\">          move.l #$3F8000,a0     ; on choisis une donnée, le frame buffer par exemple<br>\n<br>\n; on empile nos assiettes<br>\n          REPT 8<br>\n          move.l a0,-(sp)<br>\n          add.l #4,a0<br>\n          ENDR<br>\n<br>\n; on dépile nos assiettes<br>\n          REPT 8<br>\n          move.l (sp)+,d0<br>\n          ENDR</span><br>\n', '', '', NULL, '1722263833583.png', NULL, '', '', '', 3, 1, 11),
(126, '', '', '', '', '', 'Il existe encore plein d\'autre façon de faire pour manipuler des adresses et des données. Je te t\'invite à consulter la section <span class=\"bold\">Documentations</span> sur site où tu y trouvera <span class=\"bold\"><span class=\"italic\">\"Les modes d\'adressage du 68000\"</span></span>.<br>\nMais t\'inquiète pas on en verra d\'autre dans les cours qui vont suivre.', NULL, NULL, NULL, '', '', '', 3, 4, 11),
(127, '', '', 'Les différents modes d\'adressage', '', '', 'Chaque mode d\'adressage permet d\'accéder aux données de manière différente, ce qui offre une grande flexibilité dans la programmation sur le processeur Motorola 68000. Ces modes sont utilisés pour manipuler les registres de données, les registres d\'adresse, et différentes formes de mémoire immédiate ou indirecte.', NULL, NULL, NULL, '', '', '', 1, 4, 12),
(128, '', '', '', '', '', '<span class=\"bold\"><span class=\"underline\">Registre de données direct :</span></span><br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE D0, D1</span><br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Registre d\'adresse direct :</span></span><br>\nL\'opérande source est un registre de données/d\'adresse ou d\'état.<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE A0, A1<br>\nSUB.W D0,D1<br>\nMOVE.L A0, D2<br>\nAND SR</span><br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Registre d\'adresse indirect :</span></span><br>\nDans ce cas, l\'adresse n\'est pas donnée directement, c\'est un registre qui pointe dessus (donc le registre a comme valeur l\'adresse visée). L\'adresse de l\'opérande est positionnée dans le registre d\'adresse. Pour indiquer que c\'est l\'adresse pointée par le registre, il faudra utiliser les parenthèses: <span class=\"bold\">MOVE.W (A0), D0</span> qui signifie que <span class=\"bold\">A0</span> pointe sur une adresse, la donnée en word présente à cette adresse sera recopiée dans le registre de données <span class=\"bold\">D0</span>.<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE (A0), D1<br>\nMOVE D1,(A0)</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Registre d\'adresse indirect avec post-incrément :</span></span><br>\nMême chose que l\'adressage indirect simple, mais suite à cette opération, le contenu du registre d\'adresse sera incrémenté de 1 si le format est un Byte, de 2 si word, de 4 si long. <br>\n<span class=\"bold\">MOVE.W (A0)+, D0</span> signifie que <span class=\"bold\">A0</span> pointe sur une adresse, la donnée en word présente à cette adresse sera recopiée dans le registre de données <span class=\"bold\">D0</span>.<br>\nLe contenu du registre <span class=\"bold\">A0</span> est alors incrémenté de 2 <span class=\"italic\">(car .W)</span>, donc <span class=\"bold\">A0</span> pointe maintenant vers adresse + 2.<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE (A0)+, D1<br>\nMOVE D1,(A0)+<br>\nMOVE.B (A2)+,(A2)<br>\nMOVE.B (A2)+,(A2)+</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Registre d\'adresse indirect avec pré-décrément :</span></span><br>\nMême chose que l\'adressage indirect simple, mais avant de faire cette opération, le contenu du registre d\'adresse sera décrémenté de 1 si le format est un Byte, de 2 si word, de 4 si long.<br>\n<span class=\"bold\">MOVE.W D0,-(A0)</span> signifie que <span class=\"bold\">A0</span> pointe sur une adresse. <span class=\"bold\">A0</span> est alors décrémenté de 2 <span class=\"italic\">(car .W)</span>, puis cette nouvelle adresse ainsi calculée recevra la valeur du registre de données <span class=\"bold\">D0</span>.<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE -(A0), D1<br>\nMOVE D1,-(A0)<br>\nMOVE.L -(A2),-(A2)<br>\nMOVE.B #23,-(A2)</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Registre d\'adresse indirect avec déplacement :</span></span><br>\nMême chose que l\'adressage indirect simple, mais cette fois-ci, <span class=\"bold\">A0</span> pointe vers une adresse + déplacement <span class=\"italic\">(codé sur 16 bits et étendu sur 32)</span> précisé.<br>\n<span class=\"bold\">MOVE.B 16(A0), D0</span> signifie que <span class=\"bold\">A0</span> pointe sur une adresse, la donnée en word présente à adresse + déplacement sera recopiée dans le registre de données <span class=\"bold\">D0</span>.<br>\n<div class=\"border-red\"><p>La valeur du déplacement ne va pas modifier la valeur de <span class=\"bold\">A0</span> !</p></div><br>\n<span class=\"underline\">Autrement dit :</span> <span class=\"bold\">Instruction          <span class=\"color-red\">d</span>(<span class=\"color-blue\">An</span>),<span class=\"color-green\">destination</span></span><br>\nOn ajoute au contenu du registre d\'adresse <span class=\"color-blue\"><span class=\"bold\">An</span></span>, la valeur (signée) du déplacement <span class=\"color-red\"><span class=\"bold\">d</span></span>. La donnée pointée par cette nouvelle valeur du registre <span class=\"color-blue\"><span class=\"bold\">An</span></span> est posée dans / à <span class=\"color-green\"><span class=\"bold\">l\'opérande destination</span></span>.<br>\nDonc <span class=\"bold\"><span class=\"color-red\">d</span>(<span class=\"color-blue\">An</span>) = <span class=\"color-red\">d</span>+(<span class=\"color-blue\">An</span>)</span><br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE 16(A0), D1<br>\nMOVE.W #458,2(A3)<br>\n</span><br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Registre d\'adresse indirect avec index et déplacement de 8 bits :</span></span><br>\nMême chose que l\'adressage indirect avec déplacement, mais s\'ajoute à cela un registre de données qui servira d\'index de déplacement à partir de l\'adresse visée...<br>\n<div class=\"border-red\"><p>La valeur du registre de données servant d\'index et le déplacement ne va pas modifier la valeur de <span class=\"bold\">A0</span> !</p></div><br>\n<span class=\"underline\">Autrement dit :</span> <span class=\"bold\">instruction          <span class=\"color-red\">d</span>(<span class=\"color-blue\">An</span>,<span class=\"color-orange\">Rn</span>),<span class=\"color-green\">destination</span>)</span><br>\nOn ajoute au registre <span class=\"color-blue\"><span class=\"bold\">An</span></span>, la valeur signée du déplacement <span class=\"color-red\"><span class=\"bold\">d</span></span> contenu sur un MOT et la valeur du registre <span class=\"color-orange\"><span class=\"bold\">Rn</span></span> (d\'adresse ou de donnée), puis on déplace la donnée ainsi pointée dans / à<span class=\"color-green\"> <span class=\"bold\">l\'opérande destination</span></span>.<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE 8(A0, D0.L), D1<br>\nMOVE.W $10(A0,D1.L), D0</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Adressage absolu court :</span></span><br>\nIl s\'agit d\'adresse d\'une largeur de 16 bits (un mot). <span class=\"bold\"><span class=\"color-red\">L\'adresse sera automatiquement convertie en 32 bits (long)</span></span> de la manière suivante : Si le nombre est signé <span class=\"italic\">(bit de poid fort positionné)</span>, alors l\'adresse sera complétée par <span class=\"bold\">$FFFF</span>, sinon complétée par <span class=\"bold\">$0000</span>, par exemple <span class=\"bold\">$FF00</span> deviendra <span class=\"bold\">$FFFFFF00</span>.<br>\n<div class=\"border-red\"><p>Dans ce cas, vous ne pouvez accéder qu\'à 64Ko de la mémoire.</p></div><br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE $1234.W, D1</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Adressage absolu long :</span></span><br>\n<span class=\"italic\">Exemple :</span><br>\n<span class=\"code\">MOVE $12345678.L, D1</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Compteur de programme indirect avec déplacement (adressage relatif):</span></span><br>\nL\'adresse effective est fonction d\'un déplacement (toujours sur 16 bits) et du compteur d\'instructions PC. Ajout du déplacement au PC (pour les branchements, le déplacement pourra être sur 8 bits)<br>\n<div class=\"border-yellow\"><p>Le code sera relogeable dans ce cas.</p></div><br>\n<span class=\"underline\">Autrement dit :</span> <span class=\"bold\"><span class=\"color-red\">d</span>(<span class=\"color-blue\">PC</span>),<span class=\"color-green\">destination</span></span><br>\nOn ajoute la valeur du déplacement signé <span class=\"color-red\"><span class=\"bold\">d</span></span> code sur un MOT au <span class=\"color-blue\"><span class=\"bold\">PC</span></span> (de l\'instruction considérée !), on prends la donnée ainsi pointée et on la pose dans  / à <span class=\"color-green\"><span class=\"bold\">l\'opérande de destination</span></span>.<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE 16(PC), D1<br>\nMOVE.B $10(PC), D0<br>\nJMP 10(PC)</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Compteur de programme indirect avec index et déplacement de 8 bits (adressage indexé):</span></span><br>\nIdentique à Adressage relatif auquel s\'ajoute un registre de données servant d\'index.<br>\nAutrement dit : <span class=\"bold\">instruction         <span class=\"color-red\">d</span>(<span class=\"color-blue\">PC</span>,<span class=\"color-orange\">Rn</span>),<span class=\"color-green\">destination</span></span><br>\nOn ajoute la valeur du déplacement signé <span class=\"color-red\"><span class=\"bold\">d</span></span> codé sur un MOT et celle du registre <span class=\"color-orange\"><span class=\"bold\">Rn</span></span> au <span class=\"color-blue\"><span class=\"bold\">PC</span></span> (de l\'instruction considérée !), on prend la donnée ainsi pointée et on la pose dans  / à <span class=\"color-green\"><span class=\"bold\">l\'opérande destination</span></span>.<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE 8(PC, D0.L), D1<br>\nMOVE.B $10(PC, D1.W), D0</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Immédiat Simple  :</span></span><br>\nL\'opérande représente dans ce cas une donnée et devra commencer par un # dans le premier argument de l\'instruction assembleur.<br>\n<div class=\"border-red\"><p>Lors d\'un transfert d\'une donnée sur une taille d\'un mot vers un registre d\'adresse, cette donnée sera convertie sur 32 bits, c\'est donc tout le registre sur un mot long qui sera affecté.</p></div><br>\n<span class=\"underline\">a) - De type numérique</span><br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE #$1234, D1<br>\nSUB.W #456, D0<br>\nADD.L #$F824AB45,D1</span><br>\n<span class=\"underline\">b) - De type symbolique</span><br>\nDans ce cas l\'opérande source est un <span class=\"bold\">LABEL</span><br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">MOVE.L #label, A0</span><br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Immédiat Rapide :</span></span><br>\nDans cette variante, la donnée est codée directement dans l\'instruction sur 3 bits. Elle ne pourra donc être comprise qu\'entre 0 et 7. sauf pour l\'instruction move ou la donnée pourra être codée sur 8 bits. L\'instruction devra être suivie de Q pour quick. Evidemment, le nombre de cycles dans ce cas sera plus petit que précédemment, car il y aura moins de choses à traiter !<br>\n<span class=\"italic\">Exemple : </span><br>\n<span class=\"code\">ADDQ.L #2,A0<br>\nMOVEQ #128,D0</span><br>\n<br>\nSources volées au site <a class=\"link\" href=\"http://supertos.free.fr/\" target=\"blank\">http://supertos.free.fr/</a>', NULL, NULL, NULL, '', '', '', 1, 4, 12),
(132, 'IV. Installation de l’émulateur Steem', '', '', '<span class=\"underline\">1 – Problème avec DirectX au démarrage ?</span><br>\n<br>\nLa première fois que tu vas lancer <span class=\"bold\">Steem</span>, tu auras probablement une succession de fenêtres popup. Si tu es sous <span class=\"bold\">Windows 7</span>, <span class=\"bold\"><span class=\"color-red\">il n\'est plus supporté par Microsoft</span></span>, donc tu n\'auras plus aucune mise à jour, et les fichiers et configurations habituels seront au fil des années de plus en plus difficiles à obtenir. Alors Windows 10 minimum, mais bon c\'est windows et donc tu auras peut être des problèmes, tu vois la fenêtre à droite ? Cela signifie qu\'il te manque un fichier lié à <span class=\"bold\">DirectX</span>, et il est désormais impossible de le réinstaller depuis le site de Microsoft. C\'est simple, <a class=\"link\" href=\"https://www.microsoft.com/fr-fr/download/details.aspx?id=35\" target=\"blanck\">met à jour direct X sur le site officiel de microsoft</a>. Si tu veux rester sous Windows 7 je te fournis un lien qui va te permettre d\'installer DirectX, <a class=\"link\" href=\"https://www.asmtariste.fr/assets/files/directx-Jun2010_redist.zip\" target=\"blank\">une version officielle de juin 2010</a>. ', '', '', NULL, '1722504037409.png', NULL, '', '', '', 4, 1, 4),
(133, '', '', '', '<span class=\"underline\">2 - Préparation à faire <span class=\"bold\">AVANT</span> l\'ouverture de Steem</span><br>\n<br>\nBon, je vais être clair dès le début : je déteste cet émulateur, mais comme certains l\'aiment bien, je suis obligé de guider les noobs, afin de préserver le peu de cheveux qu\'il leur reste, s\'il en reste !<br>\n<br>\nDans le dossier racine de l\'émulateur, tu vas créer 3 dossiers :<br>\n<br>\n<span class=\"italic\"><span class=\"bold\">/tos<br>\n/harddrive<br>\n/st</span></span><br>\n<br>\n<span class=\"underline\">a) - Dans le dossier tos :</span><br>\nTu vas aller chercher dans <span class=\"underline\">l\'unité de disque A</span> du site (System), le tos que tu veux utiliser. Si tu n\'arrives pas à choisir, décompresses tous les fichiers  dans le dossier : tos<br>\n<br>\n<span class=\"underline\">b) - Dans le dossier harddrive :</span><br>\nTu vas simplement créer 3 autres dossiers appelés D, E et F. Ils vont représenter des unités de disques durs et tu pourras stocker plein de choses à l\'intérieur et y avoir accès à la fois depuis l\'environnement du GEM et depuis ton Windows / Linux / MacOS.<br>\n<br>\n<span class=\"underline\">c) - Dans le dossier st :</span><br>\nTu y mettras toutes tes images disques st, stx, etc.', '', '', NULL, '1722504710869.png', NULL, '', '', '', 4, 1, 4),
(134, '', '', '', '<span class=\"underline\">3 - Un popup inutile</span><br>\n<br>\nEnsuite, un popup avec un long texte te demande si tu veux <span class=\"bold\">un raccourci dans ton menu démarrer</span>... il n\'y avait pas besoin de mettre une fenêtre pour si peu... Bref, tu fais <span class=\"bold\">Oui</span> ou <span class=\"bold\">Non</span>, on s\'en fout un peu.', '', '', NULL, '1722505232071.png', NULL, '', '', '', 4, 1, 4),
(135, '', '', '', '<span class=\"underline\">4 – Le choix du TOS</span><br>\n<br>\nEt bam, encore une fenêtre popup avec cette fois un gros pavé de texte à lire, tout ça pour choisir dans la fenêtre suivante ton TOS... Rappelle-toi, je t\'ai fait créer un dossier<span class=\"bold\"> /tos</span>. Prends <span class=\"bold\">EmuTos</span>, par exemple, qui est une version améliorée du TOS original.', '', '', NULL, '1722505556237.png', NULL, '', '', '', 4, 1, 4),
(136, '', '', '', '<span class=\"underline\">5 - Choix du répertoire d\'images de disquettes</span><br>\n<br>\nBordel, encore une popup avec un pavé encore plus gros que le précédent ! Oui, je m\'emporte parce que franchement, ça me gonfle, ça n\'aide en rien et c\'est chiant à lire. Bref, choisis le dossier<span class=\"bold\"> /st</span> que je t\'ai fait créer tout à l\'heure, <span class=\"underline\">c\'est ton dossier de disquettes</span>... au moins, ça sera rangé !', '', '', NULL, '1722505901353.png', NULL, '', '', '', 4, 1, 4),
(137, '', '', '', '<span class=\"underline\">6 - Installation des unités de disque dur</span><br>\n<br>\nIl s\'agit de disques durs <span class=\"bold\">GEMDOS</span> et non <span class=\"bold\">ASCI</span>. Utilise le répertoire <span class=\"bold\">/harddrive</span> que je t\'ai fait créer tout à l\'heure.', '', '', NULL, '1722506478204.png', NULL, '', '', '', 4, 1, 4),
(138, '', '', '', '<span class=\"underline\">7 - Une autre popup...</span><br>\n<br>\nFranchement, c\'est déjà un émulateur anti-ergonomique, mais alors le parcours UX pour son installation est une vraie calamité. Une popup pour te dire comment démarrer l\'émulateur... D\'autant plus qu\'une documentation existe alors pourquoi garder ces fenêtres et nous pourrir les yeux... Bref, c\'est enfin terminé... enfin, là ce n\'était que l\'installation, on n\'a rien configuré du tout !', '', '', NULL, '1722506796895.png', NULL, '', '', '', 4, 1, 4),
(139, 'V - Configuration de Steem', '', NULL, 'Bon, ensuite on passe à sa configuration et on va commencer par parler des problèmes que tu peux rencontrer. Pour commencer, si tu as décidé d\'utiliser <span class=\"bold\">EmuTos</span>, il se peut que tu aies ce bel écran d\'erreur... Je ne sais absolument pas pourquoi, sachant qu\'il s\'agit de la <a class=\"link\" href=\"https://emutos.sourceforge.io/\" target=\"blank\">rom TOS officielle de EmuTOS</a> <span class=\"italic\">(qui, soit dit en passant, est strictement la même que celle que j\'ai mise dans mon vrai 1040STE...)</span>. Bref, si certains peuvent me donner une explication, je suis preneur :)<br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Utilise une ROM TOS 1.62.</span></span>', '', '', NULL, '1722509150494.png', NULL, '', '', '', 5, 1, 4),
(140, '', '', '', '', '', 'Bref, de toute façon, on s\'en fout, il va falloir déjà configurer \"globalement\" Steem. Déjà, retiens les raccourcis suivants :<br>\n<br>\n<span class=\"keyboard-key\">F12</span> : c\'est un toggle pour mettre l\'émulateur en mode <span class=\"bold\"><span class=\"color-orange\">start</span></span> ou <span class=\"bold\"><span class=\"color-red\">stop</span></span> <span class=\"italic\">(d\'ailleurs, le petit icône de la flèche jaune en haut à gauche de la fenêtre s\'active et se désactive à la pression de cette touche).</span><br>\n<span class=\"keyboard-key\">F11</span> : ça permet de <span class=\"bold\">relâcher</span> ou <span class=\"bold\">récupérer</span> ta souris, laissant celle de l\'Atari figée dans l\'émulateur.<br>\nCeci étant dit, maintenant je vais te donner toute une série de captures d\'écran pour que tu y mettes les mêmes réglages que moi pour commencer.<br>\nClique sur la petite roue dentée \"settings\" en haut a droite', NULL, NULL, NULL, '', '', '', 5, 4, 4),
(141, 'Machine Virtuelle ou pas ?', '', '', '<div class=\"border-red\"><p>Attention :<br>\nSi tu utilises une machine virtuelle pour faire tourner <span class=\"bold\">Steem</span> sous <span class=\"bold\">Windows 10</span>, comme c\'est mon cas, une option est nécessaire ; sinon, ta souris sera impossible à contrôler.</p></div><br>\n<br>\nDonc, regarde bien l\'écran à droite : c\'est l\'option <span class=\"bold\"><span class=\"color-green\">VM-friendly</span></span> qu\'il faut cocher.', '', '', NULL, '1722510009142.png', NULL, '', '', '', 5, 1, 4),
(142, '', '', '', '', '', '', '1722510151701.png', '1722510151729.png', NULL, '', '', '', 5, 2, 4),
(143, '', '', '', '', '', '', NULL, NULL, '1722510329649.png', '', '', '', 5, 5, 4),
(144, 'Ajout des disques durs', '', '', 'Ensuite, clique sur l\'icône <span class=\"bold\">Disk Manager</span>, qui permet de gérer les unités de disque dur. Ensuite, clique sur le gros icône <span class=\"bold\">GEMDOS</span> pour cocher la case <span class=\"bold\"><span class=\"color-green\">\"Enable GEMDOS Hard Drives\"</span></span>.<br>\n<br>\nJe t\'ai fait ajouter 4 dossiers tout à l\'heure : <span class=\"bold\">C, D, E, F</span>. Tu dois pointer sur chacun d\'eux avec le bouton <span class=\"bold\"><span class=\"color-green\">Browse</span></span>, et pour ajouter le suivant, utilise le bouton <span class=\"bold\"><span class=\"color-green\">Add</span></span>. Clique sur <span class=\"bold\"><span class=\"color-green\">OK</span></span>.', '', '', NULL, '1722510938312.png', NULL, '', '', '', 5, 1, 4),
(145, '', '', '', '', 'C\'est presque terminé !<br>\n<br>\nRedémarre l\'Atari, sélectionne le <span class=\"bold\">disque C</span>, puis va dans le menu <span class=\"bold\">Options</span> du GEM et choisis <span class=\"bold\">\"Installer une unité disque\"</span>. Sélectionne la lettre qui correspond aux unités installées lors de l\'étape précédente.<br>\n<br>\nEt voilà, tu es prêt à utiliser cet émulateur !', '', '1722511811397.png', NULL, NULL, '', '', '', 5, 6, 4),
(146, 'Un outils graphique : Deluxe Paint', '', '', 'Mis à part la partie \"Capture\" qui sera réalisée par l\'émulateur, il est intéressant de connaître un peu les outils de l\'époque, comme ce logiciel de retouche : <span class=\"bold\">Deluxe Paint</span>.<br>\n<br>\nIl tient sur trois disquettes, mais <span class=\"bold\">seule la disquette n°1 contient le programme d\'exécution</span>. Tu vas le trouver dans l<span class=\"bold\">\'unité disque B (Graphisme)</span> du site. Décompresse le tout, puis pour chaque disquette, copie-colle <span class=\"italic\">(ou plutôt glisse-dépose, comme dans la capture d\'écran à droite)</span> les fichiers dans trois dossiers différents sur l\'un de tes disques durs.<br>\n<br>\n<span class=\"bold\">Deluxe Paint</span> servira à convertir les captures dans les formats que l\'on souhaite. Justement, comme il s\'agit de cela, je vais t\'expliquer les différences entre les images <span class=\"bold\">NEO</span>, <span class=\"bold\">PI1</span> et <span class=\"bold\">PC1</span>.', '', '', NULL, '1722513695738.png', NULL, '', '', '', 1, 1, 13),
(147, '', '', 'Un outil de capture d\'écran : Hatari ou Steem', '', '', 'Tu peux évidemment utiliser <span class=\"bold\">Steem</span> si ça te plaît, le principe est le même, seules les options de l\'émulateur sont différentes. Que ce soit l\'un ou l\'autre, ils ont l\'avantage d\'offrir des captures au format <span class=\"bold\">.PNG</span>, certes, mais surtout au format <span class=\"bold\">.NEO</span>, un format directement lisible par <span class=\"bold\">Deluxe Paint</span>.<br>\n<br>\nAvant toute chose, configure <span class=\"bold\">Hatari</span> pour <span class=\"underline\">ne pas inclure la barre de status</span> que l\'on a habituellement en bas de l\'écran, <span class=\"underline\">ni les bordures</span> en trop, étant donné que l\'on ne veut capturer que <span class=\"bold\">l\'écran de 32 Ko.</span><br>\n<br>\nD\'ailleurs hormis le fait de décocher l\'option <span class=\"bold\"><span class=\"color-green\">\"Show borders\"</span></span>, qui est facile à comprendre, OK mais il ne faut pas oublier d\'enlever le disque ASCI et l\'option <span class=\"bold\"><span class=\"color-green\">\"Boot from hard disk\"</span></span> pour pouvoir booter sur une disquette si celle ci est bootable.', NULL, NULL, NULL, '', '', '', 1, 4, 13),
(148, '', '', '', '', '', '', '1722515160022.png', '1722515160024.png', NULL, '', '', '', 1, 2, 13),
(149, '', '', '', '', 'Pour faire une capture d\'écran, va dans les options de <span class=\"bold\">Hatari</span> avec <span class=\"keyboard-key\">F12</span> -> <span class=\"color-green\">Hatari Screen</span> et tu tomberas sur ce panneau. Par précaution, enlève <span class=\"bold\">\"Indicators\"</span> en mettant : <span class=\"bold\">none</span> <span class=\"italic\">(c\'est la barre du bas)</span>.<br>\n<br>\nSinon, c\'est simple : tu choisis le format <span class=\"bold\">NEO</span> <span class=\"italic\">(c\'est celui qui nous intéresse)</span> et tu cliques sur <span class=\"color-green\"><span class=\"bold\">Screenshot</span></span>, et c\'est tout !', '', '1722516142962.png', NULL, NULL, '', '', '', 1, 6, 13),
(150, '', '', '', 'Alors, si tu es sous <span class=\"bold\">Windows</span>, c\'est simple : <span class=\"bold\">Hatari</span> stocke ses fichiers à sa racine. Les écrans capturés auront un nom de fichier <span class=\"bold\">grap0001.neo</span>, <span class=\"bold\">grab0002.neo</span>, etc. Si tu es sous <span class=\"bold\">Linux</span>, par défaut, <span class=\"bold\">Hatari</span> les stocke dans <span class=\"bold\">\"Dossier personnel\"</span>.<br>\n<br>\nFais ça proprement : Renomme tes fichiers avec un nom de <span class=\"bold\"><span class=\"underline\">maximum 8 caractères</span></span> et déplace-les dans un de tes disques durs GEMDOS <span class=\"italic\">(comme ça, tu pourras y accéder depuis ton Atari).</span>', '', '', NULL, '1722516545409.png', NULL, '', '', '', 1, 1, 13),
(151, '', '', 'Conversion au format PI1 & PC1', '', '', 'On y est ! Tu as sur ton disque dur un fichier <span class=\"bold\">.NEO</span> qui contient ton image capturée ! On va procéder à la conversion de celui-ci aux formats <span class=\"bold\">.PI1</span> et <span class=\"bold\">.PC1</span>. Alors oui, je n\'ai pas encore expliqué ce que sont tous ces formats, mais on va y venir juste après et voir ce qu\'on y trouve.<br>\n<br>\nAllez hop, démarre <span class=\"bold\">Deluxe Paint</span> <span class=\"italic\">(rappelle-toi, tu as copié le contenu des 3 disquettes sur un de tes disques durs)</span> et trouve le fichier <span class=\"bold\">DPAINT.TOS</span>.<br>\n<br>\n<div class=\"border-yellow\"><p><br>\nRappel :<br>\nPense à remettre ton disque dur ASCI et à configurer le boot ainsi que les bordures de ton émulateur.</p></div>', NULL, NULL, NULL, '', '', '', 2, 4, 13);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(152, '', '', '', '', '', 'Tu arrives sur un écran noir, et sache que <span class=\"bold\">Deluxe Paint est en basse résolution</span>. Il existe d\'autres outils pour d\'autres résolutions graphiques, mais c\'est quand même plus sympa avec 16 couleurs !<br>\n<br>\nUne fois sur cet écran, tu as une barre d\'icônes. Tu auras compris qu\'il faut cliquer dessus.<br>\nAlors, clique <span class=\"italic\">(gauche ou droit, cela ne change rien dans ce cas, mais ce n\'est pas le cas pour toutes les icônes de la barre)</span> <span class=\"bold\"><span class=\"color-green\">sur l\'icône en forme de disquette</span></span>. Cela t\'ouvre une fenêtre différente.<br>\nEnsuite sur le bouton <span class=\"color-green\">Charger</span> -> <span class=\"color-green\">Unité</span> et là tu sélectionnes l\'unité dans laquelle se trouve ton fichier <span class=\"bold\">NEO</span>.', NULL, NULL, NULL, '', '', '', 2, 4, 13),
(153, '', '', '', '', '', '', '1722517869233.png', '1722517869239.png', NULL, '', '', '', 2, 2, 13),
(154, '', '', '', '', '', 'Ensuite, c\'est simple : tu sélectionnes ton fichier et tu cliques sur <span class=\"color-green\">OK</span>. À savoir, si tu te trouves dans un répertoire avec plusieurs fichiers de type image, <span class=\"bold\">Deluxe Paint</span> les filtre avec les boutons <span class=\"bold\">*.PI1</span>, *<span class=\"bold\">.PC1</span>, etc. Cependant, il ne filtre pas les autres fichiers qui ne sont pas des images.', NULL, NULL, NULL, '', '', '', 2, 4, 13),
(156, '', '', '', '', '', '', '1722518691009.png', '1722518691010.png', NULL, '', '', '', 2, 2, 13),
(157, 'Conversionnnnnnn !!!', '', '', 'Voilà, on y est arrivé ! Il ne te reste plus qu\'à sauvegarder l\'image actuelle dans les deux autres formats qui nous intéressent. Par le même menu par lequel on a chargé notre image, cette fois-ci, on va la sauvegarder.<br>\n<br>\nClique d\'abord sur le bouton <span class=\"bold\">PI1</span>, cela va automatiquement changer l\'extension du fichier. Tu arrives dans la fenêtre suivante où il ne te reste plus qu\'à choisir l\'endroit où tu souhaites sauvegarder ton fichier <span class=\"italic\">(pour les manipulations suivantes, mets ça à côté du fichier NEO)</span>. Tu cliques sur <span class=\"bold\">OK</span> et c\'est bon.<br>\n<br>\nMaintenant, reproduis les mêmes actions pour créer un fichier <span class=\"bold\">PC1</span>.', '', '', NULL, '1722519062129.png', NULL, '', '', '', 2, 1, 13),
(158, 'NEO (NéoChrome)', '', '', 'Le format d\'image <span class=\"bold\">NeoChrome</span> est spécifiquement associé au logiciel de dessin <span class=\"bold\">NeoChrome</span>, largement utilisé par les artistes et les développeurs de jeux de l\'époque. Si on examine en mémoire une image NEO <span class=\"italic\">(mais cela vaut aussi pour les autres formats)</span>, on trouve une en-tête avec des données qui ne sont pas les données de l\'image proprement dites, mais qui fournissent des renseignements sur sa résolution graphique et sa palette, par exemple <span class=\"italic\">(il y a d\'autres paramètres, mais cela ne nous intéresse pas pour le moment)</span>.<br>\n<br>\nUne image <span class=\"bold\">NEO</span> commence toujours par un mot égal à <span class=\"bold\">$0000</span> (4 octets à zéro). Ensuite, les renseignements sur la résolution sont codés sur un mot :<br>\n<span class=\"bold\"><span class=\"color-red\">$0000</span> pour la haute résolution<br>\n<span class=\"color-red\">$0001</span> pour la résolution moyenne<br>\n<span class=\"color-red\">$0002</span> pour la basse résolution</span><br>\n<br>\nComme on peut le voir sur la capture à droite <span class=\"italic\">(une image NEO que j\'ai chargée en mémoire)</span>, à l\'adresse <span class=\"bold\">$06A7EA</span>, les encres de la palette commencent avec les valeurs <span class=\"bold\">$0000, $0114, $0126</span>, etc., <span class=\"underline\">pour une longueur de 16 mots</span>.<br>\n<br>\nLes données suivantes correspondent à l\'animation des couleurs, la vitesse et la direction de l\'animation, les dimensions de l\'image, etc.', '', '', NULL, '1722521866109.png', NULL, '', '', '', 3, 1, 13),
(159, 'PI1, PI2 et PI3 (Degas Elite)', '', '', 'Le format d\'image <span class=\"bold\">PI</span>x est souvent associé au logiciel de dessin <span class=\"bold\">Degas Elite</span>. PI1, PI2 et PI3 correspondent au 3 principales résolutions graphique de l\'Atari.<br>\nSi on examine en mémoire une image PI1 <span class=\"italic\">(comme pour NEO)</span>, on trouve une en-tête avec des données similaires, mais pas strictement au même endroit. Elles fournissent toujours des renseignements sur la résolution graphique et la palette, etc. <span class=\"italic\">(il y a beaucoup moins de paramètres que pour une image NEO)</span>.<br>\n<br>\nUne image <span class=\"bold\">PI</span>x commence toujours par un mot pour la résolution avec le même principe :<br>\n<span class=\"bold\"><span class=\"color-red\">$0000</span></span> pour la haute résolution<br>\n<span class=\"bold\"><span class=\"color-red\">$0001</span></span> pour la résolution moyenne<br>\n<span class=\"bold\"><span class=\"color-red\">$0002</span></span> pour la basse résolution<br>\n<br>\nLa palette suit juste après la résolution. Comme on peut le voir sur la capture à droite <span class=\"italic\">(une image PI1 que j\'ai chargée en mémoire)</span>, à l\'adresse <span class=\"bold\">$072568</span>, les encres de la palette commencent avec les valeurs <span class=\"bold\">$0000, $0114, $0126</span>, etc., <span class=\"underline\">pour une longueur de 16 mots</span>.<br>\n<br>\nLes données suivantes correspondent directement à l\'image pour une longueur fixe de 16000 mots (soit 32000 octets = 32 Ko). Ensuite, les données pour les animations et autres sont placées à la fin du fichier sur 4 * 4 mots.', '', '', NULL, '1722522523310.png', NULL, '', '', '', 3, 1, 13),
(160, 'PC1, PC2 et PC3 (Degas Elite compressé)', '', '', 'Et pour terminer, le format d\'image <span class=\"bold\">PC</span>x est également signé par <span class=\"bold\">Degas Elite</span>, mais cette fois-ci, les données de l\'image sont compressées, ce qui permet de gagner de l\'espace en mémoire. PC1, PC2 et PC3 correspondent aux trois principales résolutions graphiques de l\'Atari.<br>\n<br>\nSi on examine en mémoire une image PC1 <span class=\"italic\">(comme pour NEO)</span>, on trouve une en-tête avec des données presque identiques. Elles fournissent toujours des renseignements sur la résolution graphique et la palette, etc., comme pour la version non compressée.<br>\n<br>\nUne image <span class=\"bold\">PC</span>x commence toujours par un mot pour la résolution avec le même principe, sauf qu\'on y trouve un $80 comme premier octet :<br>\n<span class=\"bold\"><span class=\"color-red\">$8000</span></span> pour la haute résolution<br>\n<span class=\"bold\"><span class=\"color-red\">$8001</span></span> pour la résolution moyenne<br>\n<span class=\"bold\"><span class=\"color-red\">$8002</span></span> pour la basse résolution<br>\n<br>\nLa palette suit juste après la résolution. Comme on peut le voir sur la capture à droite <span class=\"italic\">(une image PC1 que j\'ai chargée en mémoire)</span>, à l\'adresse <span class=\"bold\">$07A2AA</span>, les encres de la palette commencent avec les valeurs <span class=\"bold\">$0000, $0114, $0126</span>, etc., <span class=\"underline\">pour une longueur de 16 mots</span>.<br>\n<br>\nLes données suivantes correspondent directement à l\'image, mais sont compressées. Selon un article de ST Magazine, voici ce qui est dit sur la compression utilisée :', '', '', NULL, '1722522944864.png', NULL, '', '', '', 3, 1, 13),
(161, '', '', '', '', '', '\"<span class=\"italic\">La méthode de compression utilisée est celle des PackBits. Chaque ligne est compressée séparément, c\'est-à-dire que toutes les données d\'une ligne apparaissent avant celles de la ligne suivante. De même, à l\'intérieur de chaque ligne, chaque plan de couleur est compressé séparément.<br>\n<br>\n<div class=\"border-red\"><p>ATTENTION : Degas Elite utilise un buffer de 40 octets pour décompresser les données en cours de lecture. Ce buffer n\'est vidé que s\'il est plein. Toutes les commandes de décompression (voir l\'algorithme PackBits) doivent contenir moins de 40 octets, sous peine de déclencher un Bus Error lors de la lecture de l\'image par Degas Elite.</p></div></span>\"<br>\n<br>\n<a class=\"link\" href=\"https://download.abandonware.org/magazines/ST%20Magazine/stmagazine_numero051/st%20magazine%20-%20N051%20-%20avril%20mai%201991%20-%20page070%20et%20071.jpg\" target=\"blank\"><span class=\"italic\">ST Magazine n°51 - page 71</span></a>', NULL, NULL, NULL, '', '', '', 3, 4, 13),
(162, '', '', '', '', '', 'Comme c\'est ton premier programme en assembleur, il va falloir être organisé et structurer non seulement ton programme, mais aussi tes fichiers et dossiers. Il faut aussi que tu aies une vision plus précise de ce que l\'on range, pourquoi on doit organiser tout ça, et ce qui se passe si on ne le fait pas.<br>\nCe cours ne sera pas juste dédiée simplement à \"Ouais, ça marche, j\'affiche une image !\". Non. Nous mettrons de l\'ordre dans ton programme et dans les dossier dès le début ! <span class=\"italic\">(je te donnerai une méthode d\'organisation qui est la mienne, il y a plein de façons de faire, l\'important est de pouvoir se relire et de retrouver les choses facilement)</span>.', NULL, NULL, NULL, '', '', '', 1, 4, 14),
(163, 'Préparation du projet', '', '', 'Oui, on ne se lance pas directement sans un minimum de préparation, comme par exemple l\'image que tu souhaites afficher. Donc hop ! Ton premier travail consiste à <span class=\"bold\">capturer une image et à la convertir a<span class=\"underline\">u format PI1 (Degas Elite)</span></span>. Si tu ne sais pas comment faire, alors arrête-toi ici et va d\'abord suivre le tutoriel <a class=\"link\" href=\"https://www.asmtariste.fr/article-content/13/1\" target=\"blank\">\"Capture et conversion d\'image NEO, PI1 et PC1\"</a>.<br>\n<br>\nC\'est bon, tu as ton image ? OK. Alors, tu vas créer quelque part sur un disque dur GEMDOS, un dossier qui portera le nom de ton projet. Par exemple, moi je l\'ai appelé <span class=\"bold\">PROG_ASM.001</span>. Appelle-le comme tu le souhaites, mais il faut que cela ait un rapport avec le thème de ton programme.<br>\n<br>\nDans ce dossier, tu vas créer un autre dossier que tu vas appeler <span class=\"bold\">IMAGES</span>. Et dedans, tu copies l\'image PI1 que tu comptes afficher à l\'écran.', '', '', NULL, '1722553106262.png', NULL, '', '', '', 1, 1, 14),
(164, 'Création du programme principale', '', '', 'Très bien, ton image est prête. À présent, tu vas créer un fichier source avec <span class=\"bold\">DevPac</span>, avec comme première ligne un commentaire sur ce que fait le programme. Exemple :<br>\n<span class=\"code\">; Programme qui sert à afficher une image</span><br>\n<br>\nSauvegarde-le à la racine de ton projet et appelle-le <span class=\"bold\">MAIN.S</span>, de cette façon, on devine que c\'est ce fichier qui est le point d\'entrée du programme <span class=\"italic\">(ça va rappeler quelque chose à ceux qui font du C)</span>.<br>\n<br>\nMaintenant, nous allons assembler le programme et l\'exécuter ! Pour exécuter un programme avec <span class=\"bold\">DevPac</span>, tu vas soit dans le menu <span class=\"bold\">Program</span> -> <span class=\"bold\">Run</span>, ou mieux, mémorise le raccourci <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">X</span>.<br>\n<br>\nTu vois ce qui se produit ? En fait, ton programme démarre (même s\'il n\'y a rien dedans), mais il ne s\'arrête pas correctement.', '', '', NULL, '1722554103617.png', NULL, '', '', '', 1, 1, 14),
(165, '', '', 'Pterm0()', '', '', 'Donc, comment permettre à un programme de se terminer correctement ? Eh bien, il faut faire appel à une fonction fournie par l\'une des couches qui composent le TOS, elle se nomme <span class=\"bold\"><span class=\"color-red\">Pterm0()</span></span>. Le TOS est composé de plusieurs couches, comme par exemple le <span class=\"bold\">GEMDOS</span>. Et <span class=\"bold\"><span class=\"color-red\">Pterm0()</span></span> est fournie par le <span class=\"bold\">GEMDOS</span>. Tu peux aller jeter un œil dans le menu documentation du site, tu y trouveras les fonctions proposées par les différentes couches du TOS, comme le BIOS, XBIOS, GEMDOS, etc.<br>\n<br>\nSelon la documentation, voici comment employer cette fonction :<br>\n<span class=\"code\">move.w #0,-(sp)     ; fonction n°0<br>\ntrap #1     ; appel au GEMDOS</span><br>\n<br>\nCe que dit le code, c\'est que l\'<span class=\"bold\"><span class=\"underline\">on envoie la valeur 0 dans la pile</span></span> <span class=\"italic\">(tu te souviens du registre a0 ou \'sp\' ?)</span> avec une <span class=\"underline\">pré-décrémentation</span>. Pour rappel, <span class=\"bold\">-(sp)</span> signifie que l\'on décrémente d\'abord le registre de la pile d\'un word <span class=\"italic\">(à cause du suffixe .w)</span> pour ensuite y stocker l<span class=\"bold\">a valeur 0, qui correspond au numéro de la fonction <span class=\"color-red\">Pterm0()</span></span> <span class=\"italic\">(et oui, chaque fonction porte un identifiant)</span>. Ensuite, <span class=\"bold\">trap #1</span> fait appel au <span class=\"bold\">GEMDOS</span> <span class=\"italic\">(oui le GEMDOS est identifié par le #1)</span>. Pendant cet appel au <span class=\"bold\">GEMDOS</span>, les paramètres passés dans la pile sont <span class=\"underline\">\"dépilés\"</span> pour être lus et exécutés par le <span class=\"bold\">GEMDOS</span>.<br>\n<br>\nAssemble et exécute à nouveau, ton programme démarre et se termine sans aucune erreur !', NULL, NULL, NULL, '', '', '', 1, 4, 14),
(166, 'Inclure l\'image dans la programme', '', '', 'Bah oui, il faut bien la mettre quelque part cette image pour qu\'elle soit lue ensuite. Une image ne se place pas n\'importe où, pour cela, on dispose d\'une directive d\'assemblage. C\'est propre à l\'assembleur, donc ici dans <span class=\"bold\">DevPac</span>, il s\'agit des directives <span class=\"bold\">SECTION</span>.<br>\n<br>\nIl y en a plusieurs, mais tu dois en connaître trois principales : <br>\n<span class=\"bold\">SECTION TEXT<br>\nSECTION DATA<br>\nSECTION BSS</span>', '', '', NULL, '1722557687746.png', NULL, '', '', '', 1, 1, 14),
(167, '', '', '', '', '', 'Ton image devra être placée dans <span class=\"bold\"><span class=\"color-red\">SECTION DATA</span></span>. Pourquoi ? Cette section est utilisée <span class=\"bold\"><span class=\"underline\">pour les données initialisées</span></span>. Les données placées ici sont celles qui ont une valeur définie au moment de l\'assemblage et qui doivent être présentes dès le démarrage du programme. <span class=\"bold\">Une image PI1, qui est un fichier binaire contenant des données graphiques, a des valeurs définies et connues au moment de l\'assemblage.</span><br>\n<br>\nTon code, quant à lui, devra être placé dans <span class=\"bold\"><span class=\"color-red\">SECTION TEXT</span></span>. Il contient <span class=\"bold\"><span class=\"underline\">le code exécutable</span></span>. C\'est là que tu écris les instructions machine que le processeur doit exécuter. <br>\n<br>\n<span class=\"bold\"><span class=\"color-red\">SECTION BSS</span></span> contient <span class=\"bold\"><span class=\"underline\">les données non initialisées</span></span>. Les variables déclarées ici ne sont pas initialisées et sont mises à zéro par le système au démarrage. C\'est utilisé pour les variables globales ou statiques.<br>\nAs-tu remarqué certains éléments dans l\'exemple de code suivant ?<br>\n<span class=\"code\">monImage:<br>\n          incbin images/rainbow.pi1</span><br>\n<span class=\"color-red\"><span class=\"bold\">monImage:</span></span> : Ce label n\'a pas d\'indentation <span class=\"italic\">(comme les commentaires)</span> et ne commence pas par un <span class=\"keyboard-key\">;</span>, donc ce n\'est pas un commentaire mais un <span class=\"bold\">label</span>. Un label est un repère textuel dans le code qui sera associé à une adresse mémoire une fois le code assemblé. Dans cet exemple, <span class=\"bold\">monImage</span> est utilisé pour marquer l\'emplacement en mémoire où l\'image sera placée.<br>\n<br>\n<span class=\"color-red\"><span class=\"bold\">incbin</span></span> : Il s\'agit d\'une <span class=\"underline\">directive</span> d\'inclusion. Elle permet d\'inclure le contenu d\'un fichier binaire dans le programme. Dans cet exemple, <span class=\"bold\">incbin images/rainbow.pi1</span> inclut le fichier binaire rainbow.pi1 situé dans le répertoire images.<br>\nAinsi, on peut dire que l\'image <span class=\"bold\">PI1</span> est incluse dans la <span class=\"bold\">SECTION DATA</span> à l\'adresse spécifiée par le label <span class=\"bold\">monImage</span>.<br>\n<br>\n', NULL, NULL, NULL, '', '', '', 1, 4, 14),
(168, '', '', 'Afficher l\'image à l\'écran', '', '', 'Bon, à priori, on est bien, non ? Notre programme possède une structure, on a inclus notre image dans la bonne section et le programme se termine correctement !<br>\nUne image <span class=\"bold\">Degas Elite PI1</span> possède une en-tête qui nous donne des informations sur la résolution de l\'image ainsi que sur la palette utilisée.<br>\n<br>\n<div class=\"border-green\"><p>Rappel :<br>\nLes 2 premiers octets correspondent à sa résolution.<br>\nLes 32 octets suivants correspondent à la palette.<br>\nÀ partir du 34e octet, ce sont les données de l\'image (32 000 octets).</p></div><br>\n<br>\n<span class=\"bold\">Les données de l\'image sont stockées de façon linéaire</span>, ce qui signifie que les données à afficher sont dans l\'ordre et se suivent. Donc, si l\'on souhaite obtenir l\'adresse exacte du début de l\'image, c\'est <span class=\"bold\"><span class=\"color-red\">monImage + 2 octets + 32 octets</span></span>. Autrement dit, en assembleur, si je veux stocker l\'adresse de l\'image <span class=\"italic\">(un long word)</span> dans le registre a0 :<br>\n<span class=\"code\">move.l #monImage+34, a0</span><br>\n<br>\nAs-tu remarqué que j\'ai un <span class=\"keyboard-key\">#</span> juste avant le nom du label <span class=\"bold\">monImage:</span> ?<br>\nEffectivement, quand on utilise un label, on enlève d\'une part les <span class=\"keyboard-key\">:</span> et si on veut <span class=\"underline\">l\'adresse du label</span>, on rajoute le <span class=\"keyboard-key\">#</span>.<br>\nEn revanche, si on avait besoin <span class=\"underline\">des octets contenus à l\'adresse du label</span>, on ne met pas de <span class=\"keyboard-key\">#</span>.<br>\nDernière chose, on souhaite afficher cette image à l\'écran. Il te faut donc une adresse qui corresponde à la RAM écran <span class=\"italic\">(appelée \'framebuffer\' ou \'écran logique\', pour rappel)</span>. Si tu es arrivé ici sans avoir suivi le cours <a class=\"link\" href=\"https://www.asmtariste.fr/article-content/10/2\" target=\"blank\">\"La RAM et la ROM\"</a>, alors il va te manquer des prérequis.<br>\n<br>\nAvec notre configuration de 4 Mo, notre framebuffer est donc à l\'adresse <span class=\"bold\">$3F8000</span>, ce qui donne en assembleur :<br>\n<span class=\"code\">move.l #$3F8000, a1</span><br>\nTu remarques une nouvelle fois le <span class=\"keyboard-key\">#</span>. Cela signifie que <span class=\"underline\">l\'on utilise la valeur</span> $3F8000 que l\'on stocke dans le registre a1. (Si on enlève le <span class=\"keyboard-key\">#</span>, cela signifierait que l\'on envoie <span class=\"underline\">les octets contenus à l\'adresse</span> $3F8000 vers a1.)', NULL, NULL, NULL, '', '', '', 2, 4, 14),
(170, '', '', '', 'Voici le principe décrit par le schéma de droite :<br>\n<br>\n<span class=\"underline\"><span class=\"bold\"><span class=\"color-red\">a0</span></span> est notre pointeur d\'adresse de <span class=\"bold\"><span class=\"color-red\">l\'image</span></span></span><br>\n<span class=\"underline\"><span class=\"bold\"><span class=\"color-green\">a1</span></span> est notre pointeur d\'adresse de <span class=\"bold\"><span class=\"color-green\">l\'écran</span></span></span><br>\n<br>\nOn doit recopier les octets contenus à l\'adresse de <span class=\"color-red\">a0</span>, vers l\'adresse que contient <span class=\"color-green\">a1</span>, par groupe de 4 octets. En assembleur, cela donne :<br>\n<br>\n<span class=\"code\">move.l (a0),(a1)<br>\nadd.l #4,(a0)<br>\nadd.l #4,(a1)</span>', '', '', NULL, '1722595254174.png', NULL, '', '', '', 2, 1, 14),
(171, '', '', 'Créer une boucle', '', '', 'Ce n\'est pas terrible comme solution, surtout que l\'on a vu ce qu\'était la post-incrémentation ! Si tu ne vois pas de quoi je parle, alors STOP ! Il te manque le cours <a class=\"link\" href=\"https://www.asmtariste.fr/article-content/11/1\" target=\"blank\">\"Les registres du 68000\"</a>. Si on améliore un peu le code, ça donne :<br>\n<span class=\"code\">move.l (a0)+,(a1)+</span><br>\n<br>\nÀ chaque exécution de cette ligne, chaque registre aura sa valeur incrémentée de 4 octets ! Alors le problème qui va se poser, c\'est qu\'il faut répéter ça 8000 fois (de 0 à 7999). Je sais à quoi tu penses, tu te dis que c\'est facile car tu connais une directive pour répéter ton code :<br>\n<span class=\"code\">REPT 7999<br>\nmove.l (a0)+,(a1)+<br>\nENDR</span><br>\n<br>\nSauf que là, tu vas dupliquer ton instruction 7999 fois dans la mémoire ! Non, on va faire une vraie boucle avec une nouvelle instruction : <span class=\"bold\">DBF</span> ou son équivalent <span class=\"bold\">DBRA</span><br>\n<span class=\"bold\">DBF</span> est une instruction de comparaison.<br>\nPour la comprendre, il faut voir cette syntaxe : <span class=\"bold\">DBcc</span> <span class=\"italic\">Dn</span>, <span class=\"italic\">label</span>.<br>\n<br>\n<span class=\"bold\">DB</span> représente l\'instruction, quant à <span class=\"bold\">cc</span>, c\'est simplement son suffixe qui, dans notre cas, est <span class=\"bold\">F</span>.<br>\n<span class=\"bold\">F</span> indique une condition fausse . <span class=\"italic\">Dn</span> représente un registre de données de d0 à d7.<br>\n<span class=\"italic\">Label</span> indique l\'adresse vers laquelle on boucle si la condition <span class=\"bold\">F</span> est vérifié (donc ici fausse).<br>\n<br>\n<span class=\"bold\">DBF</span> vérifie a chaque passage si la valeur de <span class=\"italic\">Dn</span> est ou non égale à -1 ($FFFF en hexa), SI c\'est le cas on passe à l\'instruction suivante.<br>\nSi ce n\'est pas le cas alors on retourne à <span class=\"italic\">label</span> et <span class=\"italic\">Dn</span> est décrémenté de 1. Simple non ?', NULL, NULL, NULL, '', '', '', 2, 4, 14),
(172, '', '', '', 'Ouvre Devpac et tape ce petit programme, ensuite assemble le et ouvre Monst :<br>\n<span class=\"code\">          move.l #$66666,a0     ; lecture d\'une adresse au pif<br>\n          move.l #$3F8000,a1     ; framebuffer<br>\n          move.b #9,d0     ; compteur à 9<br>\nloop:<br>\n          move.l (a0)+,(a1)+<br>\n          dbf d0,loop</span><br>\n<br>\n<div class=\"border-yellow\"><p>Remarque:<br>\n<span class=\"bold\">d0 se décrémente</span> de 1 à chaque passage sur dbf<br>\nQuand <span class=\"bold\">d0 = -1</span> ($FFFF) alors la boucle s\'arrête et on passe à la suite <span class=\"italic\">(si d0 = 9 alors on obtient 10 boucles)</span></p></div>', '', '', NULL, '1722598432585.png', NULL, '', '', '', 2, 1, 14),
(173, '', '', '', 'Ajoute ces lignes juste après SECTION TEXT :<br>\n<span class=\"code\">; Afficher l\'image<br>\n          move.l #monImage+34,a0     ; adresse de l\'image<br>\n          move.l #$3F8000,a1     ; adresse du framebuffer<br>\n          move.w #8000-1,d0     ; le compteur de long word<br>\nloop:<br>\n          move.l (a0)+,(a1)+     ; on recopie à l\'écran<br>\n          dbf d0,loop     ; on boucle jusqu\'à -1</span><br>\n<br>\nAssemble ton programme, puis direction le débogueur dans lequel je vais t\'apprendre une nouvelle chose très pratique.<br>\n<br>\nSi tu traces ton code avec <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">T</span>, sur une boucle qui va boucler 8000 fois, ça va être long ! Alors, on va mettre ce que l\'on appelle un <span class=\"bold\">breakpoint</span>, c\'est-à-dire un point d\'arrêt là où tu souhaites que ton programme s\'arrête.<br>\n<br>\nDéfile ton programme avec les flèches curseur juste après ta boucle et utilise le raccourci <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">B</span>. Tu devrais voir apparaître <span class=\"bold\"></span>, qui représente l\'endroit où ton programme va s\'arrêter si tu l\'exécutes dans <span class=\"bold\">Monst</span>.<br>\n<br>\nEt d\'ailleurs, c\'est ce que l\'on va faire : <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">R</span> pour exécuter ton programme jusqu\'au <span class=\"bold\">breakpoint</span>. Ensuite la touche <span class=\"keyboard-key\">V</span> pour voir ce qui s\'est passé à l\'écran', '', '', NULL, '1722601647366.png', NULL, '', '', '', 2, 1, 14),
(174, '', '', '', '', '', '', NULL, NULL, '1722601920279.png', '', '', '', 2, 5, 14),
(175, '', '', 'Changer la résolution de l\'image', '', '', 'On a effectivement un petit problème : <span class=\"bold\">on essaye d\'afficher une image en haute résolution alors qu\'on est en moyenne résolution</span>. Pour changer de résolution, il faut faire appel à une autre couche qui compose le <span class=\"bold\">TOS</span>, comme on l\'a déjà fait pour <span class=\"bold\">Pterm0()</span>. Mais cette fois-ci, c\'est une fonction du <span class=\"bold\">XBIOS</span>, la couche la plus basse du TOS.<br>\n<br>\nLa fonction s\'appelle <span class=\"bold\"><span class=\"color-red\">Setscreen()</span></span> et c\'est la <span class=\"bold\">fonction numéro 5</span>. Elle ne permet pas seulement de définir la résolution de l\'écran, mais aussi de définir l\'adresse de l\'écran logique (le framebuffer) et de l\'écran physique.<br>\n<br>\nSelon la documentation du XBIOS, voici comment on appelle cette fonction en assembleur :<br>\n<span class=\"code\">          move.w #0,-(sp)      ; 0 : basse résolution<br>\n          move.l #-1,-(sp)     ; -1 = écran physique : pas de changement<br>\n          move.l #-1,-(sp)     ; -1 = écran logique  : pas de changement<br>\n          move.w #5,-(sp)      ; 5 = numéro de la fonction<br>\n          trap #14             ; 14 = appel du XBIOS<br>\n          add.w #12,sp         ; 12 = w + l + l + w</span><br>\n<br>\nLe principe est exactement le même que pour <span class=\"bold\">Pterm0()</span> : on envoie nos paramètres dans la pile, et ensuite ils seront dépilés pour être pris en compte par la fonction.<br>\n<br>\nSeulement, on a une petite nouveauté : <span class=\"bold\">add.w #12,sp</span><br>\nLe fait d\'avoir rempli la pile avec nos paramètres a décalé l\'adresse de la dernière valeur de <span class=\"underline\">12 octets</span>, donc ça risque de planter si on ne rectifie pas la pile à sa valeur d\'origine.<br>\nIl suffit de compter le nombre d\'octets qu\'on lui a envoyés avec nos paramètres : <span class=\"bold\">1 word, 2 long words et 1 autre word = 2 octets + 2 * 4 octets + 2 autres octets = 12</span>.<br>\n<br>\n<div class=\"border-green\"><p>A retenir : <br>\nLes valeurs -1 sont passé pour dire \"on ne change pas les valeur de ces paramètres\"<br>\nValeur pour la basse résolution : 0<br>\nValeur pour la moyenne résolution : 1<br>\nValeur pour la haute résolution : 2</p></div><br>\n<br>\nAlors tu vas coller ce bout de code au tout début de ton fichier source en choisissant comme paramètre : <span class=\"bold\">0 (basse résolution)</span><br>\n<br>\n<div class=\"border-red\"><p>Attention : <br>\nQuand ton programme se termine il faut revenir en moyenne résolution ....</p></div><br>\nDonc tu sais quoi faire, je te laisse te débrouiller.<br>\n<br>\nAlors tiens, c\'est cadeau : je te présente une autre fonction <span class=\"bold\">GEMDOS</span> très pratique qui s\'appelle <span class=\"bold\"><span class=\"color-red\">Cconin()</span></span>. Cette fonction attend la pression d\'une touche du clavier. Elle fait même mieux que ça : <span class=\"bold\"><span class=\"underline\">elle renvoie automatiquement dans le registre d0 le code hexadécimal de la touche que tu as pressée</span></span>. Pour le moment, ce n\'est pas essentiel, mais c\'est bon à savoir. Certaines fonctions renvoient des valeurs dans les registres, donc il est important de bien lire la documentation de ces instructions pour éviter les mauvaises surprises.<br>\nPlace ce code juste après ta boucle d\'affichage de l\'image. Cela te laissera le temps de voir le résultat sans avoir à utiliser le raccourci <span class=\"keyboard-key\">V</span> de <span class=\"bold\">Monst</span> à chaque fois :<br>\n<span class=\"code\">; Attendre une pression de touche<br>\n          move.w #1,-(sp)     ; 1 = numéro de la fonction Cconin<br>\n          trap #1             ; appel du GEMDOS<br>\n          add #2,sp          ; ajuster la pile (1 word = 2 octets)</span><br>\nTu devrais obtenir un meilleur résultat :  ', NULL, NULL, NULL, '', '', '', 3, 4, 14),
(176, '', '', '', '', '', '', NULL, NULL, '1722606317693.png', '', '', '', 3, 5, 14),
(177, '', '', 'Charge la palette le couleur de l\'image', '', '', 'Bon y\'a du mieux mais il manque encore les bonnes couleurs ! Pour le moment ton programme devrait à peu près ressembler à çà : <br>\n<br>\n<span class=\"code\">; Programme qui sert à l\'affichage d\'une image PI1 en haute résolution<br>\n<br>\n	SECTION TEXT<br>\n<br>\n; Passage en basse résolution<br>\n; Afficher l\'image<br>\n; Attendre une touche	<br>\n; Passage en moyenne résolution<br>\n; Terminer le programme<br>\n<br>\n	SECTION DATA<br>\nmonImage:<br>\n	incbin	images/rainbow.pi1</span><br>\n<br>\nAvant d\'aller plus loin, il est important de mettre un peu d\'ordre dans tout ça. Crée un nouveau fichier (raccourci <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">C</span>) et lorsque tu veux passer d\'une fenêtre à l\'autre, utilise <span class=\"keyboard-key\">Ctrl</span> + <span class=\"keyboard-key\">V</span>. Appelle ce fichier <span class=\"bold\">TRAPS.S</span> et copie-colle toutes tes fonctions qui utilisent les appels au <span class=\"bold\">GEMDOS</span> et au <span class=\"bold\">XBIOS</span>, à savoir : <span class=\"bold\">Setscreen(), Cconin() et Pterm0()</span>.<br>\n<br>\n<div class=\"border-green\"><p>Astuce pour le copier-coller dans DevPac :<br>\nPour sélectionner un bloc de code avec la souris comme d\'habitude, puis :<br>\n<span class=\"keyboard-key\">Shift</span> + <span class=\"keyboard-key\">F4</span> pour copier<br>\n<span class=\"keyboard-key\">Shift</span> + <span class=\"keyboard-key\">F5</span> pour couper<br>\n<span class=\"keyboard-key\">F5</span> pour coller</p></div><br>\n<br>\nPour chaque bout de code tu va créer une description de ton bout de code et un nom de label, par exemple pour <span class=\"bold\">Setscreen()</span> çà donnera çà : <br>\n<span class=\"code\">; ------------------------------<br>\n; Changing the screen resolution<br>\n;<br>\n; params : d0 = resolution value<br>\n; ------------------------------<br>\nchangeResolution:<br>\n	move.w	d0,-(sp)		; push resolution value<br>\n	move.l	#-1,-(sp)		; push physical screen adress<br>\n	move.l  #-1,-(sp)		; push logical screen adress<br>\n	move.w	#_Setscreen,-(sp)	; push Setscreen function number<br>\n	trap 	#XBIOS			; XBIOS call	<br>\n	add.w	#12,sp			; pop stack<br>\n	rts</span><br>\n<br>\n<span class=\"bold\">PAS DE PANIQUE !</span> Je vais t\'expliquer ce que j\'ai fait et pourquoi. Si tu mets tout ton code dans <span class=\"bold\">MAIN.S</span>, ton fichier deviendra vite illisible. Il est donc important de structurer ton code. Par exemple, tous les appels aux fonctions <span class=\"bold\">GEMDOS</span> et <span class=\"bold\">XBIOS</span> seront regroupés au même endroit. Cela simplifie la recherche et offre une meilleure vision globale de l\'architecture de ton code.<br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Explications sur les modifications :</span></span><br>\n<span class=\"underline\">Le label <span class=\"bold\">changeResolution:</span></span> est désormais la nouvelle adresse, et ton code sera référencé sous ce label.<br>\n<span class=\"underline\">1ère ligne :</span> J\'ai remplacé <span class=\"bold\">#0</span> par le nom d\'un registre. Idéalement, nous souhaitons utiliser ce code pour les 3 résolutions, sans dupliquer le code entier juste pour une valeur qui change. Cette valeur devient donc une variable.<br>\n<br>\n<span class=\"underline\">4ème ligne :</span> À la place de <span class=\"bold\">#5</span>, j\'ai écrit <span class=\"bold\">#_Setscreen</span>. J\'ai créé un fichier <span class=\"bold\">PARAMS.S</span> contenant la directive d\'assemblage <span class=\"bold\">EQU</span>. Par exemple :<br>\n<span class=\"code\">_Setscreen    EQU    5</span><br>\nCela signifie que si tu écris <span class=\"bold\">_Setscreen</span>, l\'assembleur le remplacera par <span class=\"bold\">5</span>.<br>\n<br>\n<span class=\"underline\">5ème ligne :</span> À la place de <span class=\"bold\">#14</span>, j\'ai écrit <span class=\"bold\">#XBIOS</span>. C\'est le même principe que précédemment, défini également dans le fichier <span class=\"bold\">PARAMS.S</span>.<br>\n<br>\n<span class=\"underline\">Dernière ligne :</span> <span class=\"bold\">RTS</span>. Cette instruction du 68000 utilise une adresse stockée dans la pile avec l\'instruction <span class=\"bold\">BSR</span>. Cela permet de revenir à l\'adresse suivant celle à laquelle l\'appel <span class=\"bold\">bsr changeResolution</span> a été invoqué.<br>\n', NULL, NULL, NULL, '', '', '', 4, 4, 14),
(178, '', '', '', '', '', 'Normalement tu devrais avoir dans mon fichier MAIN.S : <br>\n<span class=\"code\">; Programme qui sert  l\'affichage d\'une image PI1 en haute rsolution<br>\n<br>\n	SECTION TEXT<br>\n	<br>\n	move.w	#LOW_RES,d0		; set resolution<br>\n	bsr	changeResolution	<br>\n<br>\n; Afficher l\'image<br>\n	move.l 	#monImage+34,a0	; adresse de l\'image<br>\n	move.l 	#$3F8000,a1	; adresse du framebuffer<br>\n	move.w 	#8000-1,d0	; le compteur de long word<br>\nloop:<br>\n	move.l 	(a0)+,(a1)+<br>\n	dbf	d0,loop		<br>\n<br>\n	bsr	waitKey		; waiting for a key<br>\n<br>\n	move.w	#MID_RES,d0	; restore resolution<br>\n	bsr	changeResolution<br>\n<br>\n	jmp	exitProgram	; terminate and back to GEM<br>\n<br>\n	include traps.s<br>\n	include params.s<br>\n<br>\n	SECTION DATA<br>\n<br>\nmonImage:<br>\n	incbin	images/rainbow.pi1</span><br>\n<br>\n<div class=\"border-yellow\"><p>Note :<br>\nLa directive <span class=\"bold\">include</span> permet d\'inclure une fichier source dans un autre, évitant ainsi des fichiers trop long, et permettant une meilleur lisibilité</p></div>', NULL, NULL, NULL, '', '', '', 4, 4, 14),
(179, '', '', '', '', '', 'Dernière ligne droite avant le questionnaire !<br>\nTu vas maintenant ajouter une nouvelle fonction à tes connaissances : la fonction <span class=\"bold\"><span class=\"color-red\">Setpalette()</span></span>. Elle est offerte gracieusement par le <span class=\"bold\">XBIOS</span> et porte le numéro <span class=\"bold\">6</span>.<br>\n<br>\nLe principe est exactement le même que pour les autres fonctions : des paramètres, un appel au <span class=\"bold\">XBIOS</span> et une rectification de la pile :<br>\n<span class=\"code\">; --------------------------<br>\n; Loading a color ST Palette<br>\n;<br>\n; params: <#palette_adr>,a0 <br>\n; -------------------------- <br>\nloadPalette:<br>\n	move.l	a0,-(sp)		; push the palette adress<br>\n	move.w	#_Setpalette,-(sp)	; push the function number<br>\n	trap	#XBIOS			; Calling XBIOS<br>\n	add.w	#6,sp			; pop stack<br>\n	rts</span><br>\n<br>\nUtilisation de la fonction loadPalette : <br>\nTu n\'as plus qu\'à faire un <span class=\"bold\">bsr loadPalette</span> après avoir chargé ta palette dans <span class=\"bold\">a0</span> <span class=\"italic\">(je te rappelle que la palette est située à monImage+2)</span>.', NULL, NULL, NULL, '', '', '', 4, 4, 14),
(180, '', '', '', '', '', '', NULL, NULL, '1722612104472.png', '', '', '', 4, 5, 14),
(181, '', '', 'Fichiers Sources', '', '', 'Voici les fichiers <a class=\"link\" href=\"https://www.asmtariste.fr/assets/files/sources/PROG_ASM.001.zip\" target=\"blank\">sources du cours à télécharger</a>', NULL, NULL, NULL, '', '', '', 4, 4, 14),
(182, '', '', '', '', '', 'Le XBIOS peut être subdivisé en les groupes de fonctions suivants :<br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Fonctions de gestion de l\'écran et du son :</span></span> Ces fonctions permettent de contrôler les modes d\'affichage, de gérer les interruptions vidéo, ainsi que d\'initialiser et de contrôler le générateur de son.<br>\n<span class=\"bold\"><span class=\"underline\">Fonctions de gestion des périphériques :</span></span> Elles sont utilisées pour la gestion des périphériques tels que les lecteurs de disquettes et les ports d\'interface.<br>\n<span class=\"bold\"><span class=\"underline\">Fonctions de contrôle système :</span></span> Elles incluent des fonctions pour le contrôle des horloges système, des interruptions, et d\'autres paramètres système essentiels.<br>\n<span class=\"bold\"><span class=\"underline\">Fonctions de gestion de la mémoire :</span></span> Ces fonctions permettent de contrôler l\'accès à la mémoire et de configurer les différentes zones de mémoire.<br>\n<span class=\"bold\"><span class=\"underline\">Fonctions de gestion des événements :</span></span> Elles gèrent les événements matériels et logiciels, permettant une interaction fluide entre le matériel et le système d\'exploitation.<br>\n<br>\nCes groupes de fonctions assurent une interface complète pour l\'utilisation des capacités matérielles spécifiques de l\'Atari, offrant ainsi un contrôle détaillé et précis sur les composants matériels.<br>\nLe XBIOS est réentrant dans MagiC. Cela signifie que ces fonctions peuvent également être appelées à partir des interruptions <span class=\"italic\">(à condition que la pile du superviseur concernée ne déborde pas...)</span>.<br>\n<br>\n<span class=\"bold\"><span class=\"color-red\">Le XBIOS prend ses paramètres depuis la pile, dans l\'ordre inverse</span></span> ; cela signifie que le dernier argument de la liste des paramètres est stocké en premier sur la pile. Les résultats des fonctions sont retournés dans le registre processeur d0. Seuls les registres d3-d7 et a3-a7 sont sauvegardés, tous les autres peuvent être modifiés par l\'appel.', NULL, NULL, NULL, '', '', '', 1, 4, 15),
(183, '', '', '', '', '', '<span class=\"bold\">Cursconf :</span> Change ou obtient l\'affichage du curseur.<br>\n<span class=\"bold\">EgetPalette :</span> Lit la palette de couleurs.<br>\n<span class=\"bold\">EgetShift :</span> Lit le registre de mode de décalage.<br>\n<span class=\"bold\">EsetBank :</span> Définit la table de couleurs.<br>\n<span class=\"bold\">EsetColor :</span> Définit une entrée de la table de couleurs.<br>\n<span class=\"bold\">EsetGray :</span> Définit l\'interprétation des couleurs.<br>\n<span class=\"bold\">EsetPalette :</span> Charge la palette de couleurs.<br>\n<span class=\"bold\">EsetShift :</span> Définit le registre de mode de décalage.<br>\n<span class=\"bold\">EsetSmear :</span> Définit le smear de couleur.<br>\n<span class=\"bold\">Getrez :</span> Obtient la résolution.<br>\n<span class=\"bold\">Initmouse :</span> Initialise le pointeur de la souris.<br>\n<span class=\"bold\">Logbase :</span> Obtient l\'adresse de la mémoire écran logique.<br>\n<span class=\"bold\">mon_type :</span> Obtient le type de moniteur.<br>\n<span class=\"bold\">Physbase :</span> Obtient l\'adresse de la mémoire écran physique.<br>\n<span class=\"bold\">Setcolor :</span> Définit une couleur.<br>\n<span class=\"bold\">Setpalette :</span> Sélectionne la palette de couleurs.<br>\n<span class=\"bold\">Setscreen :</span> Définit la résolution actuelle de l\'écran et les adresses de base.<br>\n<span class=\"bold\">ValidMode :</span> Valide un code de mode.<br>\n<span class=\"bold\">VgetRGB :</span> Obtient la valeur RGB d\'une couleur.<br>\n<span class=\"bold\">VsetScreen :</span> Définit la résolution de l\'écran et les adresses de base.<br>\n<span class=\"bold\">VgetSize :</span> Obtient la taille du tampon d\'écran.<br>\n<span class=\"bold\">VsetMask :</span> Définit la transparence pour le True-Color.<br>\n<span class=\"bold\">VsetMode :</span> Définit le registre matériel vidéo.<br>\n<span class=\"bold\">VsetRGB :</span> Définit la valeur RGB d\'une couleur.<br>\n<span class=\"bold\">VsetSync :</span> Définit le type de synchronisation pour la vidéo externe.<br>\n<span class=\"bold\">Vsync :</span> Obtient le signal de synchronisation verticale.', NULL, NULL, NULL, '', '', '', 1, 4, 15),
(184, 'Cursconf', '', '', '<span class=\"bold\">Nom :</span> Configure le fonctionnement du curseur VT52<br>\n<span class=\"bold\">Opcode :</span> 21<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Cursconf(int16_t func, int16_t rate);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS Cursconf modifie l\'apparence et, si souhaité, le taux de clignotement du curseur. Le paramètre func peut prendre les valeurs suivantes :<br>\n<br>\nfunc	Signification<br>\n0	Désactive le curseur (le cache)<br>\n1	Active le curseur<br>\n2	Active le clignotement du curseur<br>\n3	Désactive le clignotement du curseur<br>\n4	Le taux de clignotement du curseur sera défini à la valeur rate<br>\n5	Retourne le taux de clignotement actuel<br>\n', '<div class=\"border-red\"><p>Remarque : Le paramètre rate doit être utilisé en fonction de la fréquence de répétition de l\'écran.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction ne retourne un résultat défini, à savoir le taux de clignotement, que si le numéro 5 a été passé dans le paramètre func.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    rate,-(sp)   ; Offset 4<br>\nmove.w    func,-(sp)   ; Offset 2<br>\nmove.w    #21,-(sp)    ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\naddq.l    #6,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(185, 'EgetPalette', '', '', '<span class=\"bold\">Nom :</span> Lit plusieurs entrées de la table des couleurs dans un buffer spécifié.<br>\n<span class=\"bold\">Opcode :</span> 85<br>\n<span class=\"bold\">Syntaxe :</span> void EgetPalette(int16_t colorNum, int16_t count, int16_t *palettePtr);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS EgetPalette lit une région contiguë des registres de couleurs TT.<br>\n<br>\nParamètre	Signification<br>\ncolorNum	Premier registre de couleur à lire<br>\ncount	Nombre de registres de couleur à lire<br>\npalettePtr	Pointeur vers la palette de couleurs à transférer (doit être aligné)<br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction ne retourne aucun résultat.<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT.<br>\n<br>\n<span class=\"code\">pea       palettePtr      ; Offset 6<br>\nmove.w    count,-(sp)     ; Offset 4<br>\nmove.w    colorNum,-(sp)  ; Offset 2<br>\nmove.w    #85,-(sp)       ; Offset 0<br>\ntrap      #14             ; Appel XBIOS<br>\nlea       $A(sp),sp       ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(186, 'EgetShift', '', '', '<span class=\"bold\">Nom :</span> »Obtenir la valeur du mode de décalage actuel« - Lit le registre du mode de décalage (le mode actuel du commutateur vidéo).<br>\n<span class=\"bold\">Opcode :</span> 81<br>\n<span class=\"bold\">Syntaxe :</span> int16_t EgetShift(void);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS EgetShift lit le registre du mode de décalage et retourne le contenu du registre.', '<span class=\"bold\">Valeur de retour : </span>La fonction retourne la valeur du registre, avec les affectations suivantes :<br>\n<br>\nBit	Signification<br>\n0..3	Numéro de la banque de registres de couleur<br>\n8..10	Mode, selon Getrez<br>\n12	Hyper-mono (cf. EsetGray)<br>\n15	Mode smear (cf. EsetSmear)<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT.<br>\n<br>\n<span class=\"code\">move.w    #81,-(sp)    ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\naddq.l    #2,sp        ; Correction de la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(187, 'EsetBank', '', '', '<span class=\"bold\">Nom :</span> »Définir la banque de la table des couleurs« - Définit la banque pour la table des couleurs parmi les 16 disponibles.<br>\n<span class=\"bold\">Opcode :</span> 82<br>\n<span class=\"bold\">Syntaxe :</span> int16_t EsetBank(int16_t bankNum);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS EsetBank définit le numéro de banque pour la table des couleurs du TT à la valeur bankNum. La valeur permise pour bankNum se situe entre 0 et 15. Si bankNum est négatif, le paramètre actuel ne sera pas modifié.', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne le paramètre précédent.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT.<br>\n<br>\n<span class=\"code\">move.w    bankNum,-(sp)  ; Offset 2<br>\nmove.w    #82,-(sp)      ; Offset 0<br>\ntrap      #14            ; Appel XBIOS<br>\naddq.l    #4,sp          ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(188, 'EsetColor', '', '', '<span class=\"bold\">Nom : </span>»Définir une entrée de couleur« - Écrit une entrée dans la table des couleurs pour une couleur individuelle.<br>\n<span class=\"bold\">Opcode :</span> 83<br>\n<span class=\"bold\">Syntaxe :</span> int16_t EsetColor(int16_t colorNum, int16_t color);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS EsetColor définit l\'entrée de couleur colorNum (0..255) dans la table des couleurs à la valeur color ; une valeur négative ne modifie pas l\'entrée.', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne la valeur précédente.<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT.<br>\n<br>\n<span class=\"code\">move.w    color,-(sp)     ; Offset 4<br>\nmove.w    colorNum,-(sp)  ; Offset 2<br>\nmove.w    #83,-(sp)       ; Offset 0<br>\ntrap      #14             ; Appel XBIOS<br>\naddq.l    #6,sp           ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(189, 'EsetGray', '', '', '<span class=\"bold\">Nom :</span> »Définir/effacer le mode gris« - Active ou désactive l\'interprétation des couleurs dans le commutateur vidéo.<br>\n<span class=\"bold\">Opcode : </span>86<br>\n<span class=\"bold\">Syntaxe :</span> int16_t EsetGray(int16_t switch);<br>\n<span class=\"bold\">Description : </span>La routine XBIOS EsetGray active (1) ou désactive (0) l\'interprétation des couleurs dans la table des couleurs en tant que nuances de gris. Une valeur négative retourne le bit gris du commutateur vidéo sans modifier le réglage.<br>\n<br>\nEn mode nuances de gris, on peut sélectionner une palette de 256 nuances de gris (0-255) au lieu de 4096 couleurs (RGB 0-15).', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne la valeur précédente du bit gris du commutateur vidéo.<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT (lorsque le mot de haut de la cookie \'_VDO\' a la valeur de 2).<br>\n<br>\n<span class=\"code\">move.w    switch,-(sp) ; Offset 2<br>\nmove.w    #86,-(sp)    ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\naddq.l    #4,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(190, 'EsetPalette', '', '', '<span class=\"bold\">Nom :</span> »Définir les registres de palette« - Définit plusieurs entrées dans la table des couleurs à partir du buffer spécifié.<br>\n<span class=\"bold\">Opcode : </span>84<br>\n<span class=\"bold\">Syntaxe :</span> void EsetPalette(int16_t colorNum, int16_t count, int16_t *palettePtr);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS EsetPalette définit count entrées de couleur à partir de colorNum dans la table des couleurs aux valeurs dans le tableau palettePtr.', '<span class=\"bold\">Valeur de retour :</span> La fonction n\'a pas de valeur de retour.<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT.<br>\n<br>\n<span class=\"code\">pea       palettePtr      ; Offset 6<br>\nmove.w    count,-(sp)     ; Offset 4<br>\nmove.w    colorNum,-(sp)  ; Offset 2<br>\nmove.w    #84,-(sp)       ; Offset 0<br>\ntrap      #14             ; Appel XBIOS<br>\nlea       $A(sp),sp       ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 15);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(191, 'EsetShift', '', '', '<span class=\"bold\">Nom : </span>»Définir le registre de mode de décalage« - Définit les registres de mode de décalage du commutateur vidéo.<br>\n<span class=\"bold\">Opcode :</span> 80<br>\n<span class=\"bold\">Syntaxe :</span> int16_t EsetShift(int16_t shftMode);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS EsetShift écrit dans le registre du mode de décalage du TT la valeur shftMode. shftMode est un tableau de bits avec les affectations suivantes :<br>\n<br>\nBit	Signification<br>\n0..3	Numéro de la banque de registres de couleur<br>\n8..10	Mode selon Getrez<br>\n12	Hyper-mono (cf. EsetGray)<br>\n15	Mode smear (cf. EsetSmear)', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne la valeur précédente du registre.<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT.<br>\n<br>\n<span class=\"code\">move.w    shftMode,-(sp)  ; Offset 2<br>\nmove.w    #80,-(sp)       ; Offset 0<br>\ntrap      #14             ; Appel XBIOS<br>\naddq.l    #4,sp           ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(192, 'EsetSmear', '', '', '<span class=\"bold\">Nom :</span> »Définir/effacer le mode smear vidéo« - Active (1) ou désactive (0) le mode smear du commutateur vidéo.<br>\n<span class=\"bold\">Opcode : </span>87<br>\n<span class=\"bold\">Syntaxe :</span> int16_t EsetSmear(int16_t switch);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS EsetSmear permet de basculer le mode smear du commutateur vidéo TT. En mode smear, la couleur du dernier pixel affiché est dessinée à chaque fois à la place de la couleur de fond (couleur 0).<br>\n<br>\nswitch	Signification<br>\n<0	Obtenir la valeur existante<br>\n0	Mode smear désactivé<br>\n>0	Mode smear activé', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne la valeur existante.<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement dans le TOS de l\'Atari TT.<br>\n<br>\n<span class=\"code\">move.w    switch,-(sp)  ; Offset 2<br>\nmove.w    #87,-(sp)     ; Offset 0<br>\ntrap      #14           ; Appel XBIOS<br>\naddq.l    #4,sp         ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 2, 3, 15),
(193, 'Getrez', '', '', '<span class=\"bold\">Nom :</span> »get resolution« - Retourne le code de la résolution actuelle de l\'écran.<br>\n<span class=\"bold\">Opcode :</span> 4<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Getrez(void);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS Getrez obtient la résolution actuelle de l\'écran.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne les valeurs suivantes :<br>\n<br>\nValeur	Signification<br>\n0	320x200 (4 plans)<br>\n1	640x200 (2 plans)<br>\n2	640x400 (1 plan)<br>\n4	640x480 (4 plans, TT uniquement)<br>\n6	1280x960 (1 plan, TT uniquement)<br>\n7	320x480 (8 plans, TT uniquement)<br>\nToutes les autres valeurs sont réservées pour des extensions futures.', '<div class=\"border-red\"><p>Remarque : Pour une programmation propre, il est recommandé de ne pas utiliser cette fonction car elle dépend fortement du matériel, notamment lorsqu\'il y a des cartes graphiques en usage. La résolution de l\'écran devrait être obtenue via la fonction VDI (v_opnvwk).</p></div><br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    #4,-(sp)     ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\naddq.l    #2,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 15),
(194, 'Initmouse', '', '', '<span class=\"bold\">Nom :</span> »initialize mouse« - Initialise le gestionnaire de souris.<br>\nOpcode : 0<br>\n<span class=\"bold\">Syntaxe : </span>void Initmouse(int16_t type, MOUSE *par, void (*mousevec)());<br>\n<span class=\"bold\">Description :</span> La routine XBIOS Initmouse initialise la souris au niveau bas. Le paramètre type définit le mode de fonctionnement de la souris. Les valeurs suivantes s\'appliquent :<br>\n<br>\ntype	Signification<br>\n0	Désactiver la souris<br>\n1	Activer la souris en mode relatif<br>\n2	Activer la souris en mode absolu<br>\n3	Non utilisé<br>\n4	Activer la souris en mode code de touche<br>\n<br>\nLes octets de 4 à 11 du paramètre par sont utilisés uniquement lorsque la souris fonctionne en mode absolu. Avec mousevec, on peut définir un nouveau vecteur d\'interruption de la souris. Le vecteur sera réinitialisé si la souris est désactivée (type=0).<br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne -1 si elle fonctionne correctement ou 0 si une erreur s\'est produite.<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">pea       mousevec     ; Offset 8<br>\npea       par          ; Offset 4<br>\nmove.w    type,-(sp)   ; Offset 2<br>\nmove.w    #0,-(sp)     ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\nlea       12(sp),sp    ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 15),
(195, 'Logbase', '', '', '<span class=\"bold\">Nom :</span> »logical screen RAM base« - Retourne un pointeur vers l\'adresse de départ logique de la mémoire vidéo.<br>\n<span class=\"bold\">Opcode :</span> 3<br>\n<span class=\"bold\">Syntaxe : </span>void *Logbase(void);<br>\n<span class=\"bold\">Description : </span>La routine XBIOS Logbase obtient l\'adresse de départ logique de la région de RAM actuellement utilisée pour la mémoire vidéo.', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne l\'adresse de départ de la mémoire logique de l\'écran.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    #3,-(sp)     ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\naddq.l    #2,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 15),
(196, 'mon_type', '', '', '<span class=\"bold\">Nom :</span> »mon_type« - Identifie le type de moniteur.<br>\n<span class=\"bold\">Opcode :</span> 89<br>\n</span>int16_t mon_type(void);<br>\nDescription :</span> La fonction XBIOS mon_type identifie le type de moniteur connecté, en se basant sur les broches 18 (M1) et 19 (M0) du port vidéo. Un bit à 0 signifie une connexion à la masse à la broche correspondante, un bit à 1 signifie aucune connexion.<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne le type de moniteur connecté. Les valeurs suivantes s\'appliquent :', 'Valeur	Signification	Broche<br>\n0	Moniteur monochrome ST	M1:0 M0:0<br>\n1	Moniteur couleur ST	M1:0 M0:1<br>\n2	Moniteur VGA	M1:1 M0:0<br>\n3	Périphérique TV	M1:1 M0:1<br>\n4	Écran LCD	-<br>\n5	DVI	-<br>\nLes valeurs quatre et cinq sont uniquement disponibles avec ct60 et le pilote Radeon.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.w    #89,-(sp)    ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\naddq.l    #2,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 15),
(197, 'Physbase', '', '', '<span class=\"bold\">Nom : </span>»physical screen RAM base« - Retourne l\'adresse de départ physique de la mémoire vidéo.<br>\n<span class=\"bold\">Opcode :</span> 2<br>\n<span class=\"bold\">Syntaxe :</span> void *Physbase(void);<br>\n<span class=\"bold\">Description : </span>La routine XBIOS Physbase retourne l\'adresse de départ physique de la région de RAM actuellement utilisée pour la mémoire vidéo.', '<span class=\"bold\">Valeur de retour :</span> La fonction Physbase retourne l\'adresse de départ de la mémoire physique de l\'écran.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    #2,-(sp)     ; Offset 0<br>\ntrap      #14          ; Appel XBIOS<br>\naddq.l    #2,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 15),
(198, 'Setcolor', '', '', '<span class=\"bold\">Nom :</span> »Setcolor« - Définit une des 16 couleurs.<br>\n<span class=\"bold\">Opcode : </span>7<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Setcolor(int16_t colornum, int16_t color);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS Setcolor obtient la valeur d\'un registre de couleur ou le définit à une nouvelle valeur. Les paramètres suivants s\'appliquent :<br>\n<br>\nParamètre	Signification<br>\ncolornum	Numéro du registre de couleur (0..15)<br>\ncolor	Nouvelle valeur de couleur (-1 = ne pas modifier)', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne l\'ancienne valeur du registre de couleur.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de TOS.<br>\n<br>\n<span class=\"code\">move.w    color,-(sp)    ; Offset 4<br>\nmove.w    colornum,-(sp) ; Offset 2<br>\nmove.w    #7,-(sp)       ; Offset 0<br>\ntrap      #14            ; Appel XBIOS<br>\naddq.l    #6,sp          ; Correction</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 15),
(199, 'Setscreen, Milan', '', '', '<span class=\"bold\">Nom :</span> »set screen« - Initialise l\'écran.<br>\n<span class=\"bold\">Opcode : </span>5<br>\n<span class=\"bold\">Syntaxe :</span> void Setscreen(void *par1, void *par2, int16_t rez, int16_t command);<br>\n<span class=\"bold\">Description : </span>Cette routine XBIOS correspond à la fonction Setscreen avec des paramètres supplémentaires et sert à modifier la résolution de l\'écran et les adresses de mémoire écran.<br>\n<br>\nParamètre	Signification<br>\npar1	Selon la fonction - voir ci-dessous<br>\npar2	Selon la fonction - voir ci-dessous<br>\nrez	Toujours 0x4D49 (MI_MAGIC)<br>\ncommand	Commande<br>\nLes valeurs suivantes sont définies pour command :<br>\n<br>\n<span class=\"bold\">CMD_GETMODE (0) :</span> Obtient le mode actuel<br>\n<span class=\"code\">int32_t mode;<br>\nSetscreen(-1, &mode, MI_MAGIC, CMD_GETMODE);</span><br>\n<br>\n<span class=\"bold\">CMD_SETMODE (1) :</span> Définit un nouveau mode graphique<br>\n<span class=\"code\">int32_t mode = 0x1023; // 800x608x16<br>\nSetscreen(-1, mode, MI_MAGIC, CMD_SETMODE);</span><br>\nLe BIOS et le VDI seront initialisés. Pas l\'AES.<br>\n<br>\n<span class=\"bold\">CMD_GETINFO (2) : </span>Obtient la structure d\'information d\'écran pour le mode<br>\n<span class=\"code\">SCREENINFO si;<br>\n/* La taille de la structure doit être définie */<br>\nsi.size = sizeof(SCREENINFO);<br>\n/* ID du mode ou 0 pour le mode actuel */<br>\nsi.devID = 0x1023;<br>\n/* statut de l\'opération */<br>\nsi.scrFlags = 0;<br>\nSetscreen(-1, &si, MI_MAGIC, CMD_GETINFO);<br>\nif (si.scrFlags & SCRINFO_OK)<br>\n    puts(\"OK\");<br>\nelse<br>\n    puts(\"Error\");</span><br>\n<br>\n<span class=\"bold\">CMD_ALLOCPAGE (3) :</span> Alloue une 2e page d\'écran<br>\n<span class=\"code\">int32_t adr = 0; // Adresse de la trame ou -1<br>\nSetscreen(&adr, mode, MI_MAGIC, CMD_ALLOCPAGE);<br>\nif (adr)<br>\n    puts(\"OK\");<br>\nelse<br>\n    puts(\"Error\");</span><br>\nCette commande n\'alloue qu\'une page. Un nouvel appel ne retournera que l\'adresse de la trame.<br>\n<br>\n<span class=\"bold\">CMD_FREEPAGE (4) :</span> Libère la 2e page d\'écran<br>\n<span class=\"code\">Setscreen(-1, -1, MI_MAGIC, CMD_FREEPAGE);</span><br>\nLa mémoire de la carte graphique sera de nouveau libérée. Si la deuxième page était encore active, l\'appel reviendra à la première page avec Logbase et Physbase définis.<br>\n<br>\n<span class=\"bold\">CMD_FLIPPAGE (5) :</span> Bascule vers la 2e page d\'écran<br>\n<span class=\"code\">Setscreen(-1, -1, MI_MAGIC, CMD_FLIPPAGE);</span><br>\nPermet de basculer vers la deuxième page d\'écran. Logbase et Physbase seront définis.', '<span class=\"bold\">CMD_ALLOCMEM (6) :</span> Alloue de la mémoire sur la carte graphique<br>\n<span class=\"code\">SCRMEMBLK blk;<br>\n<br>\nblk.size = sizeof(SCRMEMBLK);<br>\n/* alloue un bloc de 200 lignes */<br>\nblk.blk_y = 200;<br>\n<br>\nSetscreen(-1, &blk, MI_MAGIC, CMD_ALLOCMEM);<br>\nif (blk.blk_start)<br>\n    puts(\"OK\");<br>\nelse<br>\n    puts(\"Out of memory\");</span><br>\nLa largeur du bloc est toujours la largeur de l\'écran virtuel. Pour les fonctions matérielles, ce bloc sera comme un écran (0,0,blk_w,blk_h), les coordonnées commencent en haut à gauche (0,0). Il sera recalculé en interne.<br>\n<br>\n<span class=\"bold\">CMD_FREEMEM (7) :</span> Libère la mémoire de la carte graphique<br>\n<span class=\"code\">Setscreen(-1, &blk, MI_MAGIC, CMD_FREEMEM);</span><br>\nLibère le bloc de mémoire spécifié.<br>\n<br>\n<span class=\"bold\">CMD_SETADR (8) :</span> Définit l\'écran à une adresse fixe<br>\n<span class=\"code\">/* adresse logique ou -1 */<br>\nint32_t logbase = blk.blk_start;<br>\n/* adresse physique ou -1 */<br>\nint32_t physbase = blk.blk_start;<br>\n<br>\nSetscreen(logbase, physbase, MI_MAGIC, CMD_SETADR);</span><br>\n<br>\n<span class=\"bold\">CMD_ENUMMODES (9) :</span> Demande tous les modes disponibles, depuis le 13.01.2000<br>\n<span class=\"code\">int32_t cdecl enumfunc(SCREENINFO *inf, int32_t flag)<br>\n{<br>\n    printf(\"%s\\n\", inf->name);<br>\n    return ENUMMODE_CONT;<br>\n}<br>\n<br>\nSetscreen(-1, &enumfunc, MI_MAGIC, CMD_ENUMMODES);</span><br>\nLa fonction \"enumfunc\" sera appelée une fois pour chaque mode disponible.<br>\n<br>\n<span class=\"bold\">ENUMMODE_EXIT (0)</span> annulera CMD_ENUMMODES. ENUMMODE_CONT (1) continuera. Les paramètres sont transmis à la pile en utilisant la norme C.<br>\n<br>\n<span class=\"bold\">CMD_TESTMODE (10) :</span> Cette fonction n\'existe que dans le ct60 avec le pilote interne TOS Radeon.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> Valeur de retour non définie.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible à partir de MilanTOS 4.08.<br>\n<br>\n<span class=\"code\">move.w    command,-(sp)    ; Offset 12<br>\nmove.w    rez,-(sp)        ; Offset 10<br>\nmove.l    par2,-(sp)       ; Offset  6<br>\nmove.l    par1,-(sp)       ; Offset  2<br>\nmove.w    #5,-(sp)         ; Offset  0<br>\ntrap      #14              ; Appel XBIOS<br>\nlea       $14(sp),sp       ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 15),
(200, 'Setscreen, ct60', '', '', '<span class=\"bold\">Nom :</span> »set screen« - Initialise l\'écran.<br>\n<span class=\"bold\">Opcode :</span> 5<br>\n<span class=\"bold\">Syntaxe : </span>void Setscreen(void *par1, void *par2, int16_t rez, int16_t command);<br>\n<span class=\"bold\">Description : </span>Cette routine XBIOS correspond à la fonction Setscreen avec des paramètres supplémentaires et sert à modifier la résolution de l\'écran et les adresses de mémoire écran.<br>\n<br>\nParamètre	Signification<br>\npar1	Selon la fonction - voir ci-dessous<br>\npar2	Selon la fonction - voir ci-dessous<br>\nrez	Toujours 0x564E (\'VN\' pour VsetScreen New)<br>\ncommand	Commande<br>\nLes valeurs suivantes sont définies pour command :<br>\n<br>\n<span class=\"bold\">CMD_GETMODE (0) :</span> Obtient le mode actuel<br>\n<span class=\"code\">int32_t mode;<br>\nSetscreen(-1, &mode, 0x564E, CMD_GETMODE);</span><br>\n<br>\n<span class=\"bold\">CMD_SETMODE (1) :</span> Définit un nouveau mode graphique<br>\n<span class=\"code\">int32_t mode = 0x1023; // 800x608x16<br>\nSetscreen(-1, mode, 0x564E, CMD_SETMODE);</span><br>\nCette fonction est identique à VsetScreen(0, 0, 3, modecode);<br>\nLe BIOS et le VDI seront initialisés. Pas l\'AES.<br>\n<br>\n<span class=\"bold\">CMD_GETINFO (2) :</span> Obtient la structure d\'information d\'écran pour le mode<br>\n<span class=\"code\">SCREENINFO si;<br>\n/* La taille de la structure doit être définie */<br>\nsi.size = sizeof(SCREENINFO);<br>\n/* ID du mode ou 0 pour le mode actuel */<br>\nsi.devID = 0x1023;<br>\n/* statut de l\'opération */<br>\nsi.scrFlags = 0;<br>\nSetscreen(-1, &si, 0x564E, CMD_GETINFO);<br>\nif (si.scrFlags & SCRINFO_OK)<br>\n    puts(\"OK\");<br>\nelse<br>\n    puts(\"Error\");</span><br>\n<br>\n<span class=\"bold\">CMD_ALLOCPAGE (3) :</span> Alloue une page d\'écran<br>\n<span class=\"code\">/* Adresse de la trame ou -1 */<br>\nint32_t adr = 0;<br>\nSetscreen(&adr, mode, 0x564E, CMD_ALLOCPAGE);<br>\nif (adr)<br>\n    puts(\"OK\");<br>\nelse<br>\n    puts(\"Error\");</span><br>\nCette commande n\'alloue qu\'une page. Un nouvel appel ne retournera que l\'adresse de la trame.<br>\n<br>\n<span class=\"bold\">CMD_FREEPAGE (4) :</span> Libère une page d\'écran<br>\n<span class=\"code\">Setscreen(-1, -1, 0x564E, CMD_FREEPAGE);</span><br>\nLa mémoire de la carte graphique sera de nouveau libérée. Si la deuxième page était encore active, l\'appel reviendra à la première page avec Logbase et Physbase définis.<br>\n<br>\n<span class=\"bold\">CMD_FLIPPAGE (5) :</span> Bascule vers la page d\'écran<br>\n<span class=\"code\">Setscreen(-1, -1, 0x564E, CMD_FLIPPAGE);</span><br>\nPermet de basculer vers la deuxième page d\'écran. Logbase et Physbase seront définis.<br>\n<br>\n<span class=\"bold\">CMD_ALLOCMEM (6) :</span> Alloue de la mémoire sur la carte graphique<br>\n<span class=\"code\">SCRMEMBLK blk;<br>\n<br>\nblk.size = sizeof(SCRMEMBLK);<br>\n/* alloue un bloc de 200 lignes */<br>\nblk.blk_y = 200;<br>\n<br>\nSetscreen(-1, &blk, 0x564E, CMD_ALLOCMEM);<br>\nif (blk.blk_start)<br>\n    puts(\"OK\");<br>\nelse<br>\n    puts(\"Out of memory\");</span><br>\nLa largeur du bloc est toujours la largeur de l\'écran virtuel. Pour les fonctions matérielles, ce bloc sera comme un écran (0,0,blk_w,blk_h), les coordonnées commencent en haut à gauche (0,0). Il sera recalculé en interne.<br>\n<br>\n<span class=\"bold\">CMD_FREEMEM (7) :</span> Libère la mémoire de la carte graphique<br>\n<span class=\"code\">Setscreen(-1, &blk, 0x564E, CMD_FREEMEM);</span><br>\nLibère le bloc de mémoire spécifié.<br>\n<br>\n<span class=\"bold\">CMD_SETADR (8) :</span> Définit l\'écran à une adresse fixe<br>\n<span class=\"code\">/* adresse logique ou -1 */<br>\nint32_t logbase = blk.blk_start;<br>\n/* adresse physique ou -1 */<br>\nint32_t physbase = blk.blk_start;<br>\n<br>\nSetscreen(logbase, physbase, 0x564E, CMD_SETADR);</span><br>\n<br>\n<span class=\"bold\">CMD_ENUMMODES (9) :</span> Demande tous les modes disponibles<br>\n<span class=\"code\">int32_t cdecl enumfunc(SCREENINFO *inf, int32_t flag)<br>\n{<br>\n    printf(\"%s\\n\", inf->name);<br>\n    return ENUMMODE_CONT;<br>\n}<br>\n<br>\nSetscreen(-1, &enumfunc, 0x564E, CMD_ENUMMODES);</span><br>\nLa fonction \"enumfunc\" sera appelée une fois pour chaque mode disponible. <br>\n<br>\n<span class=\"bold\">ENUMMODE_EXIT (0)</span> annulera CMD_ENUMMODES. ENUMMODE_CONT (1) continuera. Les paramètres sont transmis à la pile en utilisant la norme C.<br>\n<br>\n<span class=\"bold\">CMD_TESTMODE (10) :</span> Teste un mode graphique<br>\n<span class=\"code\">/* 800x600x16M */<br>\nint32_t modecode = VESA_600 + HORFLAG2 + VGA + COL80 + BPS32;<br>\nSetscreen(-1, modecode, 0x564E, CMD_TESTMODE);</span><br>\nSeul le BIOS est initialisé, et un test d\'écran est réalisé avec de larges lignes colorées. Cette fonction n\'existe pas dans MilanTOS.', '<span class=\"bold\">CMD_COPYPAGE (11) : </span>Copie une page d\'écran<br>\n<span class=\"code\">VsetScreen(-1, 0, 0x564E, CMD_COPYPAGE); // Copie la première page sur la deuxième<br>\nVsetScreen(-1, 1, 0x564E, CMD_COPYPAGE); // Copie la deuxième page sur la première</span><br>\nCette fonction n\'existe pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_FILLMEM (12) :</span> Remplit la mémoire sur la carte graphique<br>\n<span class=\"code\">SCRFILLMEMBLK blk;<br>\nblk.size = sizeof(SCRFILLMEMBLK);<br>\nblk.blk_op = BLK_COPY;<br>\nblk.blk_color = 0x112233;  /* couleur de remplissage */<br>\n<br>\nVsetScreen(-1, &blk, 0x564E, CMD_SETMEM);<br>\nif (blk.blk_status == BLK_OK)<br>\n    puts(\"OK\");</span><br>\nRemplit un bloc avec une couleur avec le GPU à (blk_x, blk_y), taille blk_w, blk_h. Cette structure a la même taille et les mêmes entrées que SCRMEMBLK pour les entrées size, blk_status, blk_x, blk_y, blk_w et blk_h, permettant l\'utilisation de la structure allouée avec un cast. Cette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_COPYMEM (13) :</span> Copie de la mémoire sur la carte graphique<br>\n<span class=\"code\">SCRCOPYMEMBLK blk;<br>\nblk.size = sizeof(SCRCOPYMEMBLK);<br>\n<br>\nVsetScreen(-1, &blk, 0x564E, CMD_COPYMEM);<br>\nif (blk.blk_status == BLK_OK)<br>\n    puts(\"OK\");</span><br>\nCopie un bloc avec le GPU de (blk_src_x, blk_src_y) à (blk_dst_x, blk_dst_y), taille blk_w, blk_h. Cette structure a la même taille et les mêmes entrées que SCRMEMBLK pour les entrées size, blk_status, blk_x, blk_y, blk_w et blk_h, permettant l\'utilisation de la structure allouée avec un cast lorsque blk_x est blk_dst_x et blk_y est blk_dst_y. Cette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_TEXTUREMEM (14) :</span> Met une texture en mémoire sur la carte graphique<br>\n<span class=\"code\">SCRTEXTUREMEMBLK blk;<br>\nblk.size = sizeof(SCRTEXTUREMEMBLK);<br>\n<br>\nVsetScreen(-1, &blk, 0x564E, CMD_TEXTUREMEM);<br>\nif (blk.blk_status == BLK_OK)<br>\n    puts(\"OK\");</span><br>\nCopie une texture de 65K de la zone locale du CPU vers un écran de 65K ou une texture ARGB vers un format de pixel d\'écran de 32M plusieurs fois (meilleurs résultats avec une petite texture source et un grand écran pour la destination). Cette fonction nécessite un support de texture dans le TOS. Cette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_GETVERSION (15) : </span>Obtient la version du XBIOS vidéo<br>\n<span class=\"code\">/* si la fonction n\'est pas implémentée, 0x0100 est la première version */<br>\nlong version = 0x0100;<br>\nVsetScreen(-1, &version, 0x564E, CMD_GETVERSION);</span><br>\nRenvoie la version du XBIOS vidéo. Cette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_LINEMEM (16) :</span> Dessine une ligne sur la carte graphique<br>\n<span class=\"code\">SCRLINEMEMBLK blk;<br>\nblk.size = sizeof(SCRLINEMEMBLK);<br>\nblk.blk_fbcolor = 0x112233;  /* couleur de remplissage au premier plan */<br>\nblk.blk_bgcolor = 0;  /* couleur de remplissage en arrière-plan */<br>\nblk.blk_pattern = 0xffffffff;  /* ligne pleine */<br>\n<br>\nVsetScreen(-1, &blk, 0x564E, CMD_LINEMEM);<br>\nif (blk.blk_status == BLK_OK)<br>\n    puts(\"OK\");</span><br>\nDessine une ligne avec des couleurs avec le GPU de (blk_x1, blk_y1) à (blk_x2, blk_y2). Cette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_CLIPMEM (17) :</span> Définit le rectangle de découpe sur la carte graphique<br>\n<span class=\"code\">SCRCLIPMEMBLK blk;<br>\nblk.size = sizeof(SCRCLIPMEMBLK);<br>\nblk.blk_clip_on = 1; /* flag de découpe 1: activé, 0: désactivé */<br>\n<br>\nVsetScreen(-1, &blk, 0x564E, CMD_CLIPMEM);<br>\nif (blk.blk_status == BLK_OK)<br>\n    puts(\"OK\");</span><br>\nActive ou désactive le rectangle de découpe à (blk_x, blk_y), taille blk_w, blk_h. Cette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_SYNCMEM (18) :</span> Attend un FIFO GPU vide pour synchroniser le moteur de dessin avec la mémoire<br>\n<span class=\"code\">VsetScreen(-1, -1, 0x564E, CMD_SYNCMEM);</span><br>\nCette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">CMD_BLANK (19) :</span> Éteint / rallume l\'écran<br>\n<span class=\"code\">int32_t blank = 1; /* (0): rallumer<br>\n                      (1): éteindre normalement<br>\n                      (2): suspendre VSYNC<br>\n                      (3): suspendre HSYNC<br>\n                      (4): mise en veille */<br>\nVsetScreen(-1, blank, 0x564E, CMD_BLANK);</span><br>\nCette fonction existe depuis la version 0x0101 du XBIOS vidéo et n\'est pas dans MilanTOS.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> Rien (ou code du mode actuel en mode TOS)<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Valide uniquement avec le pilote TOS interne Radeon (PCI.HEX) pour le ct60 (24-01-2007).<br>\n', '', NULL, NULL, NULL, '', '', '', 4, 3, 15),
(201, 'ValidMode', '', '', '<span class=\"bold\">Nom :</span> »ValidMode« - Valide un code de mode.<br>\n<span class=\"bold\">Opcode :</span> 95<br>\n<span class=\"bold\">Syntaxe :</span> int16_t ValidMode(int16_t mode);<br>\n<span class=\"bold\">Description : </span>La fonction XBIOS ValidMode renvoie une version valide du code de mode spécifié, en fonction du moniteur connecté. Les bits du paramètre mode ont la signification suivante :<br>\n<br>\nBit	Signification<br>\n0-2	Nombre de plans de couleur :<br>\n     * 0 = 1 plan 2 couleurs.<br>\n     * 1 = 2 plans 4 couleurs.<br>\n     * 2 = 4 plans 16 couleurs.<br>\n     * 3 = 8 plans 256 couleurs.<br>\n     * 4 = 16 plans 65536 couleurs.<br>\n3  Défini : largeur de l\'image au moins 640 pixels (80 colonnes)<br>\n         Désactivé : largeur de l\'image 320 pixels (40 colonnes)<br>\n4     Défini : mode VGA<br>Désactivé : mode TV (également moniteurs Atari SC)<br>\n5     Défini : mode PAL<br>Désactivé : mode NTSC<br>\n6     Défini : overscan actif (non valide pour VGA)<br>\n7     Défini : Graphismes compatibles ST<br>\n8     Défini : mode entrelacé (sur moniteur couleur) ou mode double ligne (sur moniteur VGA) actif', '<div class=\"border-yellow\"><p>Note : Cette fonction n\'est pas officiellement documentée et certains outils de développement peuvent également l\'appeler Validmode ou VcheckMode.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction renvoie un code de mode valide.</p></div><br>\n<br>\n<span class=\"bold\">Disponibilité : </span>La fonction est disponible uniquement sur les ordinateurs des séries Falcon, Milan et CT60.<br>\n<br>\n<span class=\"code\">move.w  mode,-(sp)   ; Offset 2<br>\nmove.w  #95,-(sp)    ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\naddq.l  #4,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(202, 'VgetRGB', '', '', '<span class=\"bold\">Nom :</span> »VgetRGB« - Obtient les valeurs RGB d\'une palette de couleurs.<br>\n<span class=\"bold\">Opcode :</span> 94<br>\n<span class=\"bold\">Syntaxe :</span> void VgetRGB(int16_t index, int16_t count, int32_t *array);<br>\n<span class=\"bold\">Description :</span> La fonction XBIOS VgetRGB obtient les valeurs RGB pour un nombre donné de couleurs à partir de l\'index de couleur spécifié. Les valeurs résultantes sont stockées dans array.<br>\n<br>\n<div class=\"border-yellow\"><p>Note : Il ne faut pas essayer de sauvegarder plus de couleurs que ce que le mode vidéo supporte.</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction ne renvoie pas de résultat.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.l  array,-(sp)  ; Offset 6<br>\nmove.w  count,-(sp)  ; Offset 4<br>\nmove.w  index,-(sp)  ; Offset 2<br>\nmove.w  #94,-(sp)    ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\nlea     $A(sp),sp    ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(203, 'VsetScreen', '', '', '<span class=\"bold\">Nom : </span>»VsetScreen« - Initialise l\'écran.<br>\n<span class=\"bold\">Opcode :</span> 5<br>\n<span class=\"bold\">Syntaxe :</span> void VsetScreen(void *laddr, void *paddr, int16_t rez, int16_t mode);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS VsetScreen correspond à la fonction Setscreen avec un paramètre supplémentaire et sert à modifier la résolution actuelle de l\'écran et les adresses de mémoire écran.<br>\n<br>\nParamètre	Signification<br>\nladdr	Adresse de la mémoire écran logique<br>\npaddr	Adresse de la mémoire écran physique<br>\nrez	0 = ST Low<br>\n1 = ST Medium<br>\n2 = ST High<br>\n3 = Résolution utilisée, depuis le mode<br>\nmode	code du mode (voir VsetMode)<br>\nUne valeur de -1 signifie que l\'adresse ou la résolution correspondante ne sera pas modifiée.', '<div class=\"border-yellow\"><p>Note : Il est toujours conseillé de vérifier si les modifications ont été effectivement effectuées. Lors des changements de résolution, l\'émulateur VT52 est automatiquement initialisé.</p></div><br>\nLe paramètre supplémentaire mode est uniquement disponible si le cookie \'_VDO\' a une valeur de 0x00030000 ou plus.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction ne renvoie pas de résultat.<br>\n<span class=\"bold\">Disponibilité : </span>La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.w  mode,-(sp)   ; Offset 12<br>\nmove.w  rez,-(sp)    ; Offset 10<br>\nmove.l  paddr,-(sp)  ; Offset 6<br>\nmove.l  laddr,-(sp)  ; Offset 2<br>\nmove.w  #5,-(sp)     ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\nlea     14(sp),sp    ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(204, 'VgetSize', '', '', '<span class=\"bold\">Nom : </span>»VgetSize« - Renvoie la taille du tampon d\'écran.<br>\n<span class=\"bold\">Opcode : </span>91<br>\n<span class=\"bold\">Syntaxe :</span> int32_t VgetSize(int16_t mode);<br>\n<span class=\"bold\">Description :</span> La fonction XBIOS VgetSize renvoie la taille du tampon d\'écran en octets pour le mode graphique spécifié.<br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction renvoie la taille du tampon d\'écran en octets.<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.w  mode,-(sp)   ; Offset 2<br>\nmove.w  #91,-(sp)    ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\naddq.l  #4,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(205, 'VsetMask', '', '', '<span class=\"bold\">Nom : </span>»VsetMask« - Définit la transparence pour le mode TrueColor.<br>\n<span class=\"bold\">Opcode :</span> 150<br>\n<span class=\"bold\">Syntaxe :</span> void VsetMask(int32_t ormask, int32_t andmask, int16_t overlay);<br>\n<span class=\"bold\">Description :</span> La fonction XBIOS VsetMask définit des masques utilisés pour modifier les couleurs définies par la fonction VDI vs_color. vs_color obtient pour son paramètre une valeur RGB. Celle-ci est ORd bit à bit avec ormask et ANDed avec andmask. Ainsi, les couleurs peuvent apparaître comme transparentes en mode TrueColor. Si overlay est non nul, on passe en mode superposition, sinon on en sort.', '<span class=\"bold\">Valeur de retour :</span> La fonction ne renvoie pas de résultat.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.w  overlay,-(sp) ; Offset 10<br>\nmove.l  andmask,-(sp) ; Offset 6<br>\nmove.l  ormask,-(sp)  ; Offset 2<br>\nmove.w  #150,-(sp)    ; Offset 0<br>\ntrap    #14           ; Appel XBIOS<br>\nlea     12(sp),sp     ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(206, 'VsetMode', '', '', '<span class=\"bold\">Nom :</span> »VsetMode« - Définit les registres matériels vidéo.<br>\n<span class=\"bold\">Opcode : </span>88<br>\n<span class=\"bold\">Syntaxe :</span> int16_t VsetMode(int16_t mode);<br>\n<span class=\"bold\">Description :</span> La fonction XBIOS VsetMode programme le registre matériel vidéo de l\'ordinateur Falcon. Les bits du paramètre mode ont la signification suivante :<br>\n<br>\nBit	Signification<br>\n0-2	Nombre de plans de couleur :<br>\n     * 0 = 1 plan 2 couleurs<br>\n     * 1 = 2 plans 4 couleurs<br>\n     * 2 = 4 plans 16 couleurs<br>\n     * 3 = 8 plans 256 couleurs<br>\n     * 4 = 16 plans 65536 couleurs<br>\n3	Défini : largeur de l\'image au moins 640 pixels (80 colonnes)<br>\n               Désactivé : largeur de l\'image 320 pixels (40 colonnes)<br>\n4	Défini : mode VGA<br>Désactivé : mode TV (également moniteurs Atari SC)<br>\n5	Défini : mode PAL<br>Désactivé : mode NTSC<br>\n6	Défini : overscan actif (non valide pour VGA)<br>\n7	Défini : Graphismes compatibles ST<br>\n8	Défini : mode entrelacé (sur moniteur couleur) ou mode double ligne (sur moniteur VGA) actif<br>\n<br>\nSi VM_INQUIRE (-1) est passé comme mode, on obtient la résolution actuelle sans rien changer.<br>\n', '<div class=\"border-yellow\"><p>Note : Il n\'y a pas de vérification de la correction du codage pour le moniteur connecté.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction renvoie le contenu ancien du registre matériel vidéo.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.w  mode,-(sp)   ; Offset 2<br>\nmove.w  #88,-(sp)    ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\naddq.l  #4,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(207, 'VsetRGB', '', '', '<span class=\"bold\">Nom :</span> »VsetRGB« - Définit la valeur RGB d\'une couleur.<br>\n<span class=\"bold\">Opcode : </span>93<br>\n<span class=\"bold\">Syntaxe :</span> void VsetRGB(int16_t index, int16_t count, int32_t *array);<br>\n<span class=\"bold\">Description :</span> La fonction XBIOS VsetRGB définit les valeurs RGB pour les entrées de palette count à partir de l\'index de palette index. Les valeurs de couleur sont stockées dans array.<br>\n<br>\n<div class=\"border-yellow\"><p>Note : Il ne faut pas essayer de restaurer plus de couleurs que ce que le mode vidéo supporte.</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction ne renvoie pas de résultat.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.l  array,-(sp)  ; Offset 6<br>\nmove.w  count,-(sp)  ; Offset 4<br>\nmove.w  index,-(sp)  ; Offset 2<br>\nmove.w  #93,-(sp)    ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\nlea     $A(sp),sp    ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(208, 'VsetSync', '', '', '<span class=\"bold\">Nom :</span> »VsetSync« - Définit le type de synchronisation externe.<br>\n<span class=\"bold\">Opcode : </span>90<br>\n<span class=\"bold\">Syntaxe : </span>void VsetSync(int16_t flag);<br>\n<span class=\"bold\">Description :</span> La fonction XBIOS VsetSync détermine comment le vidéo doit être synchronisé. Le paramètre flag est codé comme suit :<br>\n<br>\nBit	Signification pour les bits définis<br>\n0	Utiliser l\'horloge externe<br>\n1	Utiliser la synchronisation verticale externe<br>\n2	Utiliser la synchronisation horizontale externe<br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction ne renvoie pas de résultat.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> La fonction est disponible uniquement sur les ordinateurs de la série Falcon.<br>\n<br>\n<span class=\"code\">move.w  flag,-(sp)   ; Offset 2<br>\nmove.w  #90,-(sp)    ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\naddq.l  #4,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(209, 'Vsync', '', '', '<span class=\"bold\">Nom :</span> »Vsync« - Attendre la prochaine synchronisation verticale.<br>\n<span class=\"bold\">Opcode : </span>37<br>\n<span class=\"bold\">Syntaxe : </span>void Vsync(void);<br>\n<span class=\"bold\">Description :</span> La routine XBIOS Vsync suspend l\'exécution du programme jusqu\'à la prochaine actualisation de l\'écran (interruption de vide vertical). Cela permet de synchroniser les opérations d\'écran avec le système d\'exploitation.<br>\n<br>\n<div class=\"border-yellow\"><p>Note : Pour les opérations critiques en temps (défilement), il est préférable d\'utiliser directement le compteur de lignes dans le Shifter.</p></div><br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction ne renvoie pas de résultat.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions TOS.<br>\n<br>\n<span class=\"code\">move.w  #37,-(sp)    ; Offset 0<br>\ntrap    #14          ; Appel XBIOS<br>\naddq.l  #2,sp        ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 15),
(210, '', '', '', '', '', 'Fonctions de fichier (<span class=\"bold\">F</span>...)<br>\nDate et heure (<span class=\"bold\">T</span>...)<br>\nFonctions de processus (<span class=\"bold\">P</span>...)<br>\nGestion de la mémoire (<span class=\"bold\">M</span>...)<br>\nFonctions système (<span class=\"bold\">S</span>...)<br>\nFonctions de répertoire (<span class=\"bold\">D</span>...)<br>\nEntrée/sortie de caractères (<span class=\"bold\">C</span>...)<br>\nRéseau (<span class=\"bold\">F</span>...)<br>\nSous <span class=\"bold\">MagiC</span>, le <span class=\"bold\">GEMDOS</span> est réentrant <span class=\"italic\">(à partir de MagiC 3.0, cela s\'applique même au système de fichiers!)</span>. Cela se remarque, par exemple, par des boîtes d\'alerte de type <span class=\"bold\">\"Les données sur le lecteur A: peuvent être endommagées\"</span> qui sont déplaçables - car la mémoire doit être allouée pour cela, ce qui ne fonctionne pas sous <span class=\"italic\">(Multi)</span><span class=\"bold\">TOS</span>, car une opération de fichier dans <span class=\"bold\">GEMDOS</span> est en cours de traitement en même temps.<br>\n<br>\nAvec l\'apparition de <span class=\"bold\">MiNT</span>, le <span class=\"bold\">GEMDOS</span> a été étendu par de nombreuses fonctions. De même, <span class=\"bold\">MagiC</span> à partir de la version 3.0 possède certaines fonctions compatibles avec <span class=\"bold\">MiNT</span>, et des pilotes <span class=\"bold\">MetaDOS</span> avec des fonctionnalités correspondantes ont été repérés.<br>\n<br>\nLe <span class=\"bold\">GEMDOS</span> reçoit ses paramètres sur la pile; pour cela, le dernier argument de la liste de paramètres est stocké en premier sur la pile. Les résultats des fonctions sont retournés dans le registre de processeur d0. Seuls les registres d3-d7 et a3-a7 sont sauvegardés, tous les autres seront modifiés par l\'appel.', NULL, NULL, NULL, '', '', '', 1, 4, 16),
(211, 'Fattrib', '', '', '<span class=\"bold\">Nom : </span>« Attributs de fichier » - Lire ou modifier les attributs de fichier.<br>\n<span class=\"bold\">Opcode : </span>67<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Fattrib ( const int8_t *filename, int16_t wflag, int16_t attrib );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fattrib lit ou définit les attributs d\'un fichier GEMDOS.<br>\n<br>\nParamètre	Signification<br>\nfilename	Nom du fichier concerné<br>\nwflag	0 = Lire les attributs<br>\n                1 = Définir les attributs<br>\nattrib	Drapeaux d\'attributs de fichier :<br>\n                Bit 0 : Fichier protégé en écriture<br>\n                Bit 1 : Fichier caché<br>\n                Bit 2 : Fichier système<br>\n                Bit 3 : Étiquette de volume (nom de disquette)<br>\n                Bit 4 : Répertoire<br>\n                Bit 5 : Bit d\'archive', '<div class=\"border-yellow\"><p>Note : Si possible, les programmes devraient utiliser les routines Fxattr et Fchmod, car elles sont plus efficaces que Fattrib.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">EACCDN :</span> Accès refusé.<br>\n<span class=\"bold\">EFILNF :</span> Fichier non trouvé.<br>\n<span class=\"bold\">EPTHNF :</span> Répertoire non trouvé.<br>\n<br>\n<span class=\"bold\">Autrement :</span> Les attributs actuels du fichier.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    attrib,-(sp) ; Offset 8<br>\nmove.w    wflag,-(sp)  ; Offset 6<br>\npea       filename     ; Offset 2<br>\nmove.w    #67,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\nlea       $A(sp),sp    ; correct stack</span><br>\n<br>\nGFA-Basic :<br>\n<span class=\"code\">Fehler%=Gemdos(&H43,L:filename%,W:wflag%,W:attrib%)</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 16),
(212, 'Fchdir', '', '', '<span class=\"bold\">Nom :</span> « Définir le répertoire » - Définir le répertoire courant à partir d\'un descripteur de fichier.<br>\n<span class=\"bold\">Opcode :</span> 385<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fchdir ( int16_t handle );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fchdir définit le répertoire courant pour le processus en cours à partir d\'un répertoire avec l\'ID handle.<br>\n', '<span class=\"bold\">Valeur de retour :</span> Retourne E_OK en cas de succès ou un code d\'erreur GEMDOS négatif sinon.<br>\n<span class=\"bold\">Disponibilité :</span> Disponible à partir de la version 1.17 de FreeMiNT.<br>\n<br>\n<span class=\"code\">move.w    handle,-(sp) ; Offset 2<br>\nmove.w    #385,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #4,sp        ; Correct stack</span><br>\n<br>\nGFA-Basic :<br>\n<span class=\"code\">Error%=Gemdos(&H181,W:handle%)</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 16),
(213, 'Fchmod', '', '', '<span class=\"bold\">Nom :</span> « Fchmod » - Définir les permissions d\'accès au fichier.<br>\n<span class=\"bold\">Opcode :</span> 306<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fchmod ( int8_t *name, int16_t mode );<br>\n<span class=\"bold\">Description :</span> La fonction modifie les droits d\'accès pour le fichier GEMDOS nommé. Le paramètre mode contient les nouveaux droits d\'accès :<br>\n<br>\nAccès par	mode	Signification<br>\nPropriétaire	0400	Permission de lecture<br>\ndu fichier	0200	Permission d\'écriture<br>\n                        0100	Permission d\'exécution<br>\nGroupe du	0040	Permission de lecture<br>\nfichier	        0020	Permission d\'écriture<br>\n                        0010	Permission d\'exécution<br>\nTous les	        0004	Permission de lecture<br>\nautres	        0002	Permission d\'écriture<br>\nutilisateurs	0001	Permission d\'exécution<br>\nPour les fichiers exécutables, les éléments suivants s\'appliquent :<br>\n<br>\nmode	Signification<br>\n04000	Définit l\'UID effectif du processus à l\'UID de celui qui exécute ce processus<br>\n02000	Définit le GID effectif du processus au GID de celui qui exécute ce processus<br>\n01000	Le fichier est un répertoire.<br>\n???? 	Le fichier est un programme de texte partagé. Le programme n\'est pas retiré de la mémoire après son exécution et n\'a donc pas besoin d\'être rechargé pour une utilisation répétée.', '<div class=\"border-yellow\"><p><span class=\"bold\">Note : </span>Tous les systèmes de fichiers n\'ont pas besoin de supporter toutes les options. Les droits d\'accès non pris en charge sont alors ignorés. Les droits d\'exécution pour un répertoire signifient que l\'on peut rechercher dans ce répertoire un nom ou un composant de nom.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour : </span>La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucun erreur n\'est survenue<br>\n<span class=\"bold\">EFILNF :</span> Fichier non trouvé<br>\n<span class=\"bold\">EPTHNF :</span> Chemin vers le fichier non trouvé<br>\n<span class=\"bold\">EACCDN : </span>L\'EUID du processus appelant diffère de l\'UID du propriétaire du fichier et n\'est pas non plus celui du noyau (0)<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsqu\'un cookie \'MiNT\' avec une version d\'au moins 0.90 existe.<br>\n<br>\n<span class=\"code\">move.w    mode,-(sp)   ; Offset 6<br>\npea       name         ; Offset 2<br>\nmove.w    #306,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; correct stack</span><br>\n', '', NULL, NULL, NULL, '', '', '', 1, 3, 16),
(214, 'Fchown', '', '', '<span class=\"bold\">Nom :</span> « Fchown » - Modifier l\'ID propriétaire/groupe.<br>\n<span class=\"bold\">Opcode :</span> 305<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fchown ( int8_t *name, int16_t uid, int16_t gid );<br>\n<span class=\"bold\">Description : </span>La fonction modifie l\'ID utilisateur/groupe du nom de fichier, qui contrôle les droits d\'accès du fichier.<br>\n<br>\n<div class=\"border-yellow\"><p>Cet appel ne peut être émis que par un processus ayant un identifiant d\'utilisateur effectif (EUID) de 0, ou correspondant à l\'UID du fichier ; dans ce dernier cas, le nouvel UID doit correspondre à l\'ancien, et en plus, le processus appelant doit être membre du groupe avec le numéro de groupe GID.</p></div><br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucun erreur n\'est survenue<br>\n<span class=\"bold\">EINVFN : </span>Le système de fichiers ne supporte pas le concept d\'ID utilisateur/groupe (exemple TOS-FS)<br>\n<span class=\"bold\">EACCDN : </span>L\'EUID du processus appelant diffère de l\'UID du propriétaire du fichier et n\'est également pas zéro<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Disponible lorsqu\'un cookie \'MiNT\' avec une version d\'au moins 0.90 existe.<br>\n<br>\n<span class=\"code\">move.w    gid,-(sp)    ; Offset 8<br>\nmove.w    uid,-(sp)    ; Offset 6<br>\npea       name         ; Offset 2<br>\nmove.w    #305,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\nlea       $A(sp),sp    ; Correct stack</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 16),
(215, 'Fchown16', '', '', '<span class=\"bold\">Nom :</span> « Fchown16 » - Modifier l\'ID propriétaire/groupe.<br>\n<span class=\"bold\">Opcode :</span> 384<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fchown16 ( int8_t *name, int16_t uid, int16_t gid, int16_t flag );<br>\n<span class=\"bold\">Description :</span> La fonction modifie l\'ID utilisateur/groupe du nom de fichier, qui contrôle les droits d\'accès du fichier.<br>\n<br>\nLe paramètre flag spécifie comment les liens symboliques doivent être traités. Les éléments suivants s\'appliquent :<br>\n<br>\nflag	Signification<br>\n0	La propriété du lien symbolique lui-même est modifiée. Cela équivaut à appeler Fchown(name, uid, gid).<br>\n1	Les liens symboliques sont suivis jusqu\'au fichier source et la propriété de ce fichier est modifiée.<br>\n<br>\n<div class=\"border-yellow\"><p>Cet appel ne peut être émis que par un processus ayant un identifiant d\'utilisateur effectif (EUID) de 0, ou correspondant à l\'UID du fichier ; dans ce dernier cas, le nouvel UID doit correspondre à l\'ancien, et en plus, le processus appelant doit être membre du groupe avec le numéro de groupe GID.</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK : </span>Aucun erreur n\'est survenue<br>\n<span class=\"bold\">EINVFN :</span> Le système de fichiers ne supporte pas le concept d\'ID utilisateur/groupe (exemple TOS-FS)<br>\n<span class=\"bold\">EACCDN :</span> L\'EUID du processus appelant diffère de l\'UID du propriétaire du fichier et n\'est également pas zéro<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsqu\'un cookie \'MiNT\' avec une version d\'au moins 1.16.0 existe.<br>\n<br>\n<span class=\"code\">move.w    flag,-(sp)   ; Offset 10<br>\nmove.w    gid,-(sp)    ; Offset 8<br>\nmove.w    uid,-(sp)    ; Offset 6<br>\npea       name         ; Offset 2<br>\nmove.w    #384,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\nlea       12(sp),sp    ; Correct stack</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 16),
(216, 'Fclose', '', '', '<span class=\"bold\">Nom :</span> « Fermer le fichier » - Fermer un fichier spécifié.<br>\n<span class=\"bold\">Opcode :</span> 62<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Fclose ( int16_t handle );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fclose ferme un fichier avec l\'ID de fichier handle.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Note :</span> Dans un réseau, le verrouillage actif est levé. Lors de la fermeture des canaux standard, à partir de la version 0.15 de GEMDOS, le canal d\'origine sera rétabli.</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucun erreur n\'est survenue<br>\n<span class=\"bold\">EBADF :</span> Mauvais ID de fichier<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    handle,-(sp)  ; Offset 2<br>\nmove.w    #62,-(sp)     ; Offset 0<br>\ntrap      #1            ; GEMDOS<br>\naddq.l    #4,sp         ; Correct stack</span><br>\n<br>\nGFA-Basic :<br>\n<span class=\"code\">Fehler%=Gemdos(&H3E,W:handle%)</span><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n', '', NULL, NULL, NULL, '', '', '', 1, 3, 16);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(217, 'Fcntl', '', '', '<span class=\"bold\">Nom :</span> »Fcntl« - Effectuer des opérations de commande sur un fichier donné.<br>\n<span class=\"bold\">Opcode :</span> 260<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fcntl(int16_t fh, int32_t arg, int16_t cmd);<br>\n<span class=\"bold\">Description :</span> Cette fonction effectue diverses opérations de commande sur le fichier avec le descripteur fh. Le paramètre cmd décrit l\'opération souhaitée et peut prendre les valeurs suivantes (le paramètre arg dépend de la commande sélectionnée) :<br>\n<br>\n<span class=\"bold\">F_DUPFD (0) :</span><br>\nDuplique le descripteur de fichier spécifié. Le nouveau descripteur sera dans l\'intervalle arg <= Handle < 32. Si aucun descripteur libre n\'existe dans le segment spécifié, le message d\'erreur ENHNDL sera renvoyé. Un appel à Fdup(handle) équivaut à Fcntl(handle, 6L, F_DUPFD).<br>\n<br>\n<span class=\"bold\">F_GETFD (1) :</span><br>\nCette commande renvoie le drapeau de non-héritage pour le descripteur fh. Le drapeau vaut 0 si les processus enfants démarrés avec Pexec doivent hériter du descripteur de fichier, sinon il vaut 1. Le paramètre arg est ignoré.<br>\n<br>\n<span class=\"bold\">F_SETFD (2) :</span><br>\nCette commande définit le drapeau de non-héritage pour le descripteur fh. arg spécifie si les processus enfants démarrés avec Pexec hériteront du descripteur de fichier ; une valeur de 1 indique qu\'ils ne le feront pas, une valeur de 0 qu\'ils le feront. La valeur par défaut pour le drapeau est 0 pour les descripteurs GEMDOS standards (dans la plage 0...5) et 1 pour tous les autres descripteurs.<br>\n<br>\n<span class=\"bold\">F_GETFL (3) :</span><br>\nCette commande renvoie les drapeaux du descripteur de fichier qui peuvent être modifiés par l\'utilisateur. Il s\'agit du paramètre mode spécifié lors de l\'appel à Fopen, tant qu\'il n\'a pas été modifié par un autre appel à Fcntl. arg est ignoré.<br>\n<br>\n<span class=\"bold\">F_SETFL (4) :</span><br>\nCette commande définit les drapeaux du descripteur de fichier qui peuvent être modifiés par l\'utilisateur à arg (les autres bits sont ignorés et doivent être mis à la valeur 0). Il n\'est pas possible de modifier le mode de lecture/écriture ou les modes de partage de fichier.<br>\n<br>\n<span class=\"bold\">F_GETLK (5) :</span><br>\nLe paramètre arg est un pointeur vers une structure flock, dans laquelle les informations sur les verrous de fichier sont stockées. Si un verrou existe, il sera copié dans la structure. Dans ce cas, l\'élément l_pid contiendra le PID du processus verrouillant. Si aucun verrou n\'existe, l\'élément l_type sera défini à la valeur F_UNLCK. Si le verrou est détenu par un autre ordinateur dans un réseau, l\'élément l_pid est défini à une valeur spécifiée par le NFS (Network File System). Pour cette valeur, 0x1000 <= l_pid <= 0xffff. À noter que les PID normaux ont une valeur inférieure à 1000.<br>\n<br>\n<span class=\"bold\">F_SETLK (6) :</span><br>\nCette commande définit (l_type = F_RDLCK ou F_WRLCK) ou lève (l_type = F_UNLCK) un verrou consultatif sur le fichier spécifié. Si c\'est une file FIFO (First-In-First-Out), tout le fichier doit être traité en même temps. Si le verrou entre en conflit avec les verrous définis par d\'autres processus, la valeur ELOCKED sera renvoyée. Si l\'on essaie de lever un verrou inexistant, la valeur ENSLOCK sera renvoyée. À noter que les verrous de lecture peuvent se chevaucher, mais pas les verrous d\'écriture. Si un fichier verrouillé est fermé ou si le processus correspondant se termine, tous les verrous définis seront levés automatiquement (i.e. réinitialisés).<br>\n<br>\n<span class=\"bold\">F_SETLKW (7) :</span><br>\nSemblable à F_SETLK, avec la différence que si le verrou entre en conflit avec ceux d\'autres processus, ELOCKED n\'est pas renvoyé mais le processus verrouillé est suspendu jusqu\'à ce que le verrou des autres processus soit levé.<br>\n<br>\n<span class=\"bold\">FSTAT (0x4600) :</span><br>\nObtient les attributs étendus d\'un fichier. Le paramètre arg renvoie un pointeur vers une structure XATTR remplie avec les attributs étendus du fichier, comme si un appel Fxattr avait été fait. Cette commande est prise en charge dans MagiC à partir de la version 3.0.<br>\n<br>\n<span class=\"bold\">FIONREAD (0x4601) :</span><br>\nLe paramètre arg renvoie un pointeur vers une valeur LONG qui indique le nombre d\'octets pouvant être lus actuellement à partir du descripteur de fichier spécifié sans bloquer le processus (attendre plus d\'entrée). La valeur renvoyée n\'est pas nécessairement correcte, car la quantité exacte ne peut être estimée que dans certains cas. La commande est prise en charge dans MagiC à partir de la version 3.0.<br>\n<br>\n<span class=\"bold\">FIONWRITE (0x4602) :</span><br>\nSemblable à FIONREAD, mais ici le nombre d\'octets pouvant être écrits actuellement est renvoyé. La commande est prise en charge dans MagiC à partir de la version 3.0.<br>\n<br>\n<span class=\"bold\">FUTIME (0x4603) :</span><br>\nAucune information disponible pour le moment.<br>\n<br>\n<span class=\"bold\">FTRUNCATE (0x4604) :</span><br>\nLe paramètre arg est un pointeur vers une valeur LONG qui contient la nouvelle longueur du fichier à tronquer. La commande est prise en charge dans MagiC à partir de la version 3.0.<br>\n<br>\n<span class=\"bold\">FIOEXECPT (0x4605) :</span><br>\nLe paramètre arg renvoie un pointeur vers une valeur LONG qui spécifie si le fichier est en état d\'exception (1) ou non (0).<br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Les commandes suivantes doivent être appliquées à tous les périphériques de terminal, comme la console ou un pseudo-terminal :</span></span><br>\n<br>\n<span class=\"bold\">TIOCGETP (0x5400) :</span><br>\nCette commande renvoie via le paramètre arg un pointeur vers une structure sgttyb, dans laquelle les paramètres du terminal sont définis.<br>\n<br>\n<span class=\"bold\">TIOCSETN (0x5401) :</span><br>\nAvec cette commande, on peut définir une nouvelle structure sgttyb qui définit les paramètres du terminal. Vous devez d\'abord obtenir les paramètres de contrôle du terminal, modifier ce que vous souhaitez changer, puis les définir avec cet appel.<br>\n<br>\n<span class=\"bold\">TIOCGETC (0x5402) :</span><br>\nCette commande renvoie via le paramètre arg un pointeur vers une structure tchars dans laquelle les caractères de contrôle du terminal sont définis.<br>\n<br>\n<span class=\"bold\">TIOCSETC (0x5403) :</span><br>\nAvec cette commande, de nouveaux caractères de contrôle du terminal peuvent être définis. Pour cela, on passe un pointeur dans arg vers une structure tchars dans laquelle les caractères de contrôle sont définis. Si un caractère est défini sur 0, la fonction correspondante sera désactivée.<br>\n<br>\n<span class=\"bold\">TIOCGLTC (0x5404) :</span><br>\nCette commande renvoie via le paramètre arg un pointeur vers une structure ltchars dans laquelle des caractères de contrôle étendus du terminal sont définis.<br>\n<br>\n<span class=\"bold\">TIOCSLTC (0x5405) :</span><br>\nAvec cette commande, on peut définir de nouveaux caractères de contrôle étendus du terminal. Pour cela, on passe dans arg un pointeur vers une structure ltchars dans laquelle les caractères de contrôle sont définis. Si un caractère est défini sur 0, la fonction correspondante sera désactivée.<br>\n<br>\n<span class=\"bold\">TIOCGPGRP (0x5406) :</span><br>\nCette commande renvoie via le paramètre arg un pointeur vers l\'ID du groupe de processus du terminal.<br>\n<br>\n<span class=\"bold\">TIOCSPGRP (0x5407) :</span><br>\nAvec cette commande, on peut définir l\'ID du groupe de processus du terminal. Pour cela, on passe dans le paramètre arg un pointeur vers le groupe de processus correspondant. Si des processus d\'autres groupes tentent d\'accéder à ce terminal (lecture ou écriture), ils recevront des signaux de contrôle de tâche (SIGTSTP etc.).<br>\n<br>\n<span class=\"bold\">TIOCFLUSH (0x5408) :</span><br>\nAvec cette commande, on peut spécifier le type de vidage. Pour cela, on passe un pointeur dans le paramètre arg vers une valeur LONG qui décrit le type souhaité. Les valeurs possibles sont :<br>\n<br>\nValeur	Signification<br>\n0	Vidage de l\'entrée et sortie<br>\n1	Vidage de l\'entrée<br>\n2	Vidage de la sortie<br>\n<br>\n<span class=\"bold\">Retour :</span><br>\nSi la commande est reconnue, une valeur dépendant de la commande correspondante est renvoyée. Sinon, la valeur EINVFN est renvoyée.<br>\n<br>\n<span class=\"bold\">TIOCSTOP (0x5409) :</span><br>\nCette commande interrompt la sortie vers le terminal (similaire au contrôle de flux avec Control-S). Le paramètre arg est ignoré dans ce cas.<br>\n<br>\n<span class=\"bold\">TIOCSTART (0x540a) :</span><br>\nCette commande redémarre la sortie vers le terminal (similaire au contrôle de flux avec Control-Q). Le paramètre arg est ignoré dans ce cas.<br>\n<br>\n<span class=\"bold\">TIOCGWINSZ (0x540b) :</span><br>\nCette commande permet de connaître la taille d\'une fenêtre de texte. Pour cela, un pointeur vers une structure winsize est retourné via le paramètre arg. Si un élément de cette structure a la valeur 0, cela signifie que la valeur correspondante est inconnue.<br>\n<br>\n<span class=\"bold\">TIOCSWINSZ (0x540c) :</span><br>\nCette commande permet de définir la taille de la fenêtre. Pour cela, un pointeur vers une structure winsize est passé via le paramètre arg contenant les informations requises. Il convient de noter que bien que le noyau gère l\'appel, il laisse son exécution aux gestionnaires de fenêtres. Ceux-ci envoient également le signal SIGWINCH si nécessaire.<br>\n<br>\n<span class=\"bold\">TIOCGXKEY (0x540d) :</span><br>\nCette commande renvoie la définition actuelle d\'une touche système (fonction, curseur, etc.). Pour cela, un pointeur vers la structure xkey est passé dans le paramètre arg. L\'élément xk_num de la structure doit être rempli avec la touche souhaitée :<br>\n<br>\nxk_num	Touche<br>\n0-9	F1-F10<br>\n10-19	F11-F20 (via Shift)<br>\n20	Curseur haut<br>\n21	Curseur bas<br>\n22	Curseur droite<br>\n23	Curseur gauche<br>\n24	Aide<br>\n25	Annuler<br>\n26	Insérer<br>\n27	Effacer/Accueil<br>\n28	Shift + curseur haut<br>\n29	Shift + curseur bas<br>\n30	Shift + curseur droite<br>\n31	Shift + curseur gauche<br>\nLa chaîne de caractères NULL-terminée associée à la touche (selon la convention du langage C) est retournée via l\'élément xk_def.<br>\n<br>\n<span class=\"bold\">TIOCSXKEY (0x540e) :</span><br>\nAvec cette commande, on peut définir la définition actuelle d\'une touche système (fonction ou curseur, etc.). Pour cela, un pointeur vers la structure xkey est passé dans le paramètre arg, dans lequel les éléments xk_num et xk_def doivent déjà être définis. Après l\'exécution de la commande, Fread renvoie la chaîne de texte (au lieu de ASCII-0) spécifiée dans xk_def. Cette traduction ne se produit cependant que si le programme a été placé dans le domaine MiNT avec Pdomain et si le terminal lit les caractères en utilisant Fread. Comme la chaîne passée dans xk_def doit être NULL-terminée, on peut passer un maximum de 7 caractères de cette manière.<br>\n<br>\n<span class=\"bold\">TIOCIBAUD (0x5412) :</span><br>\nAvec cette commande, on peut définir le débit en bauds pour l\'entrée vers le terminal. Pour cela, un pointeur est passé via le paramètre arg vers une valeur LONG qui spécifie le débit en bauds.<br>\n<br>\n<span class=\"bold\">TIOCOBAUD (0x5413) :</span><br>\nAvec cette commande, on peut définir le débit en bauds pour la sortie du terminal. Pour cela, un pointeur est passé via le paramètre arg vers une valeur LONG qui spécifie le débit en bauds.<br>\n<br>\n<span class=\"bold\">TIOCCBRK (0x5414) :</span><br>\nCette commande efface le bit 3 du registre TSR (la condition de rupture) du composant périphérique MFP68901. Le paramètre arg est ignoré.<br>\n<br>\n<span class=\"bold\">TIOCSBRK (0x5415) :</span><br>\nCette commande définit le bit 3 du registre TSR du composant périphérique MFP68901. Cela entraîne l\'envoi d\'un signal de rupture dès que le registre de transmission est vide. Le paramètre arg est ignoré.<br>\n<br>\n<span class=\"bold\">TIOCGFLAGS (0x5416) :</span><br>\nCette commande renvoie dans les 16 bits inférieurs du LONG pointé par le paramètre arg les drapeaux de contrôle du terminal (i.e. la configuration actuelle des bits d\'arrêt et des bits de données). Les valeurs de masque valides pour arg sont :<br>\n<br>\nMasque	Signification<br>\n0x0001	1 bit d\'arrêt<br>\n0x0002	1.5 bits d\'arrêt<br>\n0x0003	2 bits d\'arrêt<br>\n0x0000	8 bits de données<br>\n0x0004	7 bits de données<br>\n0x0008	6 bits de données<br>\n0x000C	5 bits de données<br>\n<br>\n<span class=\"bold\">TIOCSFLAGS (0x5417) :</span><br>\nCette commande définit de nouveaux drapeaux de contrôle du terminal qui sont passés via le paramètre arg.', '<span class=\"bold\">TIOCOUTQ (0x5418) :</span><br>\nCette commande renvoie dans arg un pointeur vers une valeur LONG dans laquelle est stocké le nombre d\'octets dans le tampon de sortie.<br>\n<br>\n<span class=\"bold\">TIOCSETP (0x5419) :</span><br>\nFonctionne de manière similaire à TIOCSETN, mais avec la différence que (si le terminal supporte TIOCOUTQ) la fonction ne retourne que lorsque le tampon de sortie est vide.<br>\n<br>\n<span class=\"bold\">TCURSOFF (0x6300) :</span><br>\nCette commande désactive le curseur du terminal. Le paramètre arg est ignoré.<br>\n<br>\n<span class=\"bold\">TCURSON (0x6301) :</span><br>\nCette commande active le curseur du terminal. Le paramètre arg est ignoré.<br>\n<br>\n<span class=\"bold\">TCURSBLINK (0x6302) :</span><br>\nCette commande active le clignotement du curseur du terminal. La fréquence de clignotement peut être définie avec TCURSSRATE. Le paramètre arg est ignoré.<br>\n<br>\n<span class=\"bold\">TCURSSTEADY (0x6303) :</span><br>\nCette commande désactive le clignotement du curseur du terminal. Le paramètre arg est ignoré.<br>\n<br>\n<span class=\"bold\">TCURSSRATE (0x6304) :</span><br>\nCette commande définit la fréquence de clignotement du curseur du terminal. Pour cela, un pointeur vers une valeur WORD est passé dans arg qui spécifie après combien de blancs verticaux le curseur doit être inversé.<br>\n<br>\n<span class=\"bold\">TCURSGRATE (0x6305) :</span><br>\nCette commande obtient la fréquence de clignotement du curseur du terminal. Cela est retourné dans une valeur WORD vers laquelle arg pointe.<br>\n<br>\nLes commandes suivantes sont applicables uniquement aux processus (ouverts comme des fichiers). Pour ouvrir votre propre processus en tant que fichier, vous devez spécifier le chemin pour Fopen comme U:\\PROC\\processname.-1. Ici, l\'extension -1 sélectionne votre propre processus, et -2 le processus parent.<br>\n<br>\n<span class=\"bold\">PBASEADDR (0x5002) :</span><br>\nDans le paramètre arg, un pointeur vers l\'adresse de la page de base GEMDOS du processus ouvert en tant que fichier est retourné. La commande est prise en charge dans MagiC à partir de la version 3.0.<br>\n<br>\n<span class=\"bold\">PPROCADDDR (0x5001) :</span><br>\nDans le paramètre arg, un pointeur vers l\'adresse du PCB (Process Control Block) est retourné.<br>\n<br>\n<span class=\"bold\">PCTXTSIZE (0x5003) :</span><br>\nDans le paramètre arg, un pointeur vers une valeur LONG est retourné dans laquelle la longueur de la structure de contexte de processus est spécifiée. Deux de ces structures se trouvent en mémoire avant le PCB, dont l\'adresse peut être demandée avec PPROCADDR. La première structure est responsable du contexte de processus actuel, tandis que la deuxième contient le contexte stocké du dernier appel système.<br>\n<br>\n<span class=\"bold\">PSETFLAGS (0x5004) :</span><br>\nCette commande définit les drapeaux du programme (correspondant à ceux de l\'en-tête du programme). Pour cela, un pointeur vers une valeur LONG est passé dans arg dont les 16 bits inférieurs représentent les drapeaux du programme.<br>\n<br>\n<span class=\"bold\">PGETFLAGS (0x5005) :</span><br>\nCette commande obtient les drapeaux actuels du programme. Pour cela, un pointeur vers ces drapeaux est retourné via le paramètre arg.<br>\n<br>\n<span class=\"bold\">PTRACESFLAGS (0x5006) :</span><br>\nCette commande définit les drapeaux de trace du processus. Un pointeur vers une valeur WORD est passé dans le paramètre arg représentant les drapeaux :<br>\n<br>\nP_ENABLE = 1 (Activer la trace)<br>\nP_DOS = 2 (Tracer les appels GEMDOS)<br>\nP_BIOS = 4 (Tracer les appels BIOS)<br>\nP_XBIOS = 8 (Tracer les appels XBIOS)<br>\n<span class=\"bold\">PTRACEGFLAGS (0x5007) :</span><br>\nCette commande obtient les drapeaux de trace actuels du processus. Un pointeur vers ces drapeaux est retourné via le paramètre arg.<br>\n<br>\n<span class=\"bold\">PTRACEGO (0x5008) :</span><br>\nÀ partir du processeur MC-68020.<br>\n<br>\n<span class=\"bold\">PTRACEFLOW (0x5009) :</span><br>\nÀ partir du processeur MC-68020.<br>\n<br>\n<span class=\"bold\">PTRACESTEP (0x500a) :</span><br>\nÀ partir du processeur MC-68020.<br>\n<br>\n<span class=\"bold\">PTRACE11 (0x500b) :</span><br>\nÀ partir du processeur MC-68020.<br>\n<br>\nCes fonctions devraient à l\'avenir permettre la traçabilité des processus. Le processus à tracer doit être en état \"suspendu\" pour cela ; il sera réveillé par la fonction de trace. Ces fonctions ne sont cependant pas encore implémentées à l\'heure actuelle.<br>\n<br>\n<span class=\"bold\">PLOADINFO (0x500c) :</span><br>\nCette commande retourne dans arg un pointeur vers la structure ploadinfo, dans laquelle le nom du programme et la ligne de commande sont stockés.<br>\n<br>\n<span class=\"bold\">PFSTAT (0x500d) :</span><br>\nCette commande correspond à FSTAT. Elle obtient les attributs étendus du fichier programme appartenant au processus.<br>\n<br>\nLes commandes suivantes sont applicables uniquement aux fichiers représentant une mémoire partagée :<br>\n<br>\n<span class=\"bold\">SHMGETBLK (0x4d00) :</span><br>\nCette commande retourne l\'adresse d\'un bloc de mémoire alloué avec SHMSETBLK (ou un pointeur NULL en cas d\'erreur). Par souci de compatibilité, le paramètre arg doit être défini à la valeur 0. Remarque : Différents processus peuvent voir le bloc de mémoire à différentes positions dans leur espace d\'adressage. Pour cette raison, un bloc de mémoire partagé ne doit pas contenir de pointeurs absolus vers des données ! La commande est prise en charge dans MagiC à partir de la version 3.0.<br>\n<br>\n<span class=\"bold\">SHMSETBLK (0x4d01) :</span><br>\nUn pointeur est passé dans le paramètre arg vers un bloc de mémoire qui a été précédemment alloué avec Malloc/Mxalloc. La mémoire est alors offerte pour le partage sous le nom de fichier du fichier avec le handle fh. Pour cela, le fichier doit être créé dans le sous-répertoire U:\\SHM. Le bloc est marqué de manière à ne pas être libéré à la fin du processus. La longueur sera obtenue et utilisée à la fois pour le fichier ouvert et entrée dans le répertoire. Les adresses de blocs invalides entraînent le code d\'erreur EIMBA ou une erreur de bus ou d\'adresse. La commande est prise en charge dans MagiC à partir de la version 3.0.<br>\n<br>\nLes commandes suivantes sont d\'intérêt en relation avec les CD-ROM :<br>\n<br>\n<span class=\"bold\">CDROMREADOFFSET (0x4300) :</span><br>\nCette commande obtient le numéro de bloc du premier secteur de la dernière session d\'un CD multi-session. Le paramètre arg contient ce numéro de bloc après l\'appel.<br>\n<br>\n<span class=\"bold\">CDROMPAUSE (0x4301) :</span><br>\nCette commande met un CD-ROM en pause lors de la lecture d\'un CD audio.<br>\n<br>\n<span class=\"bold\">CDROMRESUME (0x4302) :</span><br>\nCette commande reprend la lecture d\'un CD audio (la pause est annulée).<br>\n<br>\n<span class=\"bold\">CDROMPLAYMSF (0x4303) :</span><br>\nCette commande démarre la lecture audio. Le paramètre arg est un pointeur vers une structure cdrom_msf, dans laquelle les heures de début et de fin doivent être saisies en notation MSF.<br>\n<br>\n<span class=\"bold\">CDROMPLAYTRKIND (0x4304) :</span><br>\nCette commande démarre la lecture audio. Le paramètre arg est un pointeur vers une structure cdrom_ti dans laquelle les positions de début et de fin doivent être saisies en notation de piste/indice. Dans la plupart des CD audio du monde POP, les pistes ne sont pas subdivisées davantage. Mais de nombreux CD classiques ont aussi des marquages plus fins au sein des pistes en tant qu\'indices. Attention : Tous les lecteurs de CD-ROM ne peuvent pas accéder directement aux indices autres que 1 !<br>\n<br>\n<span class=\"bold\">CDROMREADTOCHDR (0x4305) :</span><br>\nCette commande permet d\'obtenir des informations sur la structure d\'un CD. Le paramètre arg est un pointeur vers une structure cdrom_tochdr dans laquelle les première et dernière pistes du CD sont saisies.<br>\n<br>\n<span class=\"bold\">CDROMREADTOCENTRY (0x4306) :</span><br>\nCette commande permet d\'obtenir des informations supplémentaires sur la structure d\'un CD. Le paramètre arg est un pointeur vers une structure cdrom_tocentry dans laquelle les informations souhaitées sont saisies.<br>\n<br>\n<span class=\"bold\">CDROMSTOP (0x4307) :</span><br>\nCette commande arrête le lecteur correspondant.<br>\n<br>\n<span class=\"bold\">CDROMSTART (0x4308) :</span><br>\nCette commande démarre le lecteur correspondant et peut également fermer le tiroir.<br>\n<br>\n<span class=\"bold\">CDROMEJECT (0x4309) :</span><br>\nCette commande sert à ouvrir le tiroir du lecteur correspondant.<br>\n<br>\n<span class=\"bold\">CDROMVOLCTRL (0x430a) :</span><br>\nCette commande permet de modifier le volume et les affectations de canaux des différents canaux audio. Le paramètre arg est un pointeur vers une structure cdrom_volctrl. La commande est compatible avec l\'appel SunOS correspondant.<br>\n <div class=\"border-red\"><p>Attention : La modification du volume n\'est pas possible avec tous les appareils !</p></div><br>\n<br>\n<span class=\"bold\">CDROMSUBCHNL (0x430b) :</span><br>\nCette commande obtient les données de position actuelles, ainsi que l\'état audio. Le paramètre arg est un pointeur vers une structure cdrom_subchnl.<br>\n<br>\n<span class=\"bold\">CDROMREADMODE2 (0x430c) :</span><br>\nCette commande permet la lecture des secteurs en Mode-2. Ces secteurs sont utilisés par les CD-XA (par exemple : Photo-CD sans correction d\'erreurs ou Vidéo-CD) et contiennent 2336 octets. Le paramètre arg est un pointeur vers une structure cdrom_read. <div class=\"border-red\"><p>Attention : Tous les appareils ne peuvent pas lire ces types de secteurs, et tous les pilotes ne proposent pas cette fonction.</p></div><br>\n<br>\n<span class=\"bold\">CDROMREADMODE1 (0x430d) :</span><br>\nCette commande permet la lecture des secteurs en Mode-1. Ces secteurs ont une taille de 2048 octets et sont utilisés sur les CD-ROM normaux. Le paramètre arg est un pointeur vers une structure cdrom_read. <br>\n<div class=\"border-red\"><p>Attention : Tous les appareils ne peuvent pas lire ces types de secteurs, et tous les pilotes ne proposent pas cette fonction.</p></div><br>\n<br>\n<span class=\"bold\">CDROMPREVENTREMOVAL (0x430e) :</span><br>\nCette commande bloque la fonction d\'éjection du CD-ROM correspondant. Cela peut être utile, par exemple, si l\'appareil est placé dans un lieu public et que l\'on veut empêcher le vol du CD.<br>\n<br>\n<span class=\"bold\">CDROMALLOWREMOVAL (0x430f) :</span><br>\nCette commande libère la fonction d\'éjection du CD-ROM correspondant.<br>\n<br>\n<span class=\"bold\">CDROMAUDIOCTRL (0x4310) :</span><br>\nCette commande permet de modifier le volume et les affectations de canaux des différents canaux audio. Le paramètre arg est un pointeur vers une structure cdrom_audioctrl. En définissant l\'élément set de cette structure à la valeur 0, on peut obtenir les paramètres actuels. <div class=\"border-red\"><p>Attention : La modification du volume n\'est pas possible avec tous les appareils !</p></div><br>\n<br>\n<span class=\"bold\">CDROMREADDA (0x4311) :</span><br>\nCette commande permet la lecture des secteurs Audio Numérique (DA). Ces secteurs ont une taille de 2352 octets et contiennent par secteur 588 échantillons en format 16 bits stéréo-PCM. Le paramètre arg est un pointeur vers une structure cdrom_read. <br>\n<div class=\"border-red\"><p>Attention : Tous les appareils ne peuvent pas lire ces types de secteurs, et tous les pilotes ne proposent pas cette fonction.</p></div><br>\n<br>\n<span class=\"bold\">CDROMGETMCN (0x4313) :</span><br>\nCette commande obtient le Numéro de Catalogue Médial, qui peut théoriquement être utilisé pour identifier facilement un CD. Malheureusement, cette information est présente dans très peu de CD. Le paramètre arg est un pointeur vers une structure cdrom_mcn.<br>\n<br>\n<span class=\"bold\">CDROMGETTISRC (0x4314) :</span><br>\nCette commande obtient le Code International d’Enregistrement de Piste (Track International Standard Recording Code - TISRC), qui devrait représenter des identifiants uniques pour les pistes individuelles. Le paramètre arg est un pointeur vers une structure cdrom_tisrc.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span><br>\nLa fonction peut retourner les résultats suivants :<br>\n>= 0 : Aucun erreur survenue (voir les écarts ci-dessus).<br>\n<span class=\"bold\">EBADF :</span> Handle de fichier invalide.<br>\n<span class=\"bold\">EINVFN :</span> La commande ne peut pas être exécutée avec le handle fh.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span><br>\nDepuis la première version de MultiTOS intégrant MiNT version 1.04, et MagiC à partir de la version 3.0.<br>\n<span class=\"code\">move.w    cmd,-(sp)    ; Offset 8<br>\nmove.l    arg,-(sp)    ; Offset 4<br>\nmove.w    fh,-(sp)     ; Offset 2<br>\nmove.w    #260,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\nlea       $A(sp),sp    ; Corriger la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 2, 3, 16),
(218, 'Fcreate', '', '', '<span class=\"bold\">Nom :</span> « Création de fichier » - Créer un fichier.<br>\n<span class=\"bold\">Opcode :</span> 60<br>\n<span class=\"bold\">Syntaxe : </span>int16_t Fcreate ( const int8_t *fname, int16_t attr );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fcreate crée un nouveau fichier, ou tronque un fichier existant, avec un nom et des attributs donnés. Les paramètres suivants s\'appliquent :<br>\n<br>\nfname : Pointeur vers le nom du fichier.<br>\nattr : Attributs du fichier :<br>\nBit 0 : Fichier protégé en écriture<br>\nBit 1 : Fichier caché<br>\nBit 2 : Fichier système<br>\nBit 3 : Étiquette de volume (nom du disque)<br>\nBit 5 : Bit d\'archive<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nDans un réseau, la création d\'un fichier établit l\'exclusivité. La capacité réseau du GEMDOS sous-jacent peut être déterminée via le cookie _FLK.</p></div><br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque sur MagiC :</span><br>\nSi le bit 3 dans attr est défini, alors la fonction XFS xfs_wlabel sera appelée. Si cette fonction peut être exécutée sans erreur, la valeur 0x0000fffc sera retournée. Cela correspond à un handle pour le fichier NUL: ou U:\\DEV\\NULL. Cependant, cette fonctionnalité est présente uniquement pour des raisons de compatibilité ; à partir de MagiC 3, il est préférable d\'utiliser la fonction Dwritelabel.</p></div>', 'Les attributs spécifiés n\'existent que dans les systèmes de fichiers DOS et sont ignorés ou émuler par d\'autres systèmes de fichiers. Avec le système de fichiers Macintosh (HFS), par exemple, seul le bit 0 de attr est supporté.<br>\n<br>\nEn outre, les liens symboliques sont désignés par cette fonction, de sorte que si le fichier existe déjà en tant que lien symbolique, le fichier référencé par ce lien sera défini à une longueur nulle.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">EPTHNF :</span> Chemin d\'accès incorrect.<br>\n<span class=\"bold\">ENHNDL :</span> Plus de handles de fichier disponibles.<br>\n<span class=\"bold\">EACCDN :</span> Accès en écriture refusé.<br>\n<span class=\"bold\">Autrement :</span> ID du fichier.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions GEMDOS. Cependant, GEMDOS Version 0.13 créant un fichier en lecture seule retourne un handle qui est de peu d\'utilité. Les versions GEMDOS antérieures à 0.15 permettent incorrectement plus d\'une étiquette de volume par disque.<br>\n<br>\n<span class=\"code\">move.w    attr,-(sp)   ; Offset 6<br>\npea       fname        ; Offset 2<br>\nmove.w    #60,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Corriger la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Handle%=Gemos(&H3c,L:fname%,W:attr)</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(219, 'Fdatime', '', '', '<span class=\"bold\">Nom : </span>« Date et heure du fichier » - Obtenir ou définir la date et l\'heure de création d\'un fichier.<br>\n<span class=\"bold\">Opcode :</span> 87<br>\n<span class=\"bold\">Syntaxe :</span> void Fdatime ( DOSTIME *timeptr, int16_t handle, int16_t wflag );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fdatime lit ou définit la date et l\'heure de création d\'un fichier. Les paramètres suivants s\'appliquent :<br>\ntimeptr : Pointeur vers la structure date/heure<br>\nhandle : ID du fichier<br>\nwflag :<br>\n0 = Obtenir les valeurs<br>\n1 = Définir les valeurs<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque : </span><br>\nEn raison de certaines erreurs dans les anciennes versions de GEMDOS, la fonction doit être appliquée de la manière suivante :<br>\nOuvrir le fichier<br>\nAppeler Fdatime<br>\nFermer le fichier</p></div>', '<span class=\"bold\">Valeur de retour : </span>La fonction ne retourne aucun résultat direct.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    wflag,-(sp)   ; Offset 8<br>\nmove.w    handle,-(sp)  ; Offset 6<br>\npea       timeptr       ; Offset 2<br>\nmove.w    #87,-(sp)     ; Offset 0<br>\ntrap      #1            ; GEMDOS<br>\nlea       $A(sp),sp     ; Corriger la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Fehler%=Gemdos(&H57,L:timeptr%,W:handle%,W:wflag%)</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(220, 'Fdelete', '', '', '<span class=\"bold\">Nom :</span> « Suppression de fichier » - Supprimer un fichier.<br>\n<span class=\"bold\">Opcode : </span>65<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Fdelete ( const int8_t *fname );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fdelete supprime le fichier désigné par fname.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nLa fonction ne doit pas être appliquée aux fichiers ouverts. À partir de MagiC 4, la suppression fonctionne également pour les fichiers avec les attributs \'Caché\' et \'Système\'. De plus, dans MagiC, aucun lien symbolique ne sera désigné, c\'est-à-dire que le lien sera supprimé et non le fichier ou le dossier auquel le lien pointe.</p></div><br>\n', '<span class=\"bold\">Valeur de retour : </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucun erreur survenue<br>\n<span class=\"bold\">EFILNF :</span> Fichier non trouvé<br>\n<span class=\"bold\">EACCDN : </span>Accès refusé<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions GEMDOS.<br>\n<br>\n<span class=\"code\">pea       fname        ; Offset 2<br>\nmove.w    #65,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Corriger la pile</span><br>\n<br>\nGFA-Basic :<br>\n<span class=\"code\">Fehler%=Gemdos(&H41,L:fname%)</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(221, 'Fdirfd', '', '', '<span class=\"bold\">Nom : </span>« Fdirfd » - Retourne un descripteur de fichier à partir d\'un handle de répertoire.<br>\n<span class=\"bold\">Opcode : </span>387 (0x0183)<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Fdirfd ( int32_t handle );<br>\n<span class=\"bold\">Description :</span> La fonction Fdirfd retourne un descripteur de fichier à partir du handle de répertoire spécifié.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne un handle de fichier si elle réussit, ou un code d\'erreur négatif.', '<span class=\"bold\">Disponibilité :</span> Disponible depuis la version 1.17 de FreeMiNT.<br>\n<br>\n<span class=\"code\">move.l    handle,-(sp) ; Offset 2<br>\nmove.w    #387,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Corriger la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(222, 'Fdup', '', '', '<span class=\"bold\">Nom :</span> « Duplication de fichier » - Dupliquer un handle de fichier.<br>\n<span class=\"bold\">Opcode :</span> 69<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Fdup ( int16_t handle );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fdup duplique un handle de fichier standard (0-5) et lui attribue un nouveau handle (>6) pour un canal standard. Les paramètres suivants s\'appliquent :<br>\n0 : Clavier (stdin:)<br>\n1 : Écran (stdout:)<br>\n2 : Port série (stdaux:)<br>\n3 : Port parallèle (stdprn:)<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque : </span><br>\nDans toutes les versions connues de GEMDOS (jusqu\'à et y compris 0.19), des erreurs se produisent si, après un Fdup, un programme est démarré avec Pexec. À partir de MagiC 4, on peut également utiliser cette fonction pour les fichiers de périphérique -1, -2, -3 (global système) et -4 (périphérique NULL).</p></div><br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">ENHNDL :</span> Plus de handles disponibles.<br>\n<span class=\"bold\">EBADF : </span>Handle de fichier incorrect.<br>\n<span class=\"bold\">Autrement :</span> Le nouveau handle désiré.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    handle,-(sp)  ; Offset 2<br>\nmove.w    #69,-(sp)     ; Offset 0<br>\ntrap      #1            ; GEMDOS<br>\naddq.l    #4,sp         ; Corriger la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Phys_channel%=Gemdos(&H45,W:handle%)</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(223, 'Ffchmod', '', '', '<span class=\"bold\">Nom : </span>« Ffchmod » - Changer les permissions d\'accès pour un fichier ouvert.<br>\n<span class=\"bold\">Opcode : </span>258 (0x0102)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Ffchmod ( int16_t fd, int16_t mode);<br>\n<span class=\"bold\">Description :</span> Voir « Nom » ci-dessus.<br>\n<br>\n<span class=\"bold\">Valeur de retour : </span>Retourne E_OK en cas de succès ou un code d\'erreur GEMDOS négatif sinon.', '<span class=\"bold\">Disponibilité :</span> Disponible depuis la version 1.15.2 de FreeMiNT.<br>\n<br>\n<span class=\"code\">move.w    mode,-(sp)   ; Offset 4<br>\nmove.w    fd,-(sp)     ; Offset 2<br>\nmove.w    #258,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Corriger la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(224, 'Ffchown', '', '', '<span class=\"bold\">Nom :</span> « Ffchown » - Change la propriété d\'un fichier ouvert en uid et gid respectivement.<br>\n<span class=\"bold\">Opcode :</span> 257 (0x0101)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Ffchown ( int16_t fd, int16_t uid, int16_t gid );<br>\n<span class=\"bold\">Description : </span>Cette fonction change la propriété d\'un fichier ouvert en uid et gid respectivement.<br>\n<br>\nUn processus non privilégié ne peut changer la propriété d\'un fichier que s\'il est détenu par cet utilisateur, à l\'identifiant de groupe effectif du processus ou à l\'un de ses groupes secondaires.', '<span class=\"bold\">Valeur de retour :</span> Retourne E_OK en cas de succès ou un code d\'erreur GEMDOS négatif sinon.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible depuis la version 1.15.2 de FreeMiNT.<br>\n<br>\n<span class=\"code\">move.w    gid,-(sp)    ; Offset 6<br>\nmove.w    uid,-(sp)    ; Offset 4<br>\nmove.w    fd,-(sp)     ; Offset 2<br>\nmove.w    #257,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Corriger la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(225, 'Ffdopendir', '', '', '<span class=\"bold\">Nom :</span> « Ffdopendir » - Dupliquer un handle de répertoire à partir d\'un descripteur de fichier.<br>\n<span class=\"bold\">Opcode :</span> 386 (0x0182)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Ffdopendir ( int16_t fd );<br>\n<span class=\"bold\">Description :</span> La fonction Ffdopendir duplique un handle de répertoire d\'un répertoire ouvert en spécifiant son descripteur de fichier. Le flag du répertoire avec l\'ID fd est hérité par le nouveau handle de répertoire.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne un handle de répertoire 32 bits si elle réussit ; ce handle peut aussi être négatif, mais il ne peut en aucun cas contenir la valeur 0xff dans l\'octet supérieur, ce qui permet de le différencier des erreurs.<br>\n', 'En cas d\'erreur, les retours possibles sont :<br>\n<span class=\"bold\">EPTHNF :</span> fd n\'est pas un répertoire valide<br>\n<span class=\"bold\">EACCDN :</span> Le répertoire n\'est pas accessible par ce programme<br>\n<span class=\"bold\">ENSMEM :</span> Le noyau ne peut pas allouer de mémoire pour cette opération<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible depuis la version 1.17 de FreeMiNT.<br>\n<br>\n<span class=\"code\">move.w    fd,-(sp)     ; Offset 2<br>\nmove.w    #386,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #4,sp        ; Corriger la pile</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(226, 'Fforce', '', '', '<span class=\"bold\">Nom :</span> « Fforce » - Rediriger un fichier standard.<br>\n<span class=\"bold\">Opcode :</span> 70<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Fforce ( int16_t stdh, int16_t nonstdh );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fforce redirige un canal standard vers un autre canal spécifique créé par l\'application. Les paramètres suivants s\'appliquent :<br>\n<br>\n<span class=\"bold\">stdh :</span> Canal à rediriger<br>\n0 = Clavier (stdin, con:)<br>\n1 = Écran (stdout, con:)<br>\n2 = Port série (stdaux:)<br>\n3 = Port parallèle (stdprn:)<br>\n<br>\n<span class=\"bold\">nonstdh :</span> Numéro du canal de remplacement (comme ci-dessus)<br>\n<br>\nSous MiNT, d\'autres canaux peuvent être redirigés :<br>\n-1 = Réfère au handle BIOS 2, redirige la sortie BIOS<br>\n-2 = Réfère au handle BIOS 1, redirige la sortie BIOS<br>\n-3 = Réfère au handle BIOS 0, redirige la sortie BIOS<br>\n-4 = Les handles GEMDOS -4 et -5 se réfèrent respectivement aux entrées et sorties MIDI. Les rediriger affectera les handles BIOS 3.<br>\n<br>\n<div class=\"border-yellow\"><p>Note : Depuis MagiC 4, cette fonction peut être utilisée pour rediriger les fichiers de périphérique -1, -2 et -3 (global système). Le périphérique NULL (-4) ne peut cependant pas être redirigé.<br>\nPour rediriger, par exemple, la sortie de l\'écran vers une imprimante, on peut utiliser une structure comme Fforce(1, Fdup(3)).</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucun erreur survenue<br>\n<span class=\"bold\">EBADF : </span>Handle incorrect<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions GEMDOS.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Note :</span><br>\nCette fonction est souvent utilisée pour rediriger l\'entrée ou la sortie d\'un processus fils. Elle doit être utilisée avec Fdup pour restaurer le handle standard avant que le processus ne se termine. Il est également important de noter que tout handle de fichier redirigé vers un handle standard (comme con:) sera fermé lorsque le fils se termine et ne doit pas être fermé par le parent.</p></div><br>\n<br>\n<span class=\"code\">move.w    nonstdh,-(sp)  ; Offset 4<br>\nmove.w    stdh,-(sp)     ; Offset 2<br>\nmove.w    #70,-(sp)      ; Offset 0<br>\ntrap      #1             ; GEMDOS<br>\naddq.l    #6,sp          ; Corriger la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Fehler%=Gemdos(&H46,W:stdh%,W:nonstdh%)</span>', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(227, 'Ffstat64', '', '', '<span class=\"bold\">Nom :</span> « Ffstat64 » - Obtenir les attributs étendus d\'un fichier ouvert.<br>\n<span class=\"bold\">Opcode :</span> 349 (0x15d)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Ffstat64 ( int16_t fd, STAT *stat );<br>\n<span class=\"bold\">Description : </span>La fonction Ffstat64 obtient les attributs étendus d\'un fichier ouvert et les enregistre dans stat.<br>\n<br>\n<div class=\"border-yellow\"><p>Note : Cette fonction est équivalente à un appel de Fcntl (mode F_STAT64).</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucun erreur survenue<br>\n<span class=\"bold\">EFILNF :</span> Fichier non trouvé<br>\n<span class=\"bold\">EPTHNF :</span> Chemin vers le fichier non trouvé<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Cette fonction est disponible depuis FreeMiNT 1.16.<br>\n<br>\n<span class=\"code\">pea       stat         ; Offset  4<br>\nmove.w    fd,-(sp)     ; Offset  2<br>\nmove.w    #349,-(sp)   ; Offset  0<br>\ntrap      #1           ; GEMDOS<br>\nlea       8(sp),sp     ; Corriger la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 3, 3, 16),
(228, 'Fgetchar', '', '', '<span class=\"bold\">Nom :</span> « Fgetchar » - Lire un caractère depuis un fichier.<br>\n<span class=\"bold\">Opcode : </span>263<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fgetchar ( int16_t fh, int16_t mode );<br>\n<span class=\"bold\">Description :</span> La fonction Fgetchar lit un caractère depuis le fichier avec le handle fh. Le paramètre mode est uniquement pertinent lorsque le fichier ouvert est un (pseudo-)terminal. Dans ce cas, les valeurs suivantes s\'appliquent :<br>\n<br>\nmode : Signification<br>\n0 = Mode brut : Pas d\'évaluation des caractères de contrôle<br>\n1 = Mode cuit : Les caractères de contrôle spéciaux (Contrôle-C, Contrôle-Z) seront recherchés et interprétés si approprié ; cela s\'applique également au contrôle de flux (Contrôle-S, Contrôle-Q)<br>\n2 = Mode écho : Les caractères lus seront affichés sur le terminal<br>\nLa valeur ASCII du caractère lu sera stockée dans le bas byte du LONG retourné par la fonction. Pour les cas où le fichier est un (pseudo-)terminal, le code scanné et l\'état Shift seront retournés comme pour Bconin.<br>\n<br>\nLes modes individuels de mode peuvent naturellement également être combinés avec une opération OR.', '<div class=\"border-red\"><p><span class=\"bold\">Avertissement :</span><br>\nCette fonction est optionnelle, donc un appel peut être répondu par EINVFN.<br>\n</p></div><br>\n<span class=\"bold\">Valeur de retour : </span>La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">= 0 :</span> Pas d\'erreur, mais le caractère lu<br>\n<span class=\"bold\">0xff1a :</span> Fin de fichier (EOF) reconnue<br>\n<span class=\"bold\">EBADF :</span> Handle de fichier invalide<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Depuis la première version de MultiTOS intégrée MiNT 1.04.<br>\n<br>\n<span class=\"code\">move.w    mode,-(sp)   ; Offset 4<br>\nmove.w    fh,-(sp)     ; Offset 2<br>\nmove.w    #263,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Corriger la pile</span>', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(229, 'Fgetdta', '', '', '<span class=\"bold\">Nom :</span> « Get disk transfer address » - Obtenir l\'adresse de transfert pour les opérations sur disquette.<br>\n<span class=\"bold\">Opcode :</span> 47<br>\n<span class=\"bold\">Syntaxe :</span> DTA *Fgetdta ( void );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fgetdta obtient l\'adresse d\'un tampon pour Fsfirst et Fsnext.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction retourne un pointeur vers l\'adresse du DTA (Disk Transfer Address).<br>\n', '<span class=\"bold\">Disponibilité :</span> Toutes les versions GEMDOS.<br>\n<br>\n<div class=\"border-yellow\"><p>Note : Lorsque qu\'une application démarre, son DTA chevauche la chaîne de ligne de commande dans la basepage du processus. Toute utilisation de Fsfirst ou Fsnext sans avoir d\'abord réalloué un nouveau DTA corrompra la ligne de commande du processus. Pour éviter cela, vous devriez utiliser Fsetdta pour définir une nouvelle structure DTA pour votre processus avant d\'utiliser Fsfirst ou Fsnext. Faites attention à affecter votre DTA à une variable locale ou automatique sans l\'avoir rétabli à sa valeur originale avant que la variable ne sorte de portée.</p></div><br>\n<br>\n<span class=\"code\">move.w    #47,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #2,sp        ; Corriger la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Pointer%=Gemdos(&H2F)</span><br>\n<br>\n', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(230, 'Finstat', '', '', '<span class=\"bold\">Nom :</span> « Finstat » - Déterminer le statut d\'entrée d\'un fichier.<br>\n<span class=\"bold\">Opcode : </span>261<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Finstat ( int16_t fh );<br>\n<span class=\"bold\">Description :</span> La fonction Finstat retourne le nombre maximum de bytes qui peuvent être lus depuis un fichier avec le handle fh sans avoir à attendre.<br>\nSi le nombre de bytes ne peut pas être rapporté exactement, alors la valeur 1 sera retournée.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Note :</span> Dans MagiC, le noyau tente d\'abord d\'implémenter l\'appel dans Fcntl (FIONREAD). Si cette sous-fonction de dev_ioctl n\'existe pas (c\'est-à-dire que le pilote de fichier retourne EINVFN), alors dev_stat sera appelée. Dans ce cas, cela peut seulement donner la déclaration « Caractère disponible » (retour == 1) ou « Aucun caractère disponible » (retour == 0). Les fichiers FAT et les [1link [mémoire partagée][Mémoire partagée]] retournent la longueur du fichier moins la position actuelle. Les tuyaux retournent le nombre de bytes présents dans le bloc.</p></div><br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">= 0 :</span> Pas d\'erreur survenue (nombre de bytes)<br>\n<span class=\"bold\">EBADF : </span>Handle de fichier invalide<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Depuis la première version de MultiTOS intégrée MiNT 1.04, et dans MagiC depuis la version 3.0.<br>\n<br>\n<span class=\"code\">move.w    fh,-(sp)     ; Offset 2<br>\nmove.w    #261,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #4,sp        ; Corriger la pile</span><br>\n', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(231, 'Flink', '', '', '<span class=\"bold\">Nom :</span> « Flink » - Créer un nouveau (hard-)link vers un fichier.<br>\n<span class=\"bold\">Opcode : </span>301<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Flink ( int8_t *oldname, int8_t *newname );<br>\n<span class=\"bold\">Description : </span>La fonction Flink crée un nouveau nom (newname) pour le fichier nommé oldname. Le fichier peut être ensuite adressé sous les deux noms, et la suppression (avec Fdelete) d\'un nom n\'a pas d\'effet sur l\'autre.<br>\n<br>\n<div class=\"border-yellow\"><p>On doit noter que oldname et newname doivent se situer sur le même disque physique, et que tous les systèmes de fichiers ne permettent pas la création de liens.</p></div>', '<span class=\"bold\">Valeur de retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucun erreur survenue<br>\n<span class=\"bold\">EINVFN : </span>Le système de fichiers ne supporte pas les hard links<br>\n<span class=\"bold\">EFILNF :</span> Le fichier oldname n\'existe pas<br>\n<span class=\"bold\">EXDEV :</span> Les fichiers oldname/newname ne se trouvent pas sur le même disque physique<br>\n<span class=\"bold\">ENSAME :</span> Les fichiers oldname/newname ne se trouvent pas sur le même disque physique<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsque un cookie \'MiNT\' avec une version d\'au moins 0.90 existe et dans MagiC depuis la version 3.0.<br>\n<br>\n<span class=\"code\">pea       newname      ; Offset 6<br>\npea       oldname      ; Offset 2<br>\nmove.w    #301,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\nlea       $A(sp),sp    ; Corriger la pile</span>', '', NULL, NULL, NULL, '', '', '', 4, 3, 16);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(232, 'Flock', '', '', '<span class=\"bold\">Nom : </span>« Flock » - Verrouiller ou déverrouiller une partie d\'un fichier.<br>\n<span class=\"bold\">Opcode : </span>92<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Flock ( int16_t handle, int16_t mode, int32_t start, int32_t length );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Flock sert à protéger des portions d\'un fichier contre l\'accès par d\'autres processus. Les paramètres suivants s\'appliquent :<br>\n<br>\nhandle : ID du fichier<br>\nmode :<br>\n0 = Appliquer le verrou<br>\n1 = Retirer le verrou<br>\nstart : Position de départ dans le fichier<br>\nlength : Nombre de bytes affectés<br>\n<br>\n<div class=\"border-red\"><p><span class=\"bold\">Avertissement :</span><br>\nCette fonction est optionnelle, donc l\'appel peut retourner EINVFN. Il est particulièrement important de noter que Flock peut ne pas être disponible sur tous les systèmes de fichiers installés.</p></div><br>\n', '<span class=\"bold\">Valeur de retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK : </span>Aucun erreur survenue<br>\n<span class=\"bold\">ELOCKED :</span> Portion de fichier chevauchante déjà verrouillée<br>\n<span class=\"bold\">ENSLOCK :</span> Verrouillage correspondant non trouvé pour suppression<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Présente uniquement lorsque le cookie _FLK existe.<br>\n<br>\n<span class=\"code\">move.l    length,-(sp)  ; Offset 10<br>\nmove.l    start,-(sp)   ; Offset  6<br>\nmove.w    mode,-(sp)    ; Offset  4<br>\nmove.w    handle,-(sp)  ; Offset  2<br>\nmove.w    #92,-(sp)     ; Offset  0<br>\ntrap      #1            ; GEMDOS<br>\nlea       $E(sp),sp     ; Corriger la pile</span>', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(233, 'Fmidipipe', '', '', '<span class=\"bold\">Nom :</span> « Fmidipipe » - Rediriger l\'entrée/sortie MIDI.<br>\n<span class=\"bold\">Opcode : </span>294<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fmidipipe ( int16_t pid, int16_t in, int16_t out );<br>\n<span class=\"bold\">Description :</span> La fonction Fmidipipe modifie les handles GEMDOS pour l\'entrée et la sortie MIDI pour le processus avec l\'ID pid. Les paramètres in et out décrivent les handles GEMDOS qui prennent l\'entrée et la sortie MIDI respectivement pour le processus.<br>\n<br>\nDans le cas où pid = 0, le processus actuel sera utilisé. Alors, l\'appel de fonction est équivalent aux deux lignes suivantes :<br>\n<span class=\"code\">Fforce (-4, in);<br>\nFforce (-5, out);</span>', '<span class=\"bold\">Valeur de retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK : </span>Aucun erreur survenue<br>\n<span class=\"bold\">EFILNF : </span>Le processus pid n\'a pas été trouvé<br>\n<span class=\"bold\">EACCDN :</span> in/out ne sont pas ouverts pour lecture ou écriture<br>\n<span class=\"bold\">EBADF :</span> in/out n\'est pas un handle valide<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsque un cookie \'MiNT\' avec une version d\'au moins 0.90 existe.<br>\n<br>\n<span class=\"code\">move.w    out,-(sp)    ; Offset 6<br>\nmove.w    in,-(sp)     ; Offset 4<br>\nmove.w    pid,-(sp)    ; Offset 2<br>\nmove.w    #294,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Corriger la pile</span>', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(234, 'Fopen', '', '', '<span class=\"bold\">Nom :</span> « File open » - Ouvrir un fichier donné.<br>\n<span class=\"bold\">Opcode :</span> 61<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fopen ( const int8_t *fname, int16_t mode );<br>\n<span class=\"bold\">Description : </span>La routine GEMDOS Fopen est utilisée pour ouvrir les fichiers spécifiés. Les paramètres sont les suivants :<br>\n<span class=\"bold\">fname :</span> Nom du fichier à ouvrir.<br>\n<span class=\"bold\">mode :</span> Mode d\'ouverture, sous forme de vecteur de bits.<br>\n<span class=\"bold\">Vecteur de Bits pour le Mode :<br>\n</span><br>\n     Bits 0-2 (Mode d\'Accès) :<br>\n          0 = Lecture seule<br>\n          1 = Écriture seule<br>\n          2 = Lecture et écriture<br>\n     Bit 3 (Réservé) : Doit être défini à 0.<br>\n     Bits 4-6 (Mode de Partage) :<br>\n          0 = Mode compatibilité (utilisé par les programmes ne connaissant pas les extensions réseau). Si le bit de lecture seule du fichier est défini, cela équivaut à interdire l\'écriture ; sinon, cela équivaut à interdire la lecture/écriture.<br>\n          1 = Lecture et écriture interdites (le fichier ne peut pas être ouvert une seconde fois)<br>\n          2 = Écriture interdite (le fichier ne peut être réouvert que pour la lecture)<br>\n          3 = Lecture interdite (le fichier ne peut être réouvert que pour l\'écriture)<br>\n          4 = Tout est permis<br>\n     Bit 7 (Drapeau d\'Héritage) : Détermine si un enfant lancé par un processus hérite des descripteurs de fichiers ouverts et bénéficie des mêmes accès que le parent. Si ce drapeau est défini, l\'enfant doit rouvrir les fichiers qu\'il souhaite utiliser et doit respecter les mêmes restrictions de partage que les autres processus.', '<span class=\"bold\">Modes Additionnels (MiNT et MagiC) :</span><br>\n0x080 : Réservé pour MiNT<br>\n0x100 : Ne pas bloquer le fichier pour les opérations d\'E/S<br>\n0x200 : Créer le fichier, s\'il n\'existe pas<br>\n0x400 : Mettre le fichier existant à une longueur nulle<br>\n0x800 : Ne pas ouvrir le fichier existant<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :<br>\n</span>Les numéros de canal standard (0-3) sont prévus pour le clavier, l\'écran, le port série et le port parallèle.<br>\nLes fichiers ouverts via des liens symboliques sont automatiquement résolus ; le fichier référencé sera ouvert ou, selon le mode, tronqué à une longueur nulle.<br>\nValeur de Retour : La fonction retourne le descripteur de fichier correspondant dans le lower WORD d\'un LONG positif, ou un code d\'erreur négatif.</p></div><br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    mode,-(sp)   ; Offset 6<br>\npea       fname        ; Offset 2<br>\nmove.w    #61,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Ajuster la pile</span><br>\n<br>\nGFA-Basic :<br>\n<span class=\"code\"> Handle%=Gemdos(&H3D,L:fname%,W:mode%)</span>', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(235, 'Foutstat', '', '', '<span class=\"bold\">Nom :</span> « Foutstat » - Déterminer l\'état de sortie d\'un fichier.<br>\n<span class=\"bold\">Opcode :</span> 262<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Foutstat ( int16_t fh );<br>\n<span class=\"bold\">Description :</span> La fonction Foutstat retourne le nombre d\'octets qui peuvent être écrits dans le fichier avec le descripteur fh sans bloquer le processus correspondant.<br>\nSi le nombre exact d\'octets ne peut être spécifié, la valeur 1 sera retournée.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nDans MagiC, le noyau tente d\'abord de mettre en œuvre l\'appel dans Fcntl (FIONWRITE). Si cette sous-fonction de dev_ioctl n\'existe pas (c\'est-à-dire que le pilote de fichiers retourne EINVFN), alors dev_stat sera appelé. Dans ce cas, cela peut seulement résulter en la déclaration « Un caractère peut être écrit » (retour == 1) ou « Aucun caractère ne peut être écrit » (retour == 0). Les fichiers FAT retournent toujours la valeur 1, la mémoire partagée retourne la longueur actuelle du fichier moins la position courante. Les tuyaux retournent le nombre d\'octets encore libres dans le bloc.</p></div>', '<span class=\"bold\">Valeur de Retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">= 0 :</span> Pas d\'erreur (nombre d\'octets)<br>\n<span class=\"bold\">EBADF : </span>Descripteur de fichier invalide.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nActuellement, cette fonction retourne toujours 1 pour les fichiers disques.</p></div><br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Depuis la première version MiNT intégrée dans MultiTOS 1.04, et dans MagiC depuis la Version 3.0.<br>\n<br>\n<span class=\"code\">move.w    fh,-(sp)     ; Offset 2<br>\nmove.w    #262,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #4,sp        ; Ajuster la pile</span>', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(236, 'Fpipe', '', '', '<span class=\"bold\">Nom :</span> « Fpipe » - Créer un tuyau.<br>\n<span class=\"bold\">Opcode :</span> 256<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fpipe ( int16_t usrh[2] );<br>\n<span class=\"bold\">Description :</span> La fonction Fpipe crée un tuyau qui peut être utilisé pour la communication inter-processus (IPC). Il est normalement utilisé par les shells qui souhaitent rediriger l\'entrée et la sortie de leurs processus enfants ; avant de lancer le processus enfant, le shell redirige son entrée et sa sortie (si nécessaire) vers les extrémités de lecture et d\'écriture du fichier nouvellement créé. En cas de succès, deux descripteurs GEMDOS seront retournés dans usrh.<br>\n<br>\nusrh[0] désigne le descripteur pour l\'extrémité de lecture du tuyau (lecture seule), tandis que usrh[1] est le descripteur pour l\'extrémité d\'écriture du tuyau (écriture seule).<br>\n<br>\nLe tuyau ainsi créé sera placé dans le répertoire U:\\PIPE en tant que pseudo-fichier et sera nommé sys$pipe.xxx, où xxx représente un entier à trois chiffres.<br>\n', '<span class=\"bold\">Valeur de Retour : </span>La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucune erreur survenue<br>\n<span class=\"bold\">ENHNDL : </span>Pas assez de descripteurs libres<br>\n<span class=\"bold\">EACCDN : </span>Pas de tuyau libre (maximum de 999 disponibles)<br>\n<span class=\"bold\">ENSMEM : </span>Mémoire insuffisante pour créer le tuyau<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsqu\'un cookie \'MiNT\' avec une version d\'au moins 0.90 est présent, et dans MagiC depuis la Version 3.0.<br>\n<br>\n<span class=\"code\">pea       usrh         ; Offset 2<br>\nmove.w    #256,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Ajuster la pile</span>', '', NULL, NULL, NULL, '', '', '', 4, 3, 16),
(237, 'Fpoll', '', '', 'Nom : « Fpoll » - Enquête sur l\'état des fichiers avec délai d\'attente.<br>\nOpcode : 346<br>\nSyntaxe : int32_t Fpoll (POLLFD *fds, uint32_t nfds, uint32_t timeout );<br>\nDescription : Fpoll() effectue une tâche similaire à Fselect : il attend qu\'un des descripteurs de fichiers d\'un ensemble devienne prêt pour effectuer des opérations d\'E/S.<br>\nL\'ensemble des descripteurs de fichiers à surveiller est spécifié dans le paramètre fds, qui est un tableau de structures de la forme suivante :<br>\n<br>\n<span class=\"code\">typedef struct pollfd<br>\n{<br>\n    int32_t  fd;            /* descripteur de fichier */<br>\n    uint16_t events;        /* événements demandés */<br>\n    uint16_t revents;       /* événements retournés */<br>\n} POLLFD;</span><br>\nL\'appelant doit spécifier le nombre d\'éléments dans le tableau fds dans nfds.<br>\n<br>\nLe champ fd contient un descripteur de fichier pour un fichier ouvert. Si ce champ est négatif, le champ events correspondant est ignoré et le champ revents retourne zéro. (Cela permet d\'ignorer facilement un descripteur de fichier pour un appel poll() : il suffit de négativer le champ fd.)<br>\n<br>\nLe champ events est un paramètre d\'entrée, un masque de bits spécifiant les événements pour lesquels l\'application est intéressée pour le descripteur de fichier fd. Si ce champ est spécifié comme zéro, tous les événements sont ignorés pour fd et revents retourne zéro.<br>\n<br>\nLe champ revents est un paramètre de sortie, rempli par le noyau avec les événements qui se sont effectivement produits. Les bits retournés dans revents peuvent inclure ceux spécifiés dans events, ou l\'une des valeurs POLLERR, POLLHUP, ou POLLNVAL. (Ces trois bits sont sans signification dans le champ events et seront définis dans le champ revents chaque fois que la condition correspondante est vraie.)<br>\n<br>\nSi aucun des événements demandés (et aucune erreur) ne s\'est produit pour aucun des descripteurs de fichiers, poll() bloque jusqu\'à ce qu\'un des événements se produise.<br>\n<br>\nLe paramètre timeout spécifie le nombre minimum de millisecondes pendant lesquelles poll() bloquera. (Cet intervalle sera arrondi à la granularité de l\'horloge système, et les délais de planification du noyau peuvent entraîner un dépassement de l\'intervalle de blocage par une petite quantité.) Spécifier une valeur négative pour timeout signifie un délai d\'attente infini. Spécifier un délai d\'attente de zéro entraîne le retour immédiat de poll(), même si aucun descripteur de fichier n\'est prêt.', 'Les bits pouvant être définis/retournés dans events et revents sont définis dans <poll.h> :<br>\n<span class=\"bold\">POLLIN : </span>Des données à lire.<br>\n<span class=\"bold\">POLLPRI :</span> Données urgentes à lire (par exemple, données hors bande sur une socket TCP ; maître du pseudo-terminal en mode paquet a vu un changement d\'état dans l\'esclave).<br>\n<span class=\"bold\">POLLOUT :</span> Écrire maintenant ne bloquera pas.<br>\n<span class=\"bold\">POLLRDHUP :</span> Le pair de socket de flux a fermé la connexion ou a arrêté d\'écrire dans la moitié de la connexion. La macro de test de fonctionnalité _GNU_SOURCE doit être définie (avant d\'inclure tout fichier d\'en-tête) pour obtenir cette définition.<br>\n<span class=\"bold\">POLLERR :</span> Condition d\'erreur (sortie seulement).<br>\n<span class=\"bold\">POLLHUP :</span> Coupure (sortie seulement).<br>\n<span class=\"bold\">POLLNVAL :</span> Requête invalide : fd non ouvert (sortie seulement).<br>\n<br>\nLors de la compilation avec _XOPEN_SOURCE défini, on a également les valeurs suivantes, qui ne transmettent pas d\'informations supplémentaires au-delà des bits listés ci-dessus :<br>\n<br>\n<span class=\"bold\">POLLRDNORM :</span> Équivalent à POLLIN.<br>\n<span class=\"bold\">POLLRDBAND :</span> Données de bande de priorité peuvent être lues (généralement inutilisé sur MiNT).<br>\n<span class=\"bold\">POLLWRNORM :</span> Équivalent à POLLOUT.<br>\n<span class=\"bold\">POLLWRBAND :</span> Les données de priorité peuvent être écrites.<br>\nMiNT(Lib) connaît également POLLMSG, mais ne l\'utilise pas.<br>\n<br>\n<span class=\"bold\">Valeur de Retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">0 :</span> L\'appel a expiré et aucun descripteur de fichier n\'était prêt.<br>\n<span class=\"bold\">>0 : </span>Le nombre de structures ayant des champs revents non nuls (en d\'autres termes, ceux pour lesquels des événements ou des erreurs ont été signalés).<br>\n<span class=\"bold\">EBADF :</span> Au moins un des descripteurs n\'est pas assigné à un fichier ouvert.<br>\n<span class=\"bold\">EFAULT :</span> Le tableau donné en argument n\'était pas contenu dans l\'espace d\'adresses du programme appelant.<br>\n<span class=\"bold\">EINTR :</span> Un signal est survenu avant tout événement demandé ; voir Psignal.<br>\n<span class=\"bold\">EINVAL : </span>La valeur nfds dépasse la valeur de RLIMIT_NOFILE.<br>\n<span class=\"bold\">ENOMEM : </span>Il n\'y avait pas d\'espace pour allouer les tables de descripteurs de fichiers.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Cette fonction est disponible depuis FreeMiNT 1.15.12.<br>\n<br>\n<span class=\"code\">move.l    timeout,-(sp)  ; Offset  10<br>\nmove.l    nfds,-(sp)     ; Offset  6<br>\npea       fds            ; Offset  2<br>\nmove.w    #346,-(sp)     ; Offset  0<br>\ntrap      #1             ; GEMDOS<br>\nlea       14(sp),sp      ; Ajuster la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(238, 'Fputchar', '', '', '<span class=\"bold\">Nom : </span>« Fputchar » - Écrire un caractère dans un fichier donné.<br>\n<span class=\"bold\">Opcode : </span>264<br>\n<span class=\"bold\">Syntaxe : </span>int32_t Fputchar ( int16_t fh, int32_t ch, int16_t mode );<br>\n<span class=\"bold\">Description :</span> La fonction Fputchar écrit un caractère dans le fichier identifié par le descripteur fh. Le paramètre mode est significatif uniquement si le fichier est un (pseudo-)terminal :<br>\n<span class=\"bold\">Mode :</span><br>\n0 : Mode brut<br>\nAucun traitement des caractères de contrôle n\'est effectué.<br>\n1 : Mode cuit<br>\nLes caractères de contrôle spéciaux (Control-C, Control-Z) seront recherchés et interprétés si nécessaire ; cela inclut également le contrôle de flux (Control-S, Control-Q).<br>\nSi le fichier est un (pseudo-)terminal, les 4 octets peuvent être transmis. Cela permet de transmettre des codes de scannage BIOS simulés et des messages d\'état Shift. Sinon, seul le bas de l\'octet de ch sera transmis.<br>\n', '<span class=\"bold\">Valeur de Retour :</span> La fonction peut retourner les valeurs suivantes :<br>\n4 : Nombre d\'octets écrits, si le fichier est un terminal.<br>\n1 : Écriture réussie, mais le fichier n\'est pas un terminal.<br>\n0 : Les octets n\'ont pas pu être écrits (peut-être en raison du contrôle de flux).<br>\nEBADF : Descripteur de fichier invalide.<br>\nCode d\'erreur BIOS négatif en cas d\'erreur d\'E/S.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Disponible depuis la première version MiNT intégrée dans MultiTOS 1.04.<br>\n<br>\n<span class=\"code\">move.w    mode,-(sp)   ; Offset 8<br>\nmove.l    ch,-(sp)     ; Offset 4<br>\nmove.w    fh,-(sp)     ; Offset 2<br>\nmove.w    #264,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\nlea       $A(sp),sp    ; Ajuster la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(239, 'Fread', '', '', '<span class=\"bold\">Nom :</span> « Fread » - Lire à partir d\'un fichier.<br>\n<span class=\"bold\">Opcode : </span>63<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fread ( int16_t handle, int32_t count, void *buf );<br>\n<span class=\"bold\">Description : </span>La routine GEMDOS Fread lit un nombre donné d\'octets à partir d\'un fichier. Les paramètres sont les suivants :<br>\n<span class=\"bold\">handle : </span>Identifiant du descripteur de fichier.<br>\n<span class=\"bold\">count :</span> Nombre d\'octets de données à lire.<br>\n<span class=\"bold\">buf :</span> Adresse du tampon de réception (d\'une taille d\'au moins count octets).<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nDans toutes les versions GEMDOS < 0.15, le système se fige si le paramètre count est égal à 0. Lors de la lecture depuis des canaux standard, un maximum de 16383 caractères peut être lu.</p></div><br>\n', '<span class=\"bold\">Valeur de Retour :</span> La fonction retourne soit un nombre positif indiquant le nombre d\'octets effectivement lus, ce qui peut être inférieur à count si une fin de fichier (EOF) a été rencontrée, ou un code d\'erreur GEMDOS négatif :<br>\n<span class=\"bold\">EBADF : </span>Descripteur de fichier incorrect.<br>\n<span class=\"bold\">ELOCKED : </span>Segment de fichier marqué comme verrouillé.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions GEMDOS.<br>\n<br>\n<span class=\"code\">pea       buf           ; Offset 8<br>\nmove.l    count,-(sp)   ; Offset 4<br>\nmove.w    handle,-(sp)  ; Offset 2<br>\nmove.w    #63,-(sp)     ; Offset 0<br>\ntrap      #1            ; GEMDOS<br>\nlea       $C(sp),sp     ; Ajuster la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Fehler%=Gemdos(&H3F,W:handle%,L:count%,L:buf%)</span><br>\n', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(240, 'Freadlink', '', '', '<span class=\"bold\">Nom : </span>« Freadlink » - Suivre un lien symbolique.<br>\n<span class=\"bold\">Opcode :</span> 303<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Freadlink ( int16_t bufsiz, int8_t *buf, int8_t *name );<br>\n<span class=\"bold\">Description :</span> La fonction Freadlink détermine le nom de fichier du lien symbolique name. Ce nom est celui spécifié pour le premier paramètre de Fsymlink.<br>\n<br>\nLe nom est stocké dans le tampon buf, qui doit avoir une longueur de bufsiz caractères.<br>\n', '<br>\n<span class=\"bold\">Valeur de Retour :</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">E_OK : </span>Aucune erreur survenue.<br>\n<span class=\"bold\">EINVFN :</span> Le système de fichiers du nom ne permet pas de liens symboliques.<br>\n<span class=\"bold\">EFILNF :</span> Le nom du lien symbolique n\'a pas été trouvé.<br>\n<span class=\"bold\">EACCDN :</span> Le nom n\'est pas un lien symbolique.<br>\n<span class=\"bold\">ERANGE : </span>Le tampon buf est trop petit pour le nom de fichier à déterminer.<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsque le cookie \'MiNT\' avec une version d\'au moins 0.90 est présent et dans MagiC depuis la Version 3.0.<br>\n<br>\n<span class=\"code\">pea       Name          ; Offset 10<br>\npea       buf           ; Offset 6<br>\nmove.w    bufsiz,-(sp)  ; Offset 2<br>\nmove.w    #303,-(sp)    ; Offset 0<br>\ntrap      #1            ; GEMDOS<br>\nlea       $C(sp),sp     ; Ajuster la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(241, 'Frename', '', '', '<span class=\"bold\">Nom :</span> « Frename » - Renommer un fichier GEMDOS.<br>\n<span class=\"bold\">Opcode :</span> 86<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Frename ( const int8_t *oldname, const int8_t *newname );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Frename permet de renommer des fichiers. Le nouveau nom peut également contenir un chemin d\'accès complet dans le lecteur physique concerné ; dans ce cas, le fichier sera déplacé. Les paramètres sont les suivants :<br>\n<span class=\"bold\">oldname :</span> Pointeur vers le nom actuel.<br>\n<span class=\"bold\">newname :</span> Pointeur vers le nouveau nom.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nDepuis la version GEMDOS 0.15, il est possible de modifier les noms des répertoires également. Cependant, ceux-ci ne peuvent pas être déplacés. Il est recommandé d\'éviter de renommer les fichiers qui sont déjà ouverts.</p></div><br>\n<br>\n<div class=\"border-yellow\"><p>Remarque sur MagiC : <br>\nIl appartient au XFS de décider si les répertoires peuvent être renommés ou déplacés. Le DOS-XFS intégré ne permet de déplacer les répertoires qu\'à partir de MagiC 5.</p></div>', '<span class=\"bold\">Valeur de Retour :</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK :</span> Aucune erreur survenue.<br>\n<span class=\"bold\">EPTHNF : </span>Répertoire non trouvé.<br>\n<span class=\"bold\">EACCDN : </span>Accès refusé (protégé en écriture).<br>\n<span class=\"bold\">ENSAME :</span> Destination non sur le même lecteur.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Toutes les versions GEMDOS.<br>\n<br>\n<span class=\"code\">pea       newname      ; Offset 8<br>\npea       oldname      ; Offset 4<br>\nmove.w    #0,-(sp)     ; Offset 2<br>\nmove.w    #86,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\nlea       $C(sp),sp    ; Ajuster la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Fehler%=Gemdos(&H56,W:0,L:oldname%,L:newname%)</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(242, 'Fseek', '', '', '<span class=\"bold\">Nom :</span> « Fseek » - Déplacer le pointeur de position du fichier.<br>\n<span class=\"bold\">Opcode :</span> 66<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Fseek ( int32_t offset, int16_t handle, int16_t seekmode );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fseek permet de déplacer le pointeur de fichier à une nouvelle position dans un fichier. Les paramètres sont les suivants :<br>\n<span class=\"bold\">offset :</span> Nombre d\'octets à sauter.<br>\n<span class=\"bold\">handle :</span> Descripteur de fichier GEMDOS.<br>\n<span class=\"bold\">seekmode :</span> Type de repositionnement :<br>\n0 = Depuis le début du fichier.<br>\n1 = Depuis la position actuelle.<br>\n2 = Depuis la fin du fichier.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque :</span><br>\nAppliquée aux tuyaux, la fonction retourne la valeur EACCDN ; cela permet aux applications de différencier entre les périphériques et les tuyaux.</p></div>', '<span class=\"bold\">Valeur de Retour : </span>La fonction retourne une valeur positive indiquant la nouvelle position absolue du pointeur de fichier depuis le début du fichier, ou un message d\'erreur négatif.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    seekmode,-(sp)  ; Offset 8<br>\nmove.w    handle,-(sp)    ; Offset 6<br>\nmove.l    offset,-(sp)    ; Offset 2<br>\nmove.w    #66,-(sp)       ; Offset 0<br>\ntrap      #1              ; GEMDOS<br>\nlea       $A(sp),sp       ; Ajuster la pile</span><br>\n<br>\nGFA-Basic : <br>\n<span class=\"code\">Fehler%=Gemdos(&H42,L:offset%,W:handle%,W:seekmode%)</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(243, 'Fseek64', '', '', '<span class=\"bold\">Nom :</span> « Fseek64 » - Déplacer le pointeur de position du fichier en 64 bits.<br>\n<span class=\"bold\">Opcode :</span> 332 (0x014c)<br>\n<span class=\"bold\">Syntaxe : </span>int32_t Fseek64 ( int32_t hioffset, uint32_t lowoffset, int16_t handle, int16_t seekmode, int64_t *newpos );<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Fseek64 permet de déplacer le pointeur de fichier à une nouvelle position dans un fichier en utilisant un nombre de 64 bits. Les paramètres sont les suivants :<br>\n<span class=\"bold\">hioffset : </span>32 bits supérieurs du nombre de 64 bits d\'octets à sauter.<br>\n<span class=\"bold\">lowoffset :</span> 32 bits inférieurs du nombre de 64 bits d\'octets à sauter.<br>\n<span class=\"bold\">handle :</span> Descripteur de fichier GEMDOS.<br>\n<span class=\"bold\">seekmode : </span>Type de repositionnement :<br>\n0 = Depuis le début du fichier.<br>\n1 = Depuis la position actuelle.<br>\n2 = Depuis la fin du fichier.<br>\n<span class=\"bold\">newpos :</span> La valeur 64 bits pointée par newpos est définie à la nouvelle position si elle est réussie.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque : </span><br>\nActuellement, Fseek64() est uniquement un wrapper autour de Fseek() car il n\'y a pas de support XFS/XDD 64 bits. Si l\'offset spécifié est supérieur à 2147483647L (2^31-1), l\'appel échoue et retourne EBADARG.</p></div>', '<span class=\"bold\">Valeur de Retour :</span> La fonction retourne une valeur positive indiquant la nouvelle position absolue du pointeur de fichier depuis le début du fichier, ou un message d\'erreur négatif.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Cette fonction est disponible depuis FreeMiNT 1.15.10.<br>\n<br>\n<span class=\"code\">pea       newpos          ; Offset 14<br>\nmove.w    seekmode,-(sp)  ; Offset 12<br>\nmove.w    handle,-(sp)    ; Offset 10<br>\nmove.l    lowoffset,-(sp) ; Offset 6<br>\nmove.l    hioffset,-(sp)  ; Offset 2<br>\nmove.w    #332,-(sp)      ; Offset 0<br>\ntrap      #1              ; GEMDOS<br>\nlea       $12(sp),sp      ; Ajuster la pile</span><br>\n<br>\nGFA-Basic : <span class=\"code\">Fehler%=Gemdos(&H14C,L:hioffset%,L:lowoffset%,W:handle%,W:seekmode%,L:newpos%)</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(244, 'Fselect', '', '', '<span class=\"bold\">Nom: </span>Fselect - Interrogation de l\'état du fichier avec délai d\'attente.<br>\n<span class=\"bold\">Opcode:</span> 285<br>\n<span class=\"bold\">Syntaxe:</span> int32_t Fselect ( uint16_t timeout, int32_t *rfds, int32_t *wfds, ((int32_t) 0) );<br>\n<span class=\"bold\">Description: </span>La fonction Fselect vérifie quels fichiers ouverts sont prêts pour la lecture ou l\'écriture. Le paramètre rfds pointe vers un bitmap LONG qui décrit l\'ensemble des descripteurs de fichiers GEMDOS à attendre pour la lecture.<br>\n<br>\nDans ce mot long, le bit n est activé lorsque le descripteur de fichier n doit être vérifié pour l\'entrée. Un ensemble vide peut également être représenté optionnellement par un pointeur NULL.<br>\n<br>\nDe la même manière, wfds pointe vers un ensemble de descripteurs de fichiers à vérifier pour l\'état de sortie.<br>\n<br>\nAu retour de la fonction, les descripteurs des fichiers qui sont prêts pour la lecture ou l\'écriture sont passés dans rfds et wfds.<br>\n<br>\n<div class=\"border-yellow\"><p>Notez que actuellement, le seul périphérique BIOS avec lequel Fselect fonctionne est le clavier.</p></div>', 'Avec timeout, on peut spécifier combien de millisecondes il faut attendre avant que la fonction ne retourne. Une valeur de 0 signifie que la fonction attend jusqu\'à ce que l\'un des fichiers spécifiés soit prêt pour la lecture ou l\'écriture.<br>\n<br>\n<div class=\"border-green\"><p><span class=\"bold\">Exemple:</span><br>\nFselect (0, 0L, 0L, 0L) attend indéfiniment.<br>\nFselect (1, 0L, 0L, 0L) attend une milliseconde.</p></div><br>\n<br>\n<span class=\"bold\">Valeur de retour:</span> La fonction peut retourner les résultats suivants :<br>\n<span class=\"bold\">0 : </span>Dans le temps spécifié, aucun fichier n\'était prêt pour la lecture ou l\'écriture (délai dépassé).<br>\n<span class=\"bold\">>0 : </span>Somme des bits définis de rfds et wfds.<br>\n<span class=\"bold\">EBADF :</span> Au moins un des descripteurs n\'est pas attribué à un fichier ouvert.<br>\n<br>\n<span class=\"bold\">Disponibilité:</span> À partir de la première version de MiNT intégrée dans MultiTOS (1.04) et MagiC à partir de la version 3.00.<br>\n<br>\n<span class=\"code\">move.l    dummy,-(sp)    ; Offset 12<br>\npea       wfds           ; Offset  8<br>\npea       rfds           ; Offset  4<br>\nmove.w    timeout,-(sp)  ; Offset  2<br>\nmove.w    #285,-(sp)     ; Offset  0<br>\ntrap      #1             ; GEMDOS<br>\nlea       $10(sp),sp     ; Correction de la pile</span>', '', NULL, NULL, NULL, '', '', '', 5, 3, 16),
(245, 'Fsetdta', '', '', '<span class=\"bold\">Nom:</span> Set disk transfer address - Définir l\'adresse pour la région de transfert pour les opérations de disquette.<br>\n<span class=\"bold\">Opcode: </span>26<br>\n<span class=\"bold\">Syntaxe: </span>void Fsetdta ( DTA *buf );<br>\n<span class=\"bold\">Description:</span> La routine GEMDOS Fsetdta définit l\'adresse du segment mémoire qui sera utilisé comme nouvelle DTA. Le paramètre buf est un pointeur vers cette structure.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque:<br>\n</span>Au lancement du programme, la DTA sera établie à partir du décalage 0x80 dans la basepage.</p></div>', '<span class=\"bold\">Valeur de retour: </span>La fonction ne retourne pas de résultat.<br>\n<br>\n<span class=\"bold\">Disponibilité: </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">pea       buf          ; Offset 2<br>\nmove.w    #26,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&H1A,L:buf%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(246, 'Fsfirst', '', '', '<span class=\"bold\">Nom: </span>search first file - Recherche de la première entrée de fichier.<br>\n<span class=\"bold\">Opcode:</span> 78<br>\n<span class=\"bold\">Syntaxe: </span>int32_t Fsfirst ( const int8_t *filename, int16_t attr );<br>\n<span class=\"bold\">Description: </span>La routine GEMDOS Fsfirst permet d\'obtenir des informations sur la première occurrence d\'un fichier ou d\'un sous-répertoire. Les paramètres suivants s\'appliquent :<br>\n<span class=\"bold\">filename: </span>Pointeur vers le nom de fichier ou de sous-répertoire.<br>\n<span class=\"color-red\">attr: </span>Attributs qui doivent être correspondus par le fichier recherché.<br>\n<span class=\"bold\">Bit-0: </span>Inclure les fichiers en lecture seule.<br>\n<span class=\"bold\">Bit-1:</span> Inclure les fichiers cachés.<br>\n<span class=\"bold\">Bit-2:</span> Inclure les fichiers système.<br>\n<span class=\"bold\">Bit-3:</span> Inclure les étiquettes de volume.<br>\n<span class=\"bold\">Bit-4: </span>Inclure les sous-répertoires.<br>\n<span class=\"bold\">Bit-5:</span> Inclure les fichiers avec le bit d\'archive activé.<br>\n<br>\nLe nom de fichier ou le chemin peut également contenir les jokers \'*\' et \'?\'. À la fin de la fonction, l\'entrée du répertoire remplira la zone de transfert de disque (DTA), dont l\'emplacement peut être obtenu ou défini avec Fgetdta et Fsetdta respectivement. Les informations nécessaires peuvent ensuite être obtenues à partir de la structure DTA.<br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarque: </span><br>\nSi le programme s\'exécute dans le domaine MiNT, Fsfirst retournera des noms de fichiers en minuscules. Étant donné que des systèmes de fichiers existent qui sont sensibles à la casse, vous devriez éviter de faire de telles conversions manuellement. Cependant, si vous avez absolument besoin de noms de fichiers en majuscules, vous devriez utiliser Pdomain pour que votre programme s\'exécute dans le domaine TOS.</p></div><br>\n<br>\n<div class=\"border-yellow\"><p><span class=\"bold\">Remarques sur MagiC:</span> <br>\nSi le bit 3 de attr est défini, le noyau appellera la fonction xfs_rlabel. Le programme utilisateur appelant ne peut malheureusement plus obtenir la date et l\'heure du nom du disque sous MagiC avec ceci. Le noyau définit tous les champs à 0 et la fonction Fsnext ne peut pas être exécutée. À partir de MagiC 3, la fonction Dreadlabel est utilisée à la place, qui gère également les noms de fichiers longs.</p></div>', '<div class=\"border-yellow\"><p></p></div>Si le bit 3 de attr n\'est pas défini, une recherche de fichiers est effectuée comme dans TOS. Si un fichier est un lien symbolique, le noyau DOS appelle la fonction Fxattr pour suivre le lien. Les valeurs retournées par Fxattr sont ensuite copiées dans la DTA.<br>\n<br>\n<div class=\"border-red\"><p><span class=\"bold\">Avertissement: </span><br>\nMagiC n\'est pas toujours capable d\'évaluer correctement les liens symboliques relatifs pendant Fsfirst/Fsnext. Il existe trois façons de surmonter cela :<br>\n(a) Meilleur: utiliser Dxreaddir<br>\n(b) Utiliser uniquement des liens symboliques absolus<br>\n(c) Toujours rendre le répertoire de recherche le répertoire actuel</p></div><br>\n<br>\nBien que MiNT gère correctement ce cas, cela a un coût énorme. Le concept Fsfirst/Fsnext est fondamentalement obsolète, inefficace et peu sûr, et devrait être évité à la fois dans MiNT et dans MagiC.<br>\n<br>\n<span class=\"bold\">Valeur de retour: </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EFILNF:</span> Fichier introuvable.<br>\n<span class=\"bold\">ENMFIL: </span>Plus de fichiers.<br>\n<br>\n<span class=\"bold\">Disponibilité: </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    attr,-(sp)   ; Offset 6<br>\npea       filename     ; Offset 2<br>\nmove.w    #78,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&H4E,L:filename%,W:attr%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(247, 'Fsnext', '', '', '<span class=\"bold\">Nom: </span>search next file - Recherche de la prochaine entrée de fichier.<br>\n<span class=\"bold\">Opcode: </span>79<br>\n<span class=\"bold\">Syntaxe:</span> int16_t Fsnext ( void );<br>\n<span class=\"bold\">Description:</span> La routine GEMDOS Fsnext recherche la prochaine entrée de fichier qui correspond aux critères spécifiés dans Fsfirst. Elle doit être appelée aussi souvent que nécessaire après un appel à Fsfirst pour récupérer toutes les occurrences possibles du fichier. Comme pour Fsfirst, les informations sont retournées dans la DTA.', '<span class=\"bold\">Valeur de retour: </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">ENMFIL:</span> Plus de fichiers.<br>\n<br>\n<span class=\"bold\">Disponibilité: </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    #79,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #2,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&H4F)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(248, 'Fsmkdir', '', '', '<span class=\"bold\">Nom: </span>make directory - Créer un répertoire.<br>\n<span class=\"bold\">Opcode:</span> 39<br>\n<span class=\"bold\">Syntaxe:</span> int16_t Fsmkdir ( const int8_t *path );<br>\n<span class=\"bold\">Description:</span> La routine GEMDOS Fsmkdir crée un répertoire. Le paramètre path est un pointeur vers le chemin du nouveau répertoire.<br>\n<br>\n<span class=\"bold\">Valeur de retour: </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EACCDN: </span>Accès refusé.<br>\n<span class=\"bold\">EPTHNF: </span>Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL:</span> Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM:</span> Pas assez de mémoire.', '<span class=\"bold\">Disponibilité:</span> Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">pea       path         ; Offset 2<br>\nmove.w    #39,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic:<br>\n<span class=\"code\">Fehler%=Gemdos(&H27,L:path%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(249, 'Fsnext', '', '', '<span class=\"bold\">Nom:</span> remove directory - Supprimer un répertoire.<br>\n<span class=\"bold\">Opcode: </span>40<br>\n<span class=\"bold\">Syntaxe: </span>int16_t Fsrmdir ( const int8_t *path );<br>\n<span class=\"bold\">Description: </span>La routine GEMDOS Fsrmdir supprime un répertoire. Le paramètre path est un pointeur vers le chemin du répertoire à supprimer.<br>\n<br>\n<span class=\"bold\">Valeur de retour: </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EACCDN:</span> Accès refusé.<br>\n<span class=\"bold\">EPTHNF:</span> Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL: </span>Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM:</span> Pas assez de mémoire.<br>\n', '<span class=\"bold\">Disponibilité: </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">pea       path         ; Offset 2<br>\nmove.w    #40,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&H28,L:path%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(250, 'Fgetdta', '', '', '<span class=\"bold\">Nom:</span> get disk transfer address - Obtenir l\'adresse du segment de transfert de disque.<br>\n<span class=\"bold\">Opcode: </span>31<br>\n<span class=\"bold\">Syntaxe:</span> DTA *Fgetdta ( void );<br>\n<span class=\"bold\">Description:</span> La routine GEMDOS Fgetdta retourne un pointeur vers la DTA actuelle.<br>\n<br>\n<span class=\"bold\">Valeur de retour:</span> La fonction retourne un pointeur vers la DTA actuelle.', '<span class=\"bold\">Disponibilité: </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    #31,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #2,sp        ; Correction de la pile<br>\nmove.l    d0,DTAptr    ; Adresse de retour de la DTA</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Gemdos(&H1F)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(251, 'Frename', '', '', '<span class=\"bold\">Nom: </span>rename file - Renommer un fichier.<br>\n<span class=\"bold\">Opcode: </span>56<br>\n<span class=\"bold\">Syntaxe: </span>int16_t Frename ( const int8_t *oldname, const int8_t *newname );<br>\n<span class=\"bold\">Description: </span>La routine GEMDOS Frename renomme un fichier ou un répertoire. Les paramètres oldname et newname sont des pointeurs vers les noms de chemin actuels et nouveaux, respectivement.<br>\n<br>\n<span class=\"bold\">Valeur de retour:</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EACCDN:</span> Accès refusé.<br>\n<span class=\"bold\">EPTHNF:</span> Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL: </span>Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM: </span>Pas assez de mémoire.', '<span class=\"bold\">Disponibilité:</span> Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">pea       newname      ; Offset 4<br>\npea       oldname      ; Offset 2<br>\nmove.w    #56,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&H38,L:oldname%,L:newname%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(252, 'Fdelete', '', '', '<span class=\"bold\">Nom: </span>delete file - Supprimer un fichier.<br>\n<span class=\"bold\">Opcode:</span> 52<br>\n<span class=\"bold\">Syntaxe: </span>int16_t Fdelete ( const int8_t *path );<br>\n<span class=\"bold\">Description: </span>La routine GEMDOS Fdelete supprime un fichier. Le paramètre path est un pointeur vers le chemin du fichier à supprimer.<br>\n<br>\n<span class=\"bold\">Valeur de retour: </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK: </span>Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EACCDN: </span>Accès refusé.<br>\n<span class=\"bold\">EPTHNF: </span>Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL: </span>Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM: </span>Pas assez de mémoire.', '<span class=\"bold\">Disponibilité: </span>Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">pea       path         ; Offset 2<br>\nmove.w    #52,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&H34,L:path%)</span><br>\n<br>\n', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(253, 'Fgetxattr', '', '', '<span class=\"bold\">Nom:</span> get extended attributes - Obtenir les attributs étendus d\'un fichier ou d\'un répertoire.<br>\n<span class=\"bold\">Opcode:</span> 248<br>\n<span class=\"bold\">Syntaxe:</span> int32_t Fgetxattr ( const int8_t *path, XATTR *xattr );<br>\n<span class=\"bold\">Description:</span> La routine GEMDOS Fgetxattr obtient les attributs étendus d\'un fichier ou d\'un répertoire. Les paramètres sont path, un pointeur vers le chemin du fichier ou du répertoire, et xattr, un pointeur vers une structure qui sera remplie avec les attributs étendus.<br>\n<br>\n<span class=\"bold\">Valeur de retour:</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EACCDN:</span> Accès refusé.<br>\n<span class=\"bold\">EPTHNF:</span> Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL:</span> Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM:</span> Pas assez de mémoire.', '<span class=\"bold\">Disponibilité:</span> Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">pea       xattr        ; Offset 4<br>\npea       path         ; Offset 2<br>\nmove.w    #248,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&HF8,L:path%,L:xattr%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(254, 'Fsetxattr', '', '', '<span class=\"bold\">Nom:</span> set extended attributes - Définir les attributs étendus d\'un fichier ou d\'un répertoire.<br>\n<span class=\"bold\">Opcode:</span> 249<br>\n<span class=\"bold\">Syntaxe:</span> int32_t Fsetxattr ( const int8_t *path, const XATTR *xattr );<br>\n<span class=\"bold\">Description:</span> La routine GEMDOS Fsetxattr définit les attributs étendus d\'un fichier ou d\'un répertoire. Les paramètres sont path, un pointeur vers le chemin du fichier ou du répertoire, et xattr, un pointeur vers une structure contenant les attributs étendus à définir.<br>\n<br>\n<span class=\"bold\">Valeur de retour:</span> La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EACCDN:</span> Accès refusé.<br>\n<span class=\"bold\">EPTHNF:</span> Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL:</span> Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM:</span> Pas assez de mémoire.', '<span class=\"bold\">Disponibilité:</span> Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">pea       xattr        ; Offset 4<br>\npea       path         ; Offset 2<br>\nmove.w    #249,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #8,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic:<br>\n<span class=\"code\"> Fehler%=Gemdos(&HF9,L:path%,L:xattr%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(255, 'Dpathconf', '', '', '<span class=\"bold\">Nom: </span>path configuration - Obtenir les informations de configuration d\'un chemin.<br>\n<span class=\"bold\">Opcode:</span> 244<br>\n<span class=\"bold\">Syntaxe: </span>int32_t Dpathconf ( const int8_t *path, int16_t opcode );<br>\n<span class=\"bold\">Description: </span>La routine GEMDOS Dpathconf retourne diverses informations de configuration d\'un chemin de fichier ou de répertoire. Les paramètres sont path, un pointeur vers le chemin, et opcode, un code indiquant quelle information est demandée.<br>\n<br>\nLes valeurs possibles pour opcode sont :<br>\nPC_LINK_MAX (0): Nombre maximum de liens vers un fichier.<br>\nPC_MAX_CANON (1): Longueur maximale d\'une ligne de commande.<br>\nPC_MAX_INPUT (2): Longueur maximale d\'une entrée.<br>\nPC_NAME_MAX (3): Longueur maximale d\'un nom de fichier.<br>\nPC_PATH_MAX (4): Longueur maximale d\'un chemin.<br>\nPC_PIPE_BUF (5): Taille maximale du tampon d\'un tube.<br>\nPC_CHOWN_RESTRICTED (6): L\'attribut chown est-il restreint ?<br>\nPC_NO_TRUNC (7): Les noms longs sont-ils tronqués ?<br>\nPC_VDISABLE (8): Caractère de désactivation de contrôle.<br>\n', '<br>\n<span class=\"bold\">Valeur de retour: </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">>=0:</span> Information demandée.<br>\n<span class=\"bold\">EACCDN:</span> Accès refusé.<br>\n<span class=\"bold\">EPTHNF:</span> Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL: </span>Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM:</span> Pas assez de mémoire.<br>\n<br>\n<span class=\"bold\">Disponibilité:</span> Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    opcode,-(sp) ; Offset 4<br>\npea       path         ; Offset 2<br>\nmove.w    #244,-(sp)   ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic: <br>\n<span class=\"code\">Fehler%=Gemdos(&HF4,L:path%,W:opcode%)</span>', '', NULL, NULL, NULL, '', '', '', 6, 3, 16),
(256, 'Dfree', '', '', '<span class=\"bold\">Nom:</span> get free space - Obtenir l\'espace libre sur un périphérique.<br>\n<span class=\"bold\">Opcode: </span>36<br>\n<span class=\"bold\">Syntaxe:</span> int16_t Dfree ( DFREESP *buf, int16_t drv );<br>\n<span class=\"bold\">Description:</span> La routine GEMDOS Dfree obtient des informations sur l\'espace libre sur un périphérique de stockage. Les paramètres sont buf, un pointeur vers une structure où les informations seront stockées, et drv, le numéro du lecteur (0 = A:, 1 = B:, etc.).<br>\n<br>\n<span class=\"bold\">Valeur de retour: </span>La fonction retourne les résultats suivants :<br>\n<span class=\"bold\">E_OK:</span> Aucun problème n\'est survenu.<br>\n<span class=\"bold\">EACCDN:</span> Accès refusé.<br>\n<span class=\"bold\">EPTHNF:</span> Chemin non trouvé.<br>\n<span class=\"bold\">ENHNDL:</span> Trop de répertoires.<br>\n<span class=\"bold\">ENSMEM:</span> Pas assez de mémoire.<br>\n<br>\n<span class=\"bold\">Disponibilité:</span> Toutes les versions de GEMDOS.<br>\n<br>\n<span class=\"code\">move.w    drv,-(sp)    ; Offset 4<br>\npea       buf          ; Offset 2<br>\nmove.w    #36,-(sp)    ; Offset 0<br>\ntrap      #1           ; GEMDOS<br>\naddq.l    #6,sp        ; Correction de la pile</span><br>\n<br>\nGFA-Basic:<br>\n<span class=\"code\">Fehler%=Gemdos(&H24,L:buf%,W:drv%)</span>', '', '', NULL, NULL, NULL, '', '', '', 7, 3, 16);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(258, 'Qu\'est-ce qu\'un sprite sheet ?', '', '', 'Un sprite sheet <span class=\"italic\">(ou planche de sprites)</span> est une image qui regroupe plusieurs petites images appelées sprites. Ces sprites peuvent représenter différentes poses, actions ou états d\'un personnage, des éléments d\'un décor, ou d\'autres objets dans un jeu vidéo. Les sprites sont ensuite découpés et utilisés individuellement par le programme du jeu selon les besoins.<br>\n<br>\nPour illustrer, imaginez un sprite sheet comme une grande image qui contient une série de petites images représentant les différentes étapes de l\'animation d\'un personnage. <span class=\"bold\"><span class=\"color-red\">Sur Atari ST l\'écran à une résolution de 320 pixels de largeur par 200 lignes de hauteur</span></span>. <span class=\"underline\">Le sprite sheet devra donc respecter ces dimensions. <br>\n</span>', '', '', NULL, '1722946780573.png', NULL, '', '', '', 1, 1, 17),
(259, '', '', '', '', '', 'D\'ailleurs, le sprite sheet ci-dessus est issu d\'un site qui en propose plein (<a class=\"link\" href=\"https://www.spriters-resource.com/\" target=\"blank\">The Spriters Resource</a>), regroupant des sprites de jeux sortis pour différentes consoles de l\'époque. Celui de l\'exemple, c\'est Popeye version arcade. En revanche, les planches ne sont pas utilisables dans l\'état.<br>\n<br>\nDonc la première chose à faire, ça va être de <span class=\"underline\">créer une image de 320x200</span> sous <span class=\"hashtag\">Photoshop</span> ou <span class=\"hashtag\">Gimp</span> ou n\'importe quel autre logiciel, peu importe. Moi, je suis sous Linux donc j\'utilise Gimp. Voici les étapes que j\'ai suivies :', NULL, NULL, NULL, '', '', '', 1, 4, 17),
(260, '', '', '', '', '', '', '1722947435831.png', '1722947435843.png', NULL, '', '', '', 1, 2, 17),
(261, '', '', '', '<span class=\"italic\">(Ci-dessus tu ouvres le sprite sheet téléchargé et à côté tu crées une image 320x200)</span>', '<span class=\"italic\">(Puis dans le sprite sheet, tu sélectionnes les sprites qui t\'intéressent)</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 17),
(262, '', '', '', '', '', '', '1722947779912.png', '1722947779922.png', NULL, '', '', '', 1, 2, 17),
(263, '', '', '', '<span class=\"italic\">(Etape suivante, image du dessus, tu me colles ça où tu veux dans la nouvelle image, et tu me mets un fond rose par exemple et tu vires le fond bleu d\'origine)</span>', '<span class=\"italic\">(Ensuite, tu changes le <span class=\"bold\">mode</span> de l\'image en <span class=\"bold\"><span class=\"color-red\">indexé 16 couleurs maximum</span></span>, puis tu sauvegardes le tout en <span class=\"bold\">.png</span> <span class=\"bold\"><span class=\"color-red\">non-compressé</span></span>)</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 17),
(264, '', '', '', '', '', 'L\'étape dite <span class=\"italic\">\"préparatoire\"</span> est terminée. Tu as ainsi généré un fichier <span class=\"bold\">.png</span> qui contient <span class=\"underline\">16 couleurs maximum</span> et qui sera lisible par <span class=\"hashtag\">Multipaint</span>. <span class=\"italic\">(Si tu ouvres directement le sprite sheet téléchargé avec Multipaint, il risque de tout déformer et de ne pas comprendre qu\'il ne faut que 16 couleurs.)</span>', NULL, NULL, NULL, '', '', '', 1, 4, 17),
(265, '', '', 'Multipaint', '', '', 'Une fois <span class=\"hashtag\">Multipaint</span> ouvert, tu choisis <span class=\"bold\">Atari ST Low</span> <span class=\"italic\">(il ne gère que la basse résolution)</span>. Ensuite, ouvre ton fichier <span class=\"bold\">PNG</span> en allant dans <span class=\"bold\"><span class=\"color-green\">File</span></span> -> <span class=\"bold\"><span class=\"color-green\">Open</span></span>.<br>\n<br>\n<div class=\"border-yellow\"><p><br>\n<span class=\"bold\">Note :</span> Prête attention à la petite fenêtre grise dans le coin en haut à gauche, qui t\'indique la résolution de ton image et le nombre de couleurs qu\'elle contient. Cela te permet de vérifier si elle correspond bien à ce que l\'on souhaite obtenir sur ST.<br>\n</p></div><br>\n<br>\nPar la même occasion, règle la grille, qui te servira de repère très important, sur <span class=\"bold\"><span class=\"underline\">16x16</span></span>. Je t\'explique pourquoi 16x16 plus loin.<br>\n<div class=\"border-green\"><p><br>\n<span class=\"bold\">Tips:</span><br>\nTu peux régler la visibilité de la grille dans le menu <span class=\"bold\">Tools</span> -> <span class=\"bold\">Set Grid</span> -> <span class=\"bold\">Darker/Brigther</span></p></div>', NULL, NULL, NULL, '', '', '', 2, 4, 17),
(266, '', '', '', '', '', '', NULL, NULL, '1722952723395.png', '', '', '', 2, 5, 17),
(268, '', '', '', '', '', 'Avec <span class=\"hashtag\">Multipaint</span>, tu peux travailler sur 2 pages : <br>\n<span class=\"bold\">Front Page</span> (page 1)<br>\n<span class=\"bold\">Spare Page</span> (page 2)<br>\nPour cela, ouvre également le fichier PNG de ton sprite sheet sur la page 2 en appuyant sur la touche <span class=\"keyboard-key\">J</span> <span class=\"italic\">(en plus de l\'avoir déjà ouvert sur la page par défaut (front page))</span>. Ainsi, tu auras l\'écran source sur la page 1 et l\'écran de travail sur la page 2. <span class=\"italic\"><br>\n<br>\nC\'est fait ? OK. A présent, dans la page 2 (spare page) tu éffaces tous les Popeye car on va les mettre au bon endroit.<br>\nPour çà tu sélectionnes une brosse et <span class=\"bold\"><span class=\"color-green\">l\'outil \'rectangle\'</span></span> <span class=\"italic\">(ou bien le raccourcis pavé numérique <span class=\"keyboard-key\">8</span>)</span> et tu sélectionne avec le clic gauche de la souris l\'encre n°0 <span class=\"italic\">(l\'encre du fond)</span> : çà effaces les Popeyes en dessinant un gros rectangle par dessus ou en barbouillant avec une brosse.<br>\n', NULL, NULL, NULL, '', '', '', 2, 4, 17),
(269, '', '', 'Méthode n°1 - Pre-shifting avec l\'animation', '', '', 'Le terme <span class=\"italic\">\"pre-shifting\"</span> fait référence à une technique utilisée pour optimiser l\'affichage des sprites, et libérer du temps processeur (CPU). En revanche cela occupe plus de place en ram (mais bon sur Atari en en a plein !lol). Le processus consiste à ajuster les positions des sprites à l\'intérieur d\'un rectangle <span class=\"italic\">. Dans ce cas on gère l\'animation et le décalage du sprite, cela ne fonctionnera pas en revanche si on doit faire reculer le sprite de 2 ou 3 pixels.<br>\n<br>\nL\'Atari ST fonctionne essentiellement avec des <span class=\"bold\"><span class=\"color-red\">colonnes de 16 pixels, pour un total de 20 colonnes (20 x 16 = 320, soit les 320 pixels de largeur de l\'écran).</span></span><br>\n<br>\nDonc, ici, nous devons faire rentrer nos 6 sprites de Popeye, qui constituent les 6 animations du personnage, dans un rectangle de X pixels. Cela donne ainsi l\'illusion que Popeye se déplace à l\'intérieur de ce rectangle.', NULL, NULL, NULL, '', '', '', 2, 4, 17),
(270, '', '', '', 'Avec l\'outil <span class=\"bold\"><span class=\"color-green\">\'Grabbrush\'</span></span> <span class=\"italic\">(ou le raccourci de la touche <span class=\"keyboard-key\">4</span> du pavé numérique)</span>, tu sélectionnes chaque Popeye de la page 1 <span class=\"italic\">(front page)</span> et tu vas les coller dans la page 2 <span class=\"italic\">(spare page)</span> tout en haut à gauche.<br>\n<br>\n<div class=\"border-green\"><p><br>\n<span class=\"bold\">Tips:</span><br>\nUtilise la molette de la souris pour zoomer/dézoomer<br>\n</p></div><br>\n<br>\nJ\'ai d\'abord commencé à placer les Popeyes en laissant la grille de 16x16. Puis, pour vérifier le placement de chaque sprite dans un rectangle de 3x16 colonnes, j\'ai ajusté la grille en 48 pixels pour la largeur X. J\'en ai profité aussi pour ajuster la hauteur de la grille. Cela donne une information importante : la taille d\'affichage d\'un rectangle de sprite.', '', '', NULL, '1722981867299.png', NULL, '', '', '', 2, 1, 17),
(272, '', '', '', 'Pour le moment on a que des Popeye orienté vers la droite, mais grace à l\'outil <span class=\"bold\"><span class=\"color-green\">\'Mirror X\'</span></span> <span class=\"italic\">(raccourcis de la touche <span class=\"keyboard-key\">X</span>)</span>, on peut donner un effet miroir à notre sélection et constituer la totalité des mouvement<span class=\"italic\"> (j\'ai également rajouté un Popeye au repos en mettant à jours la page 1).</span>', '', '', NULL, '1722983290153.png', NULL, '', '', '', 2, 1, 17),
(274, 'Le masquage', '', '', 'Le masquage de sprite est une technique utilisée pour rendre certaines parties d\'un sprite transparentes. Cela permet au sprite de se superposer à d\'autres éléments graphiques, laissant apparaître le décor ou d\'autres objets situés derrière lui.<br>\n<br>\nDans les exemples précédant, notre Popeye était dessiné sur un fond représenté par l\'encre numéro 0. C\'est important que ce soit zéros.<br>\nEt bien un masque de sprite devra être dessiné avec une couleur dites \'transparentre\' et qui devra être représenté par l\'encre numéro 15.  ', '', '', NULL, '1723023622013.png', NULL, '', '', '', 3, 1, 17),
(275, '', '', '', '', '', 'Quand on fait un jeu avec 16 couleurs<span class=\"italic\"> (numérotées de 0 à 15)</span>, <span class=\"bold\"><span class=\"underline\"><span class=\"color-red\">on définit toujours l\'encre 0 pour le fond du sprite et l\'encre 15 pour le masque.</span></span></span> <br>\nCette encre 15 sera considérée comme \"transparente\" car un sprite doit laisser entrevoir le décors derrière lui. Je ne rentrerai pas dans les détails car il s\'agit d\'une astuce de programmation que j\'explique dans le cours \"Masquer un sprite\".<br>\n<br>\n<div class=\"border-green\"><p><span class=\"bold\">Pour résumer : </span><br>\nLe fond : encre 0<br>\nLe masque : encre 15</p></div><br>\n<br>\n<div class=\"border-red\"><p><span class=\"bold\">Attention:</span><br>\nLe masque n\'est vraiment nécessaire que si la machine sur laquelle on développe ne propose aucune solution hardware pour les sprites.<br>\nexemple: l\' Amiga 500 possède des sprites hard, et donc ne nécessite pas le couleur transparente ou ne masque. </p></div><br>\n<br>\n<br>\n', NULL, NULL, NULL, '', '', '', 3, 4, 17),
(276, 'Créer le masque avec Multipaint', '', '', 'Maintenant que tu as compris le principe du masquage, il va falloir le dessiner pour nos Popeyes. Rien de plus simple :<br>\n<br>\nPrévois la page 1 ou 2 de Multipaint pour accueillir un Popeye qui marche à droite ou à gauche <span class=\"italic\">(comme les sprites sont énormes, nous n\'aurons pas la place de tout mettre dans le même écran).</span><br>\n<br>\nDessine un gros rectangle exactement de la taille des sprites. Pour cela, n\'oublie pas de définir une couleur de ton choix pour<span class=\"bold\"> l\'encre 15.</span>', '', '', NULL, '1723025767081.png', NULL, '', '', '', 3, 1, 17),
(277, '', '', '', 'Et pour terminer <span class=\"italic\">(oui déjà ! Je te l\'avais dit, avec Multipaint, c\'est facile et rapide à faire)</span>, tu sélectionnes tes sprites de Popeye avec <span class=\"bold\"><span class=\"color-green\">l\'outil \'Grab Brush\'</span></span> <span class=\"italic\">(raccourci pavé numérique <span class=\"keyboard-key\">4</span>)</span>. Pour que cela fasse un trou de la même couleur que le fond, <span class=\"underline\">sélectionne la couleur de l\'encre 0 dans la palette</span> et <span class=\"bold\"><span class=\"color-green\">l\'outil \'Brush recolor\'</span></span> (raccourcis <span class=\"keyboard-key\">P</span>) Sauvegarde ton travail et c\'est terminé !<br>\n<br>\nApplique ce que tu viens de faire pour les Popeyes qui vont dans l\'autre sens, et ton sprite sheet est prêt à être utilisé dans ton code !', '', '', NULL, '1723026051250.png', NULL, '', '', '', 3, 1, 17),
(278, '', '', 'Format et sauvegarde', '', '', 'Donc maintenant que tu as terminé ta planche de sprites, tu dois faire attention au format de sauvegarde :<br>\n<br>\n<span class=\"bold\">.png</span> : tu sauvegardes uniquement ton image et ta palette, <span class=\"bold\"><span class=\"color-red\">mais l\'organisation des encres n\'est pas conservée</span></span>.<br>\n<span class=\"bold\">.bin </span>: tu sauvegardes ton image, ta palette <span class=\"bold\">ET l\'organisation de tes encres</span>.<br>\n<span class=\"bold\">.pi1</span> : c\'est un des formats lisibles directement sur l\'Atari ST, le format <span class=\"hashtag\">Degas Elite</span>.<br>\n<br>\n<div class=\"border-red\"><p><span class=\"bold\">Attention :</span><br>\nAu moment où j\'écris cet article, <span class=\"hashtag\">Multipaint</span><span class=\"underline\"> ne sauvegarde que la version 1</span> du format <span class=\"hashtag\">Degas Elite</span> <span class=\"italic\">(un fichier de 32 034 octets)</span>. Si tu essaies de l\'ouvrir avec <span class=\"hashtag\">Deluxe Paint</span>, <span class=\"underline\">ce dernier attendra un fichier Degas Elite version 2</span> <span class=\"italic\">(un fichier de 32 066 octets)</span>, ce qui aura pour résultat l\'affichage de ton image <span class=\"underline\">sans la palette de couleurs</span>.</p></div><br>\n<br>\n<span class=\"bold\"><span class=\"color-red\"><span class=\"underline\">Fais ta sauvegarde dans les 3 formats.</span></span></span>', NULL, NULL, NULL, '', '', '', 3, 4, 17),
(280, '', '', 'Méthode n°2 - seulement avec l\'animation', '', '', 'La deuxième méthode est plus simple que la première, car elle ne nécessite pas de réserver un rectangle complet ni de caler les animations au bon endroit. De plus, la planche de sprites sera moins gourmande en espace, permettant d\'y placer beaucoup plus de sprites.<br>\n<br>\nCela dit, il faut tout de même placer nos Popeyes dans des rectangles, mais ceux-ci seront proportionnés par rapport à la largeur maximale du sprite, comme montré dans la capture d\'écran ci-dessous.', NULL, NULL, NULL, '', '', '', 2, 4, 17),
(281, '', '', '', 'On remarque que presque tous les Popeyes remplissent <span class=\"bold\">2 colonnes de 16 pixels</span>. Les exceptions, comme le 6ème sprite en partant de la gauche qui en occupe 4, correspondent en fait à une action spéciale dans le jeu. À ce moment-là, on change le paramètre de la largeur.<br>\n<br>\nIl faut de toute façon trouver une certaine uniformité dans le placement les sprites, ce qui simplifie leur accès via un programme.', '', '', NULL, '1723039469509.png', NULL, '', '', '', 2, 1, 17),
(283, 'Les lignes du framebuffer', '', '', 'Pour afficher une image complète, nous avons parlé du framebuffer. Maintenant que tu sais ce que c\'est, nous allons entrer un tout petit peu plus dans les détails. Voici une représentation visuelle de la façon dont l\'affichage est géré sur l\'Atari ST.<br>\n<br>\nNous avons vu précédemment que la résolution de l\'écran de l\'Atari ST est de <span class=\"bold\"><span class=\"color-red\">320 pixels (soit 160 octets) par 200 lignes de hauteur</span></span>. Cependant, ces lignes que l\'on voit les unes sous les autres à l\'écran sont en réalité, dans la RAM, placées les unes à la suite des autres.', '', '', NULL, '1723198962367.png', NULL, '', '', '', 1, 1, 18),
(284, '', '', '', '', '', 'Par exemple, si tu souhaites trouver l\'adresse des 3 premières lignes, et que la première commence à <span class=\"bold\">$3F8000 </span><span class=\"italic\">(dans le cas d\'une configuration avec 4 Mo de RAM)</span>, <span class=\"underline\">il faut ajouter 160 octets</span> pour obtenir l\'adresse de la seconde ligne, soit <span class=\"bold\">$3F8000 + 160 = $3F80A0</span>.<br>\n<br>\nPour la troisième ligne, c\'est le même principe : tu ajoutes à nouveau 160 octets à l\'adresse de départ, soit <span class=\"bold\">$3F8000 + 160 + 160 = $3F8140</span>.<br>\nEt ainsi de suite ... Tu as compris ?<br>\nDonc on peut dire que chaque ligne à partir de la seconde, est décalé de <span class=\"bold\">160 octets * n° de la ligne</span>. Ce décalage portent un nom : <span class=\"bold\"><span class=\"color-red\"><span class=\"underline\">offset</span></span></span><br>\n<div class=\"border-green\"><p>Un offset est  utilisé pour désigner un décalage ou une distance par rapport à une adresse de base.</p></div>', NULL, NULL, NULL, '', '', '', 1, 4, 18),
(285, '', '', 'Les lignes de 16 pixels', '', '', 'Chaque ligne contient donc plusieurs pixels, mais il y a une particularité sur l\'Atari ST : sur chaque ligne, <span class=\"bold\"><span class=\"color-red\"><span class=\"underline\">les pixels sont stockés par groupes de 16</span></span></span> ! Et ces groupes sont tous <span class=\"underline\">indépendants les uns des autres</span> (WTF ??!!).<br>\nCela signifie que l\'écran est divisé en <span class=\"bold\">320 pixels / 16 pixels = 20 groupes de 16 pixels.</span><br>\n<br>\nVoici une représentation graphique :', NULL, NULL, NULL, '', '', '', 1, 4, 18),
(286, '', '', '', '', '', '', NULL, NULL, '1723206997934.png', '', '', '', 1, 5, 18),
(287, 'Affichage de sprites 16x16', '', '', 'Ça tombe bien, je n\'en avais pas sous la main <span class=\"italic\">(merci à Mokona de suivre les cours !)</span>. Voici donc une planche de sprites qui mesure presque tous 16 pixels de large et 16 lignes de haut, ce qui va nous simplifier les choses.<br>\n<br>\nComment créer une planche de sprites comme celle-ci ? Si tu ne sais pas encore comment faire, je t\'invite à consulter la section <span class=\"bold\"><span class=\"color-green\">Tutoriels</span></span> du site, dans le cours intitulé <a class=\"link\" href=\"https://www.asmtariste.fr/article-content/17/1\" target=\"blank\">\"Créer une planche de sprites avec Multipaint\"</a>.', '', '', NULL, '1723207814485.png', NULL, '', '', '', 1, 1, 18),
(288, '', '', '', '', '', 'Mais pourquoi choisir <span class=\"bold\">16x16</span> pixels ? Pourquoi pas 12x23 ou 39x44 ? Eh bien, c\'est pour éviter de te faire peur et que tu quittes le site en courant... Le fait est que le découpage des lignes en groupes de 16 pixels indépendants <span class=\"italic\">(sur l\'axe des X)</span> pose un problème lorsqu\'on veut afficher un sprite \"au pixel près\" <span class=\"italic\">(par opposition à un groupe de 16 pixels)</span> et que notre sprite sort entièrement ou en partie de cette colonne de 16 pixels. Cela nécessiterait un traitement bien plus complexe, appelé les <span class=\"bold\">4 bitplanes</span> : un principe où chaque pixel correspond à une encre de la palette, encodée sur 4 words !<br>\nTu vois, je t\'avais prévenu que ça faisait peur !<br>\n<br>\nDonc, on va commencer simple : l\'objectif est d\'afficher, tout en haut à gauche de l\'écran, n\'importe quel sprite de ton sprite sheet que tu as bien entendu déjà préparé !', NULL, NULL, NULL, '', '', '', 1, 4, 18),
(289, 'Calcule de la source', '', '', 'Je veux afficher le sprite que j\'ai entouré en jaune. Pour cela,<span class=\"bold\"> il faut calculer l\'offset de ce sprite</span> dans l\'image chargée en mémoire. C\'est le 6ème sprite en partant du haut et le 2ème en partant de la gauche.<br>\n<br>\nTu sais également que :<br>\nUn sprite fait <span class=\"bold\">16 pixels de hauteur.</span><br>\nUn sprite fait <span class=\"bold\">16 pixels de largeur (soit 8 octets).</span><br>\nUne ligne fait <span class=\"bold\">320 pixels de longueur (soit 160 octets).</span><br>\nTu as toutes les informations nécessaires.', '', '', NULL, '1723209740619.png', NULL, '', '', '', 2, 1, 18),
(290, '', '', '', '', '', 'Pour commencer, il faut inclure la source de ton image :<br>\n<span class=\"code\">spriteSheet:<br>\n    INCBIN images/mokona.pi1</span><br>\nÀ partir de là, tu dois calculer l\'adresse de <span class=\"underline\">la coordonnée Y de ton sprite</span>, c\'est-à-dire <span class=\"bold\"><span class=\"color-red\">le nombre de lignes nécessaires pour atteindre la ligne sur laquelle ton sprite commence</span></span>. <br>\nLe calcul est simple : chaque sprite fait 16 lignes de haut, et on cible la 6ème rangée de sprites <span class=\"italic\">(donc la rangée n°5, puisque l\'on commence à la rangée n°0)</span>. <span class=\"bold\"><span class=\"color-red\">Il faut donc descendre de 5 fois 16 lignes</span></span>.<br>\n<br>\nChaque ligne a une longueur totale de <span class=\"bold\">160 octets</span>. <br>\nLa coordonnée Y se calcule donc comme suit : <span class=\"bold\"><span class=\"underline\">5 fois 16 lignes de 160 octets</span></span>. Tu me suis jusqu\'ici ? Normalement oui, c\'est simple, ce sont des mathématiques de base.<br>\n<br>\nCela se traduit ainsi dans le code :<br>\n<span class=\"code\">move.l #spriteSheet+34,a0     ; source de l\'image<br>\nadd.l #160*16*5,a0            ; Coordonnée Y = 5 * 16 lignes de 160 octets</span><br>\n<br>\nEnsuite, il faut calculer <span class=\"underline\">la coordonnée X du sprite</span> souhaité. Ici, il ne s\'agit plus du nombre de lignes, mais <span class=\"bold\"><span class=\"color-red\">du nombre de pixels <span class=\"italic\">(ou plutôt d\'octets)</span> à partir du début de la ligne</span></span> <span class=\"italic\">(adresse que l\'on a obtenue avec le calcul précédent).</span><br>\n<br>\nJ\'ai choisi le 2ème sprite <span class=\"italic\">(donc la colonne n°1, puisque l\'on commence à la colonne n°0)</span>. <span class=\"bold\"><span class=\"color-red\">Il faut donc avancer de 1 fois 16 pixels</span></span>. Les 16 pixels d\'une ligne occupent toujours 8 octets. <br>\nLa coordonnée X se calcule donc comme suit : <span class=\"bold\"><span class=\"underline\">1 fois 8 octets à partir de l\'adresse Y.</span></span><br>\n<br>\nEn reprenant le code précédent, on ajoute une ligne comme ceci :<br>\n<span class=\"code\">move.l #spriteSheet+34,a0     ; source de l\'image<br>\nadd.l #160*16*5,a0            ; Coordonnée Y = 5 * 16 lignes de 160 octets<br>\nadd.l #8*1,a0                 ; Coordonnée X = 1 * 8 octets</span><br>\n<br>\nAinsi, tu obtiens l\'adresse exacte de ton sprite dans l\'image en mémoire.', NULL, NULL, NULL, '', '', '', 2, 4, 18),
(291, 'Destination Logbase()', '', '', 'Il est temps d\'intégrer cette fonction du <span class=\"bold\">XBIOS</span>, bien pratique ! En effet, tu ne veux pas que ton programme fonctionne uniquement sur une configuration spécifique, mais sur tous les types de <span class=\"bold\">ST / STf / STe</span>, qu\'ils aient 512 Ko ou 4 Mo de RAM.<br>\n<br>\nRappelle-toi, je t\'avais expliqué que le framebuffer se logeait automatiquement à la fin de la RAM, ce qui entraîne des adresses de framebuffer différentes selon la machine. Mais avec la fonction <span class=\"bold\"><span class=\"color-red\">Logbase()</span></span>, ce n\'est plus un problème, car <span class=\"underline\"><span class=\"bold\">elle te renvoie l\'adresse du framebuffer dans l\'un des registres de crash, d0.</span></span>', '', '', NULL, '1723239991522.png', NULL, '', '', '', 2, 1, 18),
(292, '', '', '', '', '', 'Comme on a l\'habitude maintenant, on va directement créer un nouveau label dans le fichier <span class=\"bold\">TRAPS.S</span> :<br>\n<span class=\"code\">getLogicalScreenAdress:<br>\n    move.w #_Logbase,-(sp)  ; numéro de la fonction<br>\n    trap #XBIOS             ; appel XBIOS<br>\n    add.w #2, sp            ; correction de la pile<br>\n    rts</span><br>\n<br>\nEt dans le fichier <span class=\"bold\">PARAMS.S</span>, ajoute la ligne suivante :<br>\n<span class=\"code\">_Logbase     EQU     3</span><br>\n<br>\nAvec cela, tu as une fonction prête à l\'emploi pour récupérer l\'adresse logique du framebuffer, compatible avec toutes les configurations d\'Atari ST.<br>\nIl est un peu contraignant de devoir appeler cette routine chaque fois que tu veux récupérer une adresse qui sera probablement utilisée fréquemment. Pour simplifier les choses, nous allons stocker cette adresse quelque part en mémoire.<br>\n<br>\nNous allons créer une variable, c\'est-à-dire une adresse spécifique en mémoire, définie avec un label, qui servira de référence pour lire cette variable. Une variable peut contenir n\'importe quelle donnée; dans notre cas, il s\'agit d\'une adresse.<br>\n<br>\nCependant, on ne place pas cette variable n\'importe où. C\'est là qu\'intervient la directive <span class=\"bold\"><span class=\"color-green\">SECTION BSS</span></span> et l\'instruction <span class=\"bold\"><span class=\"color-green\">ds.<suffixe></span></span>. Contrairement à la section <span class=\"bold\">DATA</span>, la section <span class=\"bold\">BSS</span> est utilisée <span class=\"bold\"><span class=\"underline\">pour réserver de la mémoire pour des données non initialisées lors de l\'assemblage</span></span>. Let\'s go !<br>\n<span class=\"code\">SECTION BSS<br>\nlogicalScreenAddress:<br>\n    ds.l    1    ; on réserve un espace mémoire pour 1 Long Word</span><br>\nÀ cet endroit précis, nous pourrons <span class=\"bold\"><span class=\"underline\">lire et écrire</span></span> la variable. Revenons maintenant à <span class=\"bold\"><span class=\"color-red\">Logbase()</span></span> ! Nous allons stocker l\'adresse retournée par l\'appel <span class=\"bold\">XBIOS</span>.<br>\nLe code de la routine <span class=\"bold\">getLogicalScreenAddress</span> ressemblera désormais à ceci :<br>\n<span class=\"code\">getLogicalScreenAddress:<br>\n    move.w #_Logbase,-(sp)  ; numéro de la fonction<br>\n    trap #XBIOS             ; appel XBIOS<br>\n    add.w #2, sp            ; correction de la pile<br>\n    move.l d0,logicalScreenAddress  ; on stocke l\'adresse reçue<br>\n    rts</span><br>\nIl ne te reste plus qu\'à appeler cette routine dans ton fichier <span class=\"bold\">MAIN.S</span> et le tour est joué !', NULL, NULL, NULL, '', '', '', 2, 4, 18),
(293, '', '', '', '', '', 'Voici un aperçu qui va résumer la structure de ton code <span class=\"bold\">MAIN.S</span><br>\n<br>\n<span class=\"code\">SECTION TEXT<br>\n; passage en basse résolution Setscreen()<br>\n; chargement de la palette Setpalette()<br>\n; récupération de l\'adresse framebuffer Logbase()<br>\n<br>\n; Affichage du sprite<br>\n<br>\n; Attendre une touche Cconin()<br>\n; restaurer la résolution Setscreen()<br>\n; terminer le programme Pterm0()<br>\n<br>\n; les fichiers à inclure<br>\n<br>\nSECTION DATA<br>\n<br>\nSECTION BSS</span>', NULL, NULL, NULL, '', '', '', 2, 4, 18),
(294, 'Affichage du sprite !', '', '', 'On y est ! tu as presque terminé car il ne te reste plus qu\'à afficher ton sprite avec les coordonnées X et Y que tu viens de calculer. Tu vas d\'ailleurs finir cette routine d\'affichage toi-même, tu en est capable, tu as tous les pré-requis nécessaires.<br>\n<br>\n<div class=\"border-green\"><p><span class=\"bold\">Tips:</span><br>\nPense au cours qui t\'a permis d\'afficher une image.<br>\nUtilise une boucle avec l\'instruction dbf pour la hauteur de ton sprite.<br>\nPenser à calculer l\'adresse de la ligne suivante.</p></div><br>\n<br>\nTu devrait obtenir ton sprite dans le coin haut gauche de ton écran', '', '', NULL, '1723242047745.png', NULL, '', '', '', 3, 1, 18),
(295, '', '', 'Petit exercice !', '', '', 'Et oui, il va falloir réfléchir ! Tu as sûrement remarqué que c\'était un peu agaçant de ne pas retrouver la palette du GEM lorsque ton programme se termine. C\'est normal : nous avons modifié la palette, mais nous ne l\'avons pas restaurée en quittant le programme ! Je vais te guider un peu :<br>\n<br>\n<span class=\"bold\">Consulte la documentation :</span> Va jeter un œil sur le site et trouve la fonction <span class=\"bold\"><span class=\"color-red\">Setcolor()</span></span>. Elle te sera utile pour manipuler la palette de couleurs.<br>\n<span class=\"bold\">Réserve de l\'espace en RAM :</span> Tu devras réserver un espace en mémoire pour stocker <span class=\"underline\">les couleurs que la fonction <span class=\"bold\"><span class=\"color-red\">Setcolor()</span></span> va te retourner.</span><br>\n<span class=\"bold\">Utilise une boucle : </span>La palette de l\'Atari ST comprend 16 encres, donc tu devras créer une boucle avec un compteur pour gérer chacune d\'elles.<br>\n<br>\nUne fois que tu as fait ça, poste ton code sur le serveur <span class=\"hashtag\">Discord</span>. Si tu es bloqué et que tu as besoin d\'explications supplémentaires, n\'hésite pas à demander de l\'aide !<br>\n<br>\n<span class=\"color-red\"><span class=\"italic\">(<span class=\"bold\">Petite mise en garde :</span> ne regarde pas la solution toute faite ! Le but, c\'est de te faire raisonner comme un développeur, et non comme un teubé de la génération X qui pense tout savoir en suivant simplement des tutoriels !)</span></span>', NULL, NULL, NULL, '', '', '', 3, 4, 18),
(296, '', '', 'Fichiers Sources', '', '', '<a class=\"link\" href=\"https://www.asmtariste.fr/assets/files/sources/PROG_ASM.002.zip\" target=\"blank\">Voici les fichiers sources du cours à télécharger</a> (avec un autre exemple que celui du cours)', NULL, NULL, NULL, '', '', '', 3, 4, 18),
(297, 'L\' éditeur', '', '', '<span class=\"underline\"><span class=\"bold\">Navigation et contrôle du curseur :</span></span><br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\"><-</span> <span class=\"keyboard-key\">-></span> : curseur en <span class=\"bold\">début</span> ou <span class=\"bold\">fin</span> de ligne.<br>\n<span class=\"keyboard-key\">Shift</span> + flèches curseur : <span class=\"bold\">déplacement rapide</span> du curseur.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">T</span> ou <span class=\"keyboard-key\">B</span> : curseur en <span class=\"bold\">début</span> ou <span class=\"bold\">fin</span> de document.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">G</span> : curseur à la <span class=\"bold\">ligne n°</span>.<br>\n<span class=\"keyboard-key\">F1</span> et <span class=\"keyboard-key\">F2</span> : sélectionne le <span class=\"bold\">texte début - fin</span> (ou avec la souris).<br>\n<span class=\"keyboard-key\">Shift</span> + <span class=\"keyboard-key\">F4</span> : <span class=\"bold\">copier</span> la sélection.<br>\n<span class=\"keyboard-key\">Shift</span> + <span class=\"keyboard-key\">F5</span> : <span class=\"bold\">couper</span> la sélection.<br>\n<span class=\"keyboard-key\">F5</span> : <span class=\"bold\">coller</span> la sélection qui a été coupé ou copié.<br>\n<span class=\"keyboard-key\">F3</span> : <span class=\"bold\">sauvegarder</span> la sélection dans un nouveau fichier.<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">Y</span> : <span class=\"bold\">effacer</span> la ligne complète.<br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Recherche :</span></span><br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">F</span> : <span class=\"bold\">rechercher ou remplacer </span>à partir du curseur.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">N</span> : résultat de la recherche <span class=\"bold\">après</span> le curseur.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">P</span> : résultat de la recherche <span class=\"bold\">avant</span> le curseur.', '<span class=\"underline\"><span class=\"bold\">Contrôle des fenêtres :</span></span><br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">V</span> : passer à la <span class=\"bold\">fenêtre suivante</span>.<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">W</span> : <span class=\"bold\">fermer</span> la fenêtre et le fichier.<br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Contrôle général :</span></span><br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">L</span> : <span class=\"bold\">charger</span> un nouveau fichier.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">S</span> : <span class=\"bold\">sauvegarde</span> d\'un fichier <span class=\"bold\">sous</span> ...<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">Shift</span> + <span class=\"keyboard-key\">S</span> : <span class=\"bold\">sauvegarde</span> du fichier <span class=\"bold\">en cours</span>.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">A</span> : <span class=\"bold\">assembler</span> le programme.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">X</span> : <span class=\"bold\">exécuter</span> le programme assemblé.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">K</span> : exécuter le programme <span class=\"bold\">sous GEM ou TOS</span> (toggle)<br>\n', '', NULL, NULL, NULL, '', '', '', 1, 3, 19),
(298, 'Le débogueur (Monst)', '', '', '<span class=\"underline\"><span class=\"bold\">Navigation et fenêtres :</span></span><br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">C</span> : <span class=\"bold\">terminer</span> le programme.<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">C</span> + <span class=\"keyboard-key\">C</span> : <span class=\"bold\">quitter</span> le débogueur.<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">O</span> : débogueur en basse ou moyenne <span class=\"bold\">résolution</span>.<br>\n<br>\n<span class=\"keyboard-key\">V</span> : aperçu de <span class=\"bold\">l\'écran</span> en cours.<br>\n<span class=\"keyboard-key\">L</span> : affiche la fenêtre des <span class=\"bold\">labels</span>.<br>\n<span class=\"keyboard-key\">H</span> : affiche la fenêtre de <span class=\"bold\">l\'historique</span> des registres.<br>\n<br>\n<span class=\"keyboard-key\">Tab</span> ou <span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">I</span> : sélection de la fenêtre <span class=\"bold\">1, 2 ou 3</span>.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">1</span> : sélection de la <span class=\"bold\">fenêtre 1</span>.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">2</span> : sélection de la <span class=\"bold\">fenêtre 2</span>.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">3</span> : sélection de la <span class=\"bold\">fenêtre 3</span>.<br>\n<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">Z</span> : fenêtre 1, 2 ou 3 en <span class=\"bold\">fullscreen</span>.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">S</span> : créer un <span class=\"bold\">clone</span> de la fenêtre 1 ou 2.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">F</span> : changer la taille de la <span class=\"bold\">police</span> d\'une fenêtre 1, 2 ou 3.<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">W</span> : la fenêtre 2 prend <span class=\"bold\">toute la largeur</span> de l\'écran et désactive la fenêtre 3.<br>\n<br>\n<span class=\"underline\"><span class=\"bold\">Traçage du code :</span></span><br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">Z</span> ou <span class=\"keyboard-key\">W</span> : <span class=\"bold\">exécuter</span> la ligne (pas à pas).<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">A</span> ou <span class=\"keyboard-key\">T</span> : <span class=\"bold\">exécuter</span> la ligne (sans rentrer dans les appels).<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">S</span> : <span class=\"bold\">ne pas exécuter</span> la ligne.<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">B</span> : placer un <span class=\"bold\">breakpoint</span> (10 maximum).<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">R</span> : <span class=\"bold\">exécuter</span> jusqu\'au prochain breakpoint.<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">K</span> : <span class=\"bold\">supprimer</span> tous les breakpoints.', '<span class=\"bold\"><span class=\"underline\">Commandes :</span></span><br>\n<span class=\"keyboard-key\">M</span> ou <span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">A</span> : <span class=\"bold\">aller</span> à l\'adresse.<br>\n<br>\n<span class=\"keyboard-key\">S</span> : <span class=\"bold\">sauvegarder</span> une plage mémoire en binaire*<br>\n    Save binary : <span class=\"italic\">fichier.bin</span><br>\n    start address,end : <span class=\"italic\">AB3456</span>,<span class=\"italic\">AC6789</span><br>\n(* sauvegarde à la racine de Devpac)<br>\n<br>\n<span class=\"keyboard-key\">T</span> : <span class=\"bold\">écrire</span> un octet à une adresse.<br>\n    Port to write, value : <span class=\"italic\">AB3456</span>,<span class=\"italic\">3F</span><br>\n<br>\n<span class=\"keyboard-key\">W</span> : <span class=\"bold\">remplir</span> une plage d\'adresses avec un octet.<br>\n    Fill start,end,with : <span class=\"italic\">AB3456</span>,<span class=\"italic\">AC6789</span>,<span class=\"italic\">3F</span><br>\n<br>\n<span class=\"keyboard-key\">Alternate</span> + <span class=\"keyboard-key\">R</span> ou <span class=\"keyboard-key\">E</span>: <span class=\"bold\">écrire</span> dans un registre.<br>\n    Register=value : <span class=\"italic\">dn ou An</span>=<span class=\"italic\">AB345678</span><br>\nou écrire dans la fenêtre 3 en déplaçant le curseur<br>\n<br>\n<span class=\"keyboard-key\">Control</span> + <span class=\"keyboard-key\">P</span> : <span class=\"bold\">préférences</span> de Monst<br>\n     <span class=\"italic\">(Screen Timer, Follow Traps, Relative offsets, Ignore case, <br>\nIgnore cartidge area, Source line numbers, Auto load source, Auto \'_\' or \'@\' prefix, Start label, Symbol length, Display ZAn in disassembly, Top of RAM)</span>', '', NULL, NULL, NULL, '', '', '', 1, 3, 19),
(299, 'Tadjtime', '', '', '<span class=\"bold\">Nom :</span> \"Ajuster le temps\" - Corrige l\'heure pour synchroniser l\'horloge du système.<br>\n<span class=\"bold\">Opcode : </span>343 (0x157)<br>\n<span class=\"bold\">Syntaxe :</span> int Tadjtime(const struct timeval *delta, struct timeval *olddelta);<br>\n<span class=\"bold\">Description :</span> La fonction Tadjtime() ajuste progressivement l\'horloge du système (comme renvoyée par Tgettimeofday). La quantité de temps par laquelle l\'horloge doit être ajustée est spécifiée dans la structure pointée par delta.<br>\n<br>\nSi l\'ajustement dans delta est positif, l\'horloge du système est accélérée par un petit pourcentage (c\'est-à-dire en ajoutant une petite quantité de temps à la valeur de l\'horloge chaque seconde) jusqu\'à ce que l\'ajustement soit terminé. Si l\'ajustement dans delta est négatif, l\'horloge est ralentie de manière similaire.<br>\n<br>\nSi un ajustement de l\'horloge d\'un appel précédent à Tadjtime() est déjà en cours lors d\'un appel ultérieur à Tadjtime(), et que delta n\'est pas NULL pour l\'appel ultérieur, alors l\'ajustement précédent est arrêté, mais toute partie déjà complétée de cet ajustement n\'est pas annulée.<br>\n', 'Si olddelta n\'est pas NULL, le tampon auquel il pointe est utilisé pour renvoyer le temps restant de tout ajustement précédent qui n\'a pas encore été terminé.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> Un retour de valeur 0 si le réglage a été effectué avec succès, sinon un code d\'erreur négatif est retourné.<br>\n<br>\n<div class=\"border-green\"><p><span class=\"bold\">Notes : </span><br>\nL\'ajustement que Tadjtime() effectue à l\'horloge est réalisé de manière à ce que l\'horloge augmente toujours de manière monotone. Utiliser Tadjtime() pour ajuster l\'heure empêche les problèmes qui peuvent être causés pour certaines applications (par exemple, make(1)) par des sauts positifs ou négatifs brusques dans le temps du système.</p></div><br>\n<br>\n<span class=\"bold\">Disponibilité :</span> Cette fonction est disponible à partir de FreeMiNT 1.16.<br>\n', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(300, 'Talarm', '', '', '<span class=\"bold\">Nom : </span>\"Talarm\" - Lit/règle une alarme de processus pour le processus en cours.<br>\n<span class=\"bold\">Opcode :</span> 288 (0x0120)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Talarm(int32_t time);<br>\n<span class=\"bold\">Description :</span> La fonction Talarm envoie un signal SIGALRM au processus appelant après time secondes.<br>\n<br>\nSi aucun gestionnaire de signaux n\'a été installé pour ce signal avec Psignal, le processus sera immédiatement terminé (c\'est-à-dire lors de la réception du signal). En réglant la valeur de time à 0, une alarme définie précédemment peut être annulée. Si time est négatif, la fonction n\'a aucun effet et seule la valeur de retour est livrée.', '<span class=\"bold\">Valeur de retour :</span> La fonction renvoie le temps (en secondes) restant avant que le signal SIGALRM ne soit déclenché (si une alarme a été activée), ou sinon la valeur 0 si aucune alarme n\'a été programmée avant cet appel.<br>\n<br>\n<span class=\"bold\">Disponibilité :</span> À partir de la première version de MiNT intégrée à MultiTOS 1.04.<br>\n<br>\nL\'appel a été introduit dans la version MiNT 0.8pl8, mais avant la version 1.12, le code contenait un bug affectant sa fonctionnalité.', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(301, 'Tgetdate', '', '', '<span class=\"bold\">Nom : </span>\"Obtenir la date\" - Obtient la date.<br>\n<span class=\"bold\">Opcode :</span> 42<br>\n<span class=\"bold\">Syntaxe :</span> uint32_t Tgetdate(void);<br>\n<span class=\"bold\">Description : </span>La routine GEMDOS Tgetdate obtient la date actuelle.', '<span class=\"bold\">Valeur de retour :</span> La fonction renvoie un nombre uint32_t avec la date, qui est codée comme suit :<br>\nBits	Signification<br>\n0-4	Jour (1-31)<br>\n5-8	Mois (1-12)<br>\n9-15	Année (0-119, 0 = 1980)<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de GEMDOS.', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(302, 'Tgettime', '', '', '<span class=\"bold\">Nom :</span> \"Obtenir l\'heure\" - Obtient l\'heure.<br>\n<span class=\"bold\">Opcode : </span>44<br>\n<span class=\"bold\">Syntaxe :</span> uint32_t Tgettime(void);<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Tgettime obtient l\'heure du système.', '<span class=\"bold\">Valeur de retour :</span> La fonction renvoie l\'heure du système, codée comme suit :<br>\nBits	Signification<br>\n0-4	Secondes en unités de deux (0-29)<br>\n5-10	Minutes (0-59)<br>\n11-15	Heures (0-23)<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de GEMDOS.', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(303, 'Tgettimeofday', '', '', '<span class=\"bold\">Nom : </span>\"Tgettimeofday\" - Interroge l\'état de l\'horloge système interne à haute résolution.<br>\n<span class=\"bold\">Opcode :</span> 341 (0x0155)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Tgettimeofday(timeval *tv, timezone *tzp);<br>\n<span class=\"bold\">Description : </span>La fonction Tgettimeofday interroge l\'état de l\'horloge système interne à haute résolution.<br>\n<br>\nL\'argument tv est un pointeur vers la structure timeval.<br>\nL\'argument tzp est un pointeur vers la structure timezone.<br>\nVous pouvez passer en toute sécurité NULL pour l\'un ou l\'autre argument. Cela n\'est pas considéré comme une erreur.<br>\n<br>\nLes implémenteurs de liaisons de bibliothèque doivent être conscients que la définition de la structure timezone n\'est pas standard. Les membres sont en fait des int et non des long int (cela ne s\'applique qu\'à la structure timezone; les membres de la structure timeval sont toujours des long). Les bibliothèques 16 bits devront copier le contenu de la structure pointée par tzp.', 'L\'appel Ssystem() a une commande S_CLOCKMODE. Cette commande permet de récupérer ou de définir le mode d\'horloge du noyau, c\'est-à-dire de spécifier si l\'horloge matérielle est censée fonctionner en UTC ou en heure locale.<br>\n<br>\nIl est prévu de rendre MiNT conforme au modèle de gestion du temps du noyau décrit dans RFC1305. Ce modèle est déjà implémenté avec succès dans des systèmes d\'exploitation tels que SunOS, Ultrix, OSF/1, HP-UX et Linux. Il faut s\'attendre à des changements dans la réalisation interne à l\'avenir.<br>\n<br>\n<span class=\"bold\">Valeur de retour : </span>La fonction ne peut jamais échouer. Elle renvoie toujours E_OK.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsqu\'un noyau MiNT d\'une version au moins 1.15.0 est détecté.', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(304, 'Tmalarm', '', '', '<span class=\"bold\">Nom :</span> \"Tmalarm\" - Interroge l\'état de l\'horloge système interne à haute résolution.<br>\n<span class=\"bold\">Opcode :</span> 317 (0x013d)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Tmalarm(int32_t time);<br>\n<span class=\"bold\">Description : </span>Cette fonction lit/règle une alarme de processus pour le processus en cours.<br>\n<br>\ntime spécifie la durée (en millisecondes) à attendre avant qu\'un signal SIGALRM ne soit délivré. Si time est 0, toute alarme précédemment réglée est annulée. Si time est négatif, la fonction ne modifie aucune alarme actuellement définie.<br>\n<br>\nSi aucun gestionnaire de signal SIGALRM n\'a été configuré lorsque l\'alarme est déclenchée, le processus sera tué.', '<span class=\"bold\">Valeur de retour :</span> Renvoie 0 si aucune alarme n\'a été programmée avant cet appel ou le temps restant (en millisecondes) avant que l\'alarme ne soit déclenchée.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsqu\'un \'MiNT\' cookie avec une version d\'au moins 1.10 existe.', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(305, 'Tsetdate', '', '', '<span class=\"bold\">Nom : </span>\"Régler la date\" - Régler la date.<br>\n<span class=\"bold\">Opcode : </span>43<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Tsetdate(uint16_t date);<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Tsetdate règle la date actuelle. Le paramètre date est codé comme suit :<br>\nBits	Signification<br>\n0-4	Jour (1-31)<br>\n5-8	Mois (1-12)<br>\n9-15	Année (0-119, 0 = 1980)', '<span class=\"bold\">Valeur de retour :</span> La fonction renvoie 0 si la date a été réglée avec succès, sinon un code d\'erreur négatif est retourné.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de GEMDOS.', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(306, 'Tsettime', '', '', '<span class=\"bold\">Nom :</span> \"Régler l\'heure\" - Régler l\'heure.<br>\n<span class=\"bold\">Opcode : </span>45<br>\n<span class=\"bold\">Syntaxe :</span> int16_t Tsettime(uint16_t time);<br>\n<span class=\"bold\">Description :</span> La routine GEMDOS Tsettime règle l\'heure du système.<br>\ntime est un nombre de 16 bits codé comme suit :<br>\nBits	Signification<br>\n0-4	Secondes en unités de deux (0-29)<br>\n5-10	Minutes (0-59)<br>\n11-15	Heures (0-23)', '<span class=\"bold\">Valeur de retour : </span>La fonction renvoie 0 si l\'heure a été réglée avec succès, sinon un code d\'erreur négatif est retourné.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Toutes les versions de GEMDOS.', '', NULL, NULL, NULL, '', '', '', 1, 3, 20),
(307, 'Tsettimeofday', '', '', '<span class=\"bold\">Nom :</span> \"Tsettimeofday\" - Interroge l\'état de l\'horloge système interne à haute résolution.<br>\n<span class=\"bold\">Opcode : </span>342 (0x0156)<br>\n<span class=\"bold\">Syntaxe :</span> int32_t Tsettimeofday(timeval *tv, timezone *tzp);<br>\n<span class=\"bold\">Description :</span> La fonction Tsettimeofday règle l\'horloge système interne à haute résolution.<br>\n<br>\n<br>\nL\'appel Ssystem() a une commande S_CLOCKMODE. Cette commande permet de récupérer ou de définir le mode d\'horloge du noyau, c\'est-à-dire de spécifier si l\'horloge matérielle est censée fonctionner en UTC ou en heure locale.<br>\n<br>\nIl est prévu de rendre MiNT conforme au modèle de gestion du temps du noyau décrit dans RFC1305. Ce modèle est déjà implémenté avec succès dans des systèmes d\'exploitation tels que SunOS, Ultrix, OSF/1, HP-UX et Linux. Il faut s\'attendre à des changements dans la réalisation interne à l\'avenir.<br>\n<br>\n<span class=\"bold\">Valeur de retour :</span> La fonction renvoie 0 en cas de succès, sinon un code d\'erreur négatif.<br>\n<br>\n<span class=\"bold\">Disponibilité : </span>Disponible lorsqu\'un noyau MiNT d\'une version au moins 1.15.0 est détecté.', 'L\'argument tv est un pointeur vers la structure timeval qui contient la date et l\'heure actuelles, et un intervalle de microsecondes.<br>\n<br>\nL\'argument tzp est un pointeur vers la structure timezone, qui est utilisée pour définir le fuseau horaire.<br>\n<br>\nVous pouvez passer en toute sécurité NULL pour l\'un ou l\'autre argument. Cela n\'est pas considéré comme une erreur.<br>\n<br>\nLes implémenteurs de liaisons de bibliothèque doivent être conscients que la définition de la structure timezone n\'est pas standard. Les membres sont en fait des int et non des long int (cela ne s\'applique qu\'à la structure timezone; les membres de la structure timeval sont toujours des long).', '', NULL, NULL, NULL, '', '', '', 1, 3, 20);
INSERT INTO `contents` (`id_contents`, `title_left`, `title_right`, `title_center`, `text_left`, `text_right`, `text_center`, `image_left`, `image_right`, `image_center`, `attachement_left`, `attachement_right`, `attachement_center`, `page`, `id_templates`, `id_articles`) VALUES
(308, 'Le principe', '', '', 'Un sprite est généralement représenté <span class=\"bold\">dans un rectangle où l’image est entourée de pixels qui ne font pas partie de l’objet réel</span> <span class=\"italic\">(par exemple notre Sonic ce sont les pixels que j\'ai volontairement mis en <span class=\"color-yellow\"><span class=\"bold\">jaune</span></span>)</span>. Lorsqu\'on affiche le sprite, ces pixels indésirables peuvent se superposer au fond, ce qui n\'est pas souhaitable.<br>\nOn ne veut afficher que la partie utile du sprite (Sonic) sans montrer les pixels autour qui pourraient interférer avec le fond sur lequel il est dessiné.', '', '', NULL, '1723565662807.png', NULL, '', '', '', 1, 1, 21),
(309, 'AND (ET)', '', '', 'Pour comprendre le masquage de sprites, il est important de connaître quelques opérations logiques simples que l\'on peut effectuer sur les pixels. L\'opération AND est une opération binaire, ce qui signifie qu\'elle prend deux bits comme entrée, pour les comparer, et produit en sortie un seul bit, qui est le résultat. Voici comment elle fonctionne :<br>\n<span class=\"bold\">1 AND 1 = 1<br>\n1 AND 0 = 0<br>\n0 AND 1 = 0<br>\n0 AND 0 = 0</span><br>\nEn résumé, l\'opération <span class=\"bold\">AND</span> ne donne 1 en sortie que si les deux bits d\'entrée sont égaux à 1. Si l\'un des deux bits est 0, le résultat est 0.<br>\n<br>\n<div class=\"border-green\"><p>Note:<br>\nDans une opération AND on conserve les 0 et les 1 mais le 0 reste prioritaire.<br>\nPratique utilisée pour mettre des bits à 0 sans toucher aux bits 1.</p></div><br>', '', '', NULL, '1723567461744.png', NULL, '', '', '', 1, 1, 21),
(310, '', '', 'A quoi çà sert ?', '', '', 'Le problème des sprites, c\'est qu\'ils sont dessinés à l\'intérieur d\'un rectangle, que ce soit dans une planche de sprites ou ailleurs. Pour l\'instant, imagine un sprite simplement dessiné sur une planche de sprites, pas encore intégré dans un décor.<br>\n<br>\nDans ce rectangle, il faut distinguer deux éléments :<br>\n<br>\n<span class=\"bold\"><span class=\"underline\">Le sprite lui-même :</span></span> composé de plusieurs octets qui définissent sa forme et ses détails.<br>\n<span class=\"bold\"><span class=\"underline\">Le fond qui entoure le sprite :</span></span> constitué d\'octets qui ont tous la même valeur, puisque c\'est un fond uni.<br>\nCes octets représentent des <span class=\"bold\"><span class=\"color-red\">valeurs qui correspondent aux 16 encres</span></span> disponibles sur l\'Atari ST <span class=\"italic\">(pour le STE, on verra ça une autre fois)</span>. Il est important de comprendre que ces valeurs sont en réalité des numéros d\'encre, <span class=\"underline\">pas des numéros de couleur</span>. Les couleurs elles-mêmes ne nous intéressent pas ici.<br>\nLes valeurs des encres vont de <span class=\"bold\">%0000</span> <span class=\"italic\">(soit $00)</span> à <span class=\"bold\">$1111</span> <span class=\"italic\">(soit $FF)</span>. C\'est ici que les opérations logiques entrent en jeu pour gérer l\'affichage des sprites.', NULL, NULL, NULL, '', '', '', 1, 4, 21),
(311, 'Affichage de la silouhette ', '', '', 'Il faudra créer une planche de sprites avec, d\'une part, le sprite lui-même, et d\'autre part, son masque, et ce, pour chaque sprite. <span class=\"italic\">(Pour savoir comment faire, consulte le tutoriel <a class=\"link\" href=\"https://www.asmtariste.fr/article-content/17/1\" target=\"blank\">\"Créer une planche de sprites\"</a>)</span>.<br>\n<br>\nLa méthode la plus courante consiste à créer un masque qui rend la zone rectangulaire contenant le sprite transparente <span class=\"italic\">(c\'est-à-dire non affichée)</span>. Pour cela, il faut sacrifier une encre, et c\'est le rôle de l\'encre 15, qui se traduit en binaire par des bits à 1 : %1111 ($F).<br>\n<br>\n<div class=\"border-green\"><p><br>\n<span class=\"bold\">Note :</span><br>\nLes encres de 0 à 15 sont encodées sur seulement 4 bits.<br>\nUn octet peut donc contenir 2 pixels, soit 2 encres.</p></div>', '', '', NULL, '1723582279085.png', NULL, '', '', '', 1, 1, 21),
(312, '', '', '', '', '', 'Nous avons vu qu\'une opération logique effectuée avec un <span class=\"bold\">AND</span> permet de <span class=\"underline\">garder les bits à 1 et 0 intacts lorsqu\'ils sont comparés à un bit de valeur 0</span>. Cela tombe bien, car notre silhouette est remplie de 0 ! Et notre décor est rempli de bits à 1 et à 0.<br>\n<br>\nAdmettons que tu ais un décor déjà affiché à l\'écran et que tu en lis un octet <span class=\"italic\">(donc 2 encres, comme 6 et 11)</span>, par exemple <span class=\"bold\">%01101011</span>, et que tu compares cet octet avec l\'encre zéro <span class=\"bold\">%00000000</span> du sprite dans la planche de sprites, le résultat sera <span class=\"underline\">une mise à zéro de tous les bits (qu\'ils soient à 1 ou 0)</span>.<br>\nSi tu affiches ce résultat à l\'écran, c\'est la couleur de l\'encre 0 qui sera utilisée pour afficher cette silhouette :<br>\n<span class=\"code\">; opération AND <br>\nmove.b #%00000000,d0     ; un octet de la silouhette <br>\nand.b #%01101011,d0    ; AND avec un octet de l\'écran<br>\n; d0 = %00000000</span><br>\n<br>\nPour le masque, c\'est pareil : on utilise des bits à 1 pour l\'encre 15 : <span class=\"bold\">%11111111</span>. Ainsi, si on compare ces bits avec les encres utilisées dans le décor, <span class=\"bold\"><span class=\"underline\">les 1 resteront des 1 et les 0 resteront des 0</span></span>.<br>\n<span class=\"code\">; opération AND <br>\nmove.b #%11111111,d0     ; un octet du masque <br>\nand.b #%01101011,d0    ; AND avec un octet de l\'écran<br>\n; d0 = %01101011</span><br>\n<br>\nLe décor reste donc intact.', NULL, NULL, NULL, '', '', '', 1, 4, 21),
(314, '', '', '', '', '', '', NULL, NULL, '1723582669042.png', '', '', '', 1, 5, 21),
(315, '', '', 'OR (OU)', '', '', 'C\'est fait ! Tu as maintenant un trou dans le décor, un peu comme si Sonic devenait un fantôme... flippant, non ? Ce trou est rempli d\'encre 0. Nous devons maintenant y afficher un sprite dont le contour rectangulaire est également rempli d\'encre 0.<br>\n<br>\nSi un AND permettait de garder les bits à 1 et 0 intacts lorsqu\'ils sont comparés à un bit de valeur 0 et bien pour le <span class=\"bold\">OR</span> c\'est presque l\'inverse : <span class=\"underline\">on garde les bits qui sont à 1 et 0 intacts quand ils sont comparé à eux même</span>. Mais comparer 2 bits différent, le bit 1 reste prioritaire. Voici comment elle fonctionne :<br>\n<span class=\"bold\">1 OR 1 = 1<br>\n1 OR 0 = 1<br>\n0 OR 1 = 1<br>\n0 OR 0 = 0</span><br>\n<br>\nReprenons un décor déjà affiché à l\'écran et que tu en lis un octet (donc 2 encres, comme 6 et 11), par exemple <span class=\"bold\">%01101011</span>, et que tu compares cet octet avec l\'encre zéro <span class=\"bold\">%00000000</span> du sprite dans la planche de sprites <span class=\"italic\">(en gros le rectangle dans lequel le sprite est inclus)</span>, le résultat sera opération null : les bits resterons inchangées ! <br>\n<span class=\"code\">; opération OR <br>\nmove.b #%01101011,d0     ; un octet de l\'écran<br>\nor.b #%00000000,d0    ; OR avec un octet rectangle du sprite<br>\n; d0 = %01101011</span><br>\n<br>\nEt à l\'inverse les octets de la silhouette étant tous en encre 0, comparé aux octets du sprite constituée de 0 et 1 : opération null également ! <br>\n<span class=\"code\">; opération OR <br>\nmove.b #%01101011,d0     ; un octet du sprite<br>\nor.b #%00000000,d0    ; OR avec un octet de la silhouette<br>\n; d0 = %01101011</span><br>\n<br>\nSi tu affiches ce résultat à l\'écran, c\'est la couleur des encre qui ne sont pas à 0 qui seront utilisée pour afficher le sprite !<br>\n', NULL, NULL, NULL, '', '', '', 2, 4, 21),
(316, '', '', '', '', '', '', NULL, NULL, '1723586320503.png', '', '', '', 2, 5, 21),
(317, '', '', 'Fichiers Sources', '', '', '<a class=\"link\" href=\"https://www.asmtariste.fr/assets/files/sources/PROG_ASM.003.zip\" target=\"blank\">Voici les fichiers sources du cours à télécharger</a>', NULL, NULL, NULL, '', '', '', 2, 4, 21),
(319, '', '', 'Hardware versus Software', '', '', '<div class=\"border-red\"><p><span class=\"bold\">Attention, dans ce cours, nous allons aborder plus de sujets que d\'habitude, alors ne va pas trop vite. Prends le temps de tester chaque partie de ce cours, et évite de lire en diagonale ou de répondre au questionnaire sans avoir vraiment suivi tous les autres cours et celui-ci dans son intégralité.</span></p></div><br>\n<br>\nNous allons aborder des concepts importants que l\'on retrouve dans de nombreux jeux de l\'époque. D\'ailleurs, dans la description de cet article, je t\'ai parlé de \"sprites hard\", et tu te demandes peut-être ce que c\'est ? Eh bien, si l\'on prend des machines comme le <span class=\"hashtag\">Commodore 64</span>, l\'<span class=\"hashtag\">Amiga 500</span>, ou encore les consoles de <span class=\"hashtag\">Nintendo</span> et <span class=\"hashtag\">Sega</span>, elles possèdent parmi leurs composants des puces qui permettent d\'afficher et de stocker des sprites sans que le microprocesseur ait besoin de calculer quoi que ce soit pour les afficher : on gagne ainsi énormément de temps machine <span class=\"italic\">(j\'ai vulgarisé mais en gros c\'est çà)</span>.<br>\n<br>\nDe plus, tu te souviens du cours concernant le masquage des sprites ? Ces machines n\'ont pas besoin de masquer quoi que ce soit, étant donné que les sprites ont leur propre palette et donc une couleur transparente <span class=\"italic\">(c\'est le cas, par exemple, de la série Plus des <span class=\"hashtag\">Amstrad</span> ainsi que de la <span class=\"hashtag\">GX4000</span>)</span>.<br>\n<br>\nEn revanche, pour l\'<span class=\"hashtag\">Atari ST</span> : rien de ce côté-là. Idem pour le STE, même si certains efforts ont été faits sur d\'autres aspects <span class=\"italic\">(on peut aussi ajouter des ordinateurs tels que l\'<span class=\"hashtag\">Amstrad CPC</span> et le <span class=\"hashtag\">ZX Spectrum</span>)</span>.<br>\nOn va devoir tout faire à la main !', NULL, NULL, NULL, '', '', '', 1, 4, 24);

-- --------------------------------------------------------

--
-- Structure de la table `disk_units`
--

CREATE TABLE `disk_units` (
  `id_disk_units` int(11) NOT NULL,
  `label` varchar(50) DEFAULT NULL,
  `letter` varchar(50) DEFAULT NULL,
  `icon` varchar(50) DEFAULT NULL,
  `isDisplay` tinyint(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `disk_units`
--

INSERT INTO `disk_units` (`id_disk_units`, `label`, `letter`, `icon`, `isDisplay`) VALUES
(1, 'Coding', 'C', NULL, 1),
(2, 'System', 'A', NULL, 1),
(3, 'Graphismes', 'B', NULL, 1),
(4, 'PAO', 'D', NULL, 1),
(5, 'Utilitaires', 'E', NULL, 1),
(6, 'Musiques', 'F', NULL, 1);

-- --------------------------------------------------------

--
-- Structure de la table `files`
--

CREATE TABLE `files` (
  `id_files` int(11) NOT NULL,
  `name` varchar(128) DEFAULT NULL,
  `isDisplay` tinyint(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `files`
--

INSERT INTO `files` (`id_files`, `name`, `isDisplay`) VALUES
(1, 'TOS v1.00 (1986)(Atari Corp)(ST)(Fr).zip', 1),
(2, 'TOS v1.06 (1989)(Atari Corp)(STE)(Fr).zip', 1),
(3, 'TOS v1.62 (1990)(Atari Corp)(STE)(Fr).zip', 1),
(4, 'TOS 1.00_1.06_1.62_EMUTOS_Atrai [Fr].zip', 1),
(5, 'ACSI_harddrive_image.80.zip', 1),
(6, 'Devpac v3.10 (1992)(HiSoft).zip', 1),
(7, 'GFA Basic v3.6 (GFA Systemtechnik).zip', 1),
(8, 'Lattice C ST v5.60 (HiSoft)(Disk1a7).zip', 1),
(9, 'Pure C (Application Systems Heidelberg)(Disk1a3).zip', 1),
(10, 'Advanced OCP Art Studio.zip', 1),
(11, 'Advanced OCP Art Studio (manual).zip', 1),
(12, 'Quantum Paint v2.00.zip', 1),
(13, 'NEOchrome Master v2.28.zip', 1),
(15, 'Degas Elite v1.1.zip', 1),
(16, '1st Word Plus v3.20.zip', 1),
(17, 'Redacteur v4.0beta24 (Disk1 Ã  9).zip', 1),
(18, 'M-Disk v6.0.zip', 1),
(19, 'Ripper v3.1.zip', 1),
(21, 'SysInfo v8.20.zip', 1),
(22, 'DeluxePaint_v1.00_Disk1a3.zip', 1),
(23, 'FiveToFive v2.13.zip', 1),
(24, 'DigitalImpact v1.2.zip', 1),
(25, 'MaxYMiserFM v1.62.zip', 1),
(26, 'Replay v3.zip', 1);

-- --------------------------------------------------------

--
-- Structure de la table `menu`
--

CREATE TABLE `menu` (
  `id_menu` int(11) NOT NULL,
  `name` varchar(50) DEFAULT NULL,
  `link` varchar(50) DEFAULT NULL,
  `place` tinyint(4) DEFAULT NULL,
  `isDisplay` tinyint(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `menu`
--

INSERT INTO `menu` (`id_menu`, `name`, `link`, `place`, `isDisplay`) VALUES
(1, 'accueil', '/accueil', 1, NULL),
(2, 'news', '/news', 2, NULL),
(3, 'coding', '/coding', 3, NULL),
(4, 'documentation', '/documentation', 4, NULL),
(5, 'certificates', '/certificates', 5, NULL),
(6, 'informations', '/informations', 7, NULL),
(7, 'tutorials', '/tutorials', 6, NULL);

-- --------------------------------------------------------

--
-- Structure de la table `menu_admin`
--

CREATE TABLE `menu_admin` (
  `id_menu_admin` int(11) NOT NULL,
  `name` varchar(50) DEFAULT NULL,
  `link` varchar(50) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `menu_admin`
--

INSERT INTO `menu_admin` (`id_menu_admin`, `name`, `link`) VALUES
(1, 'Menu', '/menu-setting'),
(2, 'Articles', '/all-articles'),
(4, 'Dossiers', '/disk-units-setting'),
(5, 'Fichiers', '/unit-files-setting'),
(6, 'Utilisateurs', '/all-users'),
(7, 'Certificats', '/all-certificates');

-- --------------------------------------------------------

--
-- Structure de la table `questions`
--

CREATE TABLE `questions` (
  `id_questions` int(11) NOT NULL,
  `text` varchar(256) DEFAULT NULL,
  `id_articles` int(11) DEFAULT NULL,
  `isMultiple` tinyint(1) DEFAULT 0
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `questions`
--

INSERT INTO `questions` (`id_questions`, `text`, `id_articles`, `isMultiple`) VALUES
(1, 'Qu\'est-ce qu\'un émulateur ?', 4, 0),
(2, 'À quoi sert un Ultra Satan ?', 4, 0),
(3, 'Quel est le seul système de numérotation que l\'ordinateur comprend ?', 4, 0),
(4, 'À quoi sert un éditeur de texte ?', 4, 0),
(5, 'Quel est le rôle principal d\'un assembleur ?', 4, 0),
(6, 'Que devient le code saisi dans l\'éditeur après l\'assemblage ?', 4, 0),
(7, 'Où est stocké le code source saisi dans l\'éditeur ?', 4, 0),
(8, 'Comment s\'appelle l\'assembleur édité par Hisoft ?', 4, 0),
(9, 'Comment se nomme ce bureau tout vert lorsque l\'on allume un Atari ST ?', 4, 0),
(10, 'Que désigne le TOS ?', 4, 0),
(11, 'Que désigne ASCI pour l\'Atari ST ?', 4, 0),
(12, 'Quelle est la valeur décimale du nombre binaire suivant\n`%11001011` ?', 5, 0),
(13, 'Convertir le nombre décimal `75` en hexadécimal donne :', 5, 0),
(14, 'Quelle est la valeur binaire du nombre hexadécimal `$A3` ?', 5, 0),
(15, 'Quel est le résultat de la conversion binaire `%11100000` en décimal ?', 5, 0),
(16, 'Quelle est la valeur en décimal du bit 7 ?', 5, 0),
(17, 'Quel est l\'octet de poids faible dans la valeur 16 bits `%00001010 00000101` ?', 5, 0),
(18, 'Quelle est la représentation hexadécimale de la valeur décimale `255` ?', 5, 0),
(19, 'Quelle est la valeur binaire du nombre décimal `167` ?', 5, 0),
(20, 'Quel est le quartet de poids fort dans l\'octet binaire `%01101001` ?', 5, 0),
(21, 'Lorsqu\'on convertit le nombre binaire `%00000001 11111111` en décimal, quelle est la valeur totale ?', 5, 0),
(22, 'Que dois-tu faire pour lire le contenu de la disquette de l\'unité A ?', 8, 0),
(23, 'Le programme DevPac peux être installé sur quel support ?', 8, 1),
(24, 'Quels sont les raccourcis clavier pour sauvegarder un fichier dans DevPac ?', 8, 1),
(25, 'Que faire si tu rencontres un problème avec le pavé numérique dans DevPac ?', 8, 0),
(26, 'Comment associer les fichiers sources avec DevPac pour une ouverture rapide ?', 8, 0),
(27, 'Quelle est la différence principale entre la RAM et la ROM ?', 10, 1),
(28, 'Quels sont les différents types de configurations de RAM possibles sur un Atari 1040STe ?', 10, 1),
(29, 'Que représente la valeur hexadécimale $003F8000 dans la mémoire ?', 10, 1),
(30, 'Quels sont les adresses de fin de RAM pour les configurations suivantes : 512 Ko, 1 Mo, 2 Mo, et 4 Mo ?', 10, 0),
(31, 'Dans quelle zone de la RAM le framebuffer est il placé par le TOS quelque soit la configuration ?', 10, 0),
(32, 'Quelle est la fonction de l\'outil The Ripper v3.1 ?', 10, 0),
(33, 'Comment naviguer entre les différentes fenêtres dans DevPac et quel est le raccourci pour ouvrir le débogueur ?', 10, 0),
(34, 'Que représente la valeur $003F8000 affichée à ladresse $44E ?', 10, 1),
(35, 'Pourquoi est-il important de comprendre et visualiser la disposition de la mémoire et des adresses de la RAM ?', 10, 0),
(36, 'Quelles sont les deux catégories principales de registres dans le processeur 68000 ?', 11, 0),
(37, 'Quelle instruction permet d\'envoyer une valeur dans un registre ?', 11, 0),
(38, 'Quelle différence majeure existe-t-il entre les deux catégories de registres mentionnées dans la question 1 ?', 11, 1),
(39, 'Quelle valeur peut-on envoyer dans un registre avec move.b ?', 11, 1),
(40, 'Je veux envoyer la valeur 548 dans un registre, quelle syntaxe est incorrecte ?', 11, 0),
(41, 'Quelles sont les bonnes définitions concernant le registre a7 ?', 11, 1),
(42, 'À quoi servent les suffixes .b, .w et .l ?', 11, 0),
(43, 'J\'ai la valeur $85F0 dans D0, à laquelle je souhaite ajouter la valeur $4, quelles syntaxes sont les bonnes ?', 11, 1),
(44, 'Que signifie l\'instruction move.l d0, (a0)+ ?', 11, 0),
(45, 'Quel est l\'autre nom du registre de la pile ?', 11, 1),
(46, 'Quel est le rôle de la fonction `Pterm0()` dans un programme assembleur ?', 14, 0),
(47, 'Quelle section doit contenir les données initialisées dans un programme assembleur ?', 14, 0),
(48, 'Quelle instruction permet d\'inclure un fichier binaire dans un programme assembleur ?', 14, 0),
(49, 'Quel appel système est utilisé pour changer la résolution de l\'écran dans le TOS ?', 14, 0),
(50, 'Quels sont les octets qui correspondent à la palette dans une image PI1 ?', 14, 0),
(51, 'Quels paramètres sont utilisés par la fonction `Setscreen()` du XBIOS pour changer la résolution de l\'écran ?', 14, 1),
(52, 'Que fait l\'instruction `move.l (a0)+,(a1)+` en assembleur ?', 14, 1),
(53, 'Quelles sections doivent être utilisées pour placer le code exécutable et les variables non initialisées ?', 14, 1),
(55, 'Quelle valeur est utilisée pour l\'écran physique et l\'écran logique lorsqu\'on ne veut pas les changer avec `Setscreen()` ?', 14, 0),
(56, 'Quelle directive permet de définir une constante dans un programme assembleur ?', 14, 0),
(57, 'Quelle instruction permet de retourner à l\'adresse suivant celle à laquelle l\'appel BSR a été invoqué ?', 14, 0),
(58, 'Que fait l\'instruction `DBF` en assembleur ?', 14, 0),
(59, 'Comment inclure un fichier source dans un autre pour éviter des fichiers trop longs ?', 14, 0),
(60, 'Quelle fonction GEMDOS attend la pression d\'une touche du clavier et renvoie son code hexadécimal ?', 14, 0),
(61, 'Quelle est la façon de calculer l\'offset pour localiser une ligne spécifique dans le framebuffer de l\'Atari ST ?', 18, 1),
(62, 'Combien de groupes de 16 pixels sont présents sur une ligne de l\'écran Atari ST ?', 18, 0),
(63, 'Quelle est la directive d\'assemblage utilisée pour réserver de la mémoire pour des données non initialisées ?', 18, 0),
(64, 'Comment calcule-t-on l\'adresse du sprite dans une image en mémoire connaissant sa position Y ?', 18, 0),
(65, 'Quel est le but de la fonction XBIOS Logbase() dans le contexte de l\'Atari ST ?', 18, 0),
(66, 'Pourquoi est-il important de masquer les pixels indésirables autour d\'un sprite lorsqu\'il est affiché sur un fond ?', 21, 1),
(67, 'Quelle opération logique est utilisée pour créer une silhouette du sprite qui rend la zone rectangulaire contenant le sprite transparente ?', 21, 0),
(68, 'Comment l\'opération AND affecte-t-elle les bits d\'un octet lorsqu\'un bit de valeur 0 est comparé à un autre bit ?', 21, 0),
(69, 'Quelle est la fonction principale de l\'encre 15 dans le contexte du masquage de sprites ?', 21, 0),
(70, 'Lorsqu\'une opération AND est effectuée entre un octet du fond et un octet du masque de sprite constitué uniquement de bits à 1, quel est le résultat attendu ?', 21, 0),
(71, 'Quelles valeurs les encres peuvent-elles prendre dans le contexte de l\'Atari ST ?', 21, 0),
(72, 'Quelle opération logique est utilisée pour superposer un sprite sur un fond après que le masque a créé une silhouette dans le décor ?', 21, 0),
(73, 'Comment l\'opération OR affecte-t-elle un octet du fond comparé au contour du sprite contenant l\'encre 0 ?', 21, 0);

-- --------------------------------------------------------

--
-- Structure de la table `role`
--

CREATE TABLE `role` (
  `id_role` int(11) NOT NULL,
  `name` varchar(50) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `role`
--

INSERT INTO `role` (`id_role`, `name`) VALUES
(0, 'ghost'),
(1, 'administrateur'),
(2, 'utilisateur');

-- --------------------------------------------------------

--
-- Structure de la table `tags`
--

CREATE TABLE `tags` (
  `id_tags` int(11) NOT NULL,
  `color` varchar(10) DEFAULT NULL,
  `label` varchar(50) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `tags`
--

INSERT INTO `tags` (`id_tags`, `color`, `label`) VALUES
(1, '#FF5733', 'Basic'),
(2, '#FF6F61', 'ASM'),
(3, '#FFD700', '68000'),
(4, '#00FF7F', 'Atari'),
(5, '#00FFFF', 'Sprite'),
(6, '#1E90FF', 'XBIOS'),
(7, '#FF1493', 'BIOS'),
(8, '#ADFF2F', 'GEMDOS'),
(9, '#FF4500', 'Line-A'),
(10, '#32CD32', 'VDI'),
(11, '#8A2BE2', 'AES'),
(12, '#00BFFF', 'X CONTROL'),
(13, '#FF6347', 'Emulateurs'),
(14, '#FF69B4', 'Scrolling'),
(15, '#FFDAB9', 'Blitter'),
(16, '#4B0082', 'Interruptions'),
(17, '#FF1493', 'TOS'),
(18, '#9400D3', 'Octet'),
(19, '#FFD700', 'Décimal'),
(20, '#7CFC00', 'Binaire'),
(21, '#FF4500', 'Hexadécimal'),
(22, '#7FFFD4', 'Bit');

-- --------------------------------------------------------

--
-- Structure de la table `templates`
--

CREATE TABLE `templates` (
  `id_templates` int(11) NOT NULL,
  `isTitleLeft` tinyint(1) DEFAULT NULL,
  `isTitleRight` tinyint(1) DEFAULT NULL,
  `isTitleCenter` tinyint(1) DEFAULT NULL,
  `isTextLeft` tinyint(1) DEFAULT NULL,
  `isTextRight` tinyint(1) DEFAULT NULL,
  `isTextCenter` tinyint(1) DEFAULT NULL,
  `isImageLeft` tinyint(1) DEFAULT NULL,
  `isImageRight` tinyint(1) DEFAULT NULL,
  `isImageCenter` tinyint(1) DEFAULT NULL,
  `isAttachementLeft` tinyint(1) DEFAULT NULL,
  `isAttachementRight` tinyint(1) DEFAULT NULL,
  `isAttachementCenter` tinyint(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `templates`
--

INSERT INTO `templates` (`id_templates`, `isTitleLeft`, `isTitleRight`, `isTitleCenter`, `isTextLeft`, `isTextRight`, `isTextCenter`, `isImageLeft`, `isImageRight`, `isImageCenter`, `isAttachementLeft`, `isAttachementRight`, `isAttachementCenter`) VALUES
(1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0),
(2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0),
(3, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0),
(4, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0),
(5, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0),
(6, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0),
(7, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0),
(8, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0),
(9, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0);

-- --------------------------------------------------------

--
-- Structure de la table `to_contain`
--

CREATE TABLE `to_contain` (
  `id_disk_units` int(11) NOT NULL,
  `id_files` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `to_contain`
--

INSERT INTO `to_contain` (`id_disk_units`, `id_files`) VALUES
(1, 6),
(1, 7),
(1, 8),
(1, 9),
(2, 1),
(2, 2),
(2, 3),
(2, 4),
(2, 5),
(3, 10),
(3, 11),
(3, 12),
(3, 13),
(3, 15),
(3, 22),
(4, 16),
(4, 17),
(5, 18),
(5, 19),
(5, 21),
(6, 23),
(6, 24),
(6, 25),
(6, 26);

-- --------------------------------------------------------

--
-- Structure de la table `to_graduate`
--

CREATE TABLE `to_graduate` (
  `id_articles` int(11) NOT NULL,
  `id_users` int(11) NOT NULL,
  `id_certificates` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `to_graduate`
--

INSERT INTO `to_graduate` (`id_articles`, `id_users`, `id_certificates`) VALUES
(4, 3, 8),
(4, 6, 59),
(4, 7, 10),
(4, 10, 9),
(4, 11, 23),
(4, 15, 31),
(4, 18, 55),
(5, 3, 11),
(5, 7, 12),
(5, 10, 17),
(5, 11, 25),
(5, 15, 30),
(5, 18, 54),
(8, 3, 53),
(8, 7, 15),
(8, 10, 43),
(8, 11, 24),
(8, 15, 32),
(8, 18, 57),
(10, 3, 40),
(10, 7, 16),
(10, 10, 18),
(10, 11, 22),
(10, 15, 33),
(10, 18, 58),
(11, 3, 41),
(11, 7, 20),
(11, 10, 44),
(11, 11, 21),
(11, 15, 34),
(14, 3, 42),
(14, 7, 27),
(14, 10, 45),
(14, 11, 38),
(14, 15, 35),
(18, 3, 52),
(18, 7, 29),
(18, 10, 46),
(18, 11, 39),
(18, 15, 36),
(21, 3, 51),
(21, 7, 50),
(21, 15, 56);

-- --------------------------------------------------------

--
-- Structure de la table `to_have`
--

CREATE TABLE `to_have` (
  `id_articles` int(11) NOT NULL,
  `id_tags` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `to_have`
--

INSERT INTO `to_have` (`id_articles`, `id_tags`) VALUES
(1, 4),
(2, 7),
(3, 17),
(4, 13),
(5, 18),
(5, 19),
(5, 20),
(5, 21),
(5, 22),
(6, 4),
(7, 6),
(7, 7),
(7, 8),
(8, 2),
(8, 4),
(9, 4),
(10, 3),
(10, 4),
(11, 2),
(11, 3),
(12, 2),
(12, 3),
(13, 4),
(14, 2),
(14, 3),
(14, 6),
(15, 6),
(16, 8),
(17, 4),
(17, 5),
(18, 2),
(18, 3),
(18, 5),
(19, 2),
(19, 4),
(20, 8),
(21, 2),
(21, 3),
(21, 5),
(24, 2),
(24, 3),
(24, 5);

-- --------------------------------------------------------

--
-- Structure de la table `users`
--

CREATE TABLE `users` (
  `id_users` int(11) NOT NULL,
  `username` varchar(50) DEFAULT NULL,
  `email` varchar(50) DEFAULT NULL,
  `hashpassword` varchar(265) DEFAULT NULL,
  `isActivated` tinyint(1) DEFAULT NULL,
  `firstname` varchar(50) DEFAULT NULL,
  `lastname` varchar(50) DEFAULT NULL,
  `registrationDate` date DEFAULT NULL,
  `id_role` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Déchargement des données de la table `users`
--

INSERT INTO `users` (`id_users`, `username`, `email`, `hashpassword`, `isActivated`, `firstname`, `lastname`, `registrationDate`, `id_role`) VALUES
(1, 'zisquier', 'tbressel.dev@gmail.com', '$2a$10$8WECOsML1uyIZPxqdKphaeg3kvM7kZmm/xysUcGAW6S4r5nA2LIrW', 1, 'null', 'null', '2024-06-27', 1),
(3, 'Shaoth', 'edamain@gmail.com', '$2a$10$DByJyQypaeg5r9hu1P2hweWmuY.lnteBIzZsidsEiJLw.pEVAdPvi', 1, 'null', 'null', '2024-07-05', 2),
(5, 'Darian', 'jm.piamiat@gmail.com', '$2a$10$1obq.WkC2Rng9DKJvnEn1.2qJx83kFmlABAIMRT2knAIxSC0h4AU2', 1, 'null', 'null', '2024-07-10', 2),
(6, 'duruti', 'duruti43@gmail.com', '$2a$10$VxkPQdGv0k30EdiPJOocH.CHpg/HwahHxIc/cT1V2E5zdkgpCoA7i', 1, 'null', 'null', '2024-07-10', 2),
(7, 'Mokona', 'mokona@zaclys.net', '$2a$10$LXsMkkqAfUBpIPyH9aIuRehFbdr8f8w4zCOM/PrymUBIG77.1Bo0.', 1, 'null', 'null', '2024-07-10', 2),
(8, 'caviar56', 'nprou1@free.fr', '$2a$10$Zi.mbB2zriA/TiKqDuhlzON8zGNe4DGkSa/QtLbkSO4tfqV9RtR.y', 1, 'null', 'null', '2024-07-10', 2),
(9, 'pasou94', 'pascalsou@hotmail.com', '$2a$10$CMrc5URcT4y.jqNHythVy.WkerA2ZKMuakOXdXS9hhQJtKUE8mON.', 1, 'null', 'null', '2024-07-11', 2),
(10, 'dlfrsilver', 'dlfrsilver@gmail.com', '$2a$10$GujEGaFT7MJXoxX5RZWUYua1iMOuO.jHBcPJyeElR6gZkYZOVhBc.', 1, 'null', 'null', '2024-07-15', 2),
(11, 'Freddo', 'freddo@etik.com', '$2a$10$R.bpMXyq1tjw9iX.ciRl4ugLVd.92Dxx1CAQgHlxt475JBBKYCBPy', 1, 'null', 'null', '2024-08-01', 2),
(12, 'vinz', 'vincent.barrilliot@laposte.net', '$2a$10$OwL9nL2a5/mshO2l5QcqkulmrLK4pcQUebvvt2WDdpYNwzZHx/7m6', 1, 'null', 'null', '2024-08-01', 2),
(13, NULL, NULL, NULL, 0, NULL, NULL, '2024-08-04', 0),
(14, 'Soutarson', 'soutpasc@gmail.com', '$2a$10$WpTdNoNqF02c981owdnmkedd5jAAki3QlnBBrmUPjPqRFS1p0awTq', 1, 'null', 'null', '2024-08-07', 2),
(15, 'mara', 'maraflush@gmail.com', '$2a$10$wIvFM.lMAWS80dz4rDdpJ.yecSFwtX1rgedXr1BTeH/Klcjn7fDTe', 1, 'null', 'null', '2024-08-11', 2),
(16, 'jojo', 'jojo@yopmail.com', '$2a$10$PQ5z.la.cW1mu/c8ctKQf.Lm9Y/xM7cPqJPyQSSAdPEjr0/aHWdy.', 1, 'null', 'null', '2024-08-11', 2),
(17, NULL, NULL, NULL, 0, NULL, NULL, '2024-08-12', 0),
(18, 'PapyVador', 'lebon2612@googlemail.com', '$2a$10$ydfMWcE1JAxLUlYP4JNbpuHhClGhVOOZdYYjspgACEYL41nNvf6XG', 1, 'null', 'null', '2024-08-15', 2),
(19, 'gloky', 'mrgloky@gmail.com', '$2a$10$XdYbRl/rrRCuUnBunrlT4uBk09ifrTlf7y..HlEQhJbiW7z30nwSi', 1, 'null', 'null', '2024-08-15', 2);

--
-- Index pour les tables déchargées
--

--
-- Index pour la table `articles`
--
ALTER TABLE `articles`
  ADD PRIMARY KEY (`id_articles`),
  ADD KEY `id_categories` (`id_categories`),
  ADD KEY `id_users` (`id_users`);

--
-- Index pour la table `categories`
--
ALTER TABLE `categories`
  ADD PRIMARY KEY (`id_categories`);

--
-- Index pour la table `certificates`
--
ALTER TABLE `certificates`
  ADD PRIMARY KEY (`id_certificates`);

--
-- Index pour la table `choices`
--
ALTER TABLE `choices`
  ADD PRIMARY KEY (`id_choices`),
  ADD KEY `id_questions` (`id_questions`);

--
-- Index pour la table `contents`
--
ALTER TABLE `contents`
  ADD PRIMARY KEY (`id_contents`),
  ADD KEY `id_templates` (`id_templates`),
  ADD KEY `id_articles` (`id_articles`);

--
-- Index pour la table `disk_units`
--
ALTER TABLE `disk_units`
  ADD PRIMARY KEY (`id_disk_units`);

--
-- Index pour la table `files`
--
ALTER TABLE `files`
  ADD PRIMARY KEY (`id_files`);

--
-- Index pour la table `menu`
--
ALTER TABLE `menu`
  ADD PRIMARY KEY (`id_menu`);

--
-- Index pour la table `menu_admin`
--
ALTER TABLE `menu_admin`
  ADD PRIMARY KEY (`id_menu_admin`);

--
-- Index pour la table `questions`
--
ALTER TABLE `questions`
  ADD PRIMARY KEY (`id_questions`),
  ADD KEY `id_articles` (`id_articles`);

--
-- Index pour la table `role`
--
ALTER TABLE `role`
  ADD PRIMARY KEY (`id_role`);

--
-- Index pour la table `tags`
--
ALTER TABLE `tags`
  ADD PRIMARY KEY (`id_tags`);

--
-- Index pour la table `templates`
--
ALTER TABLE `templates`
  ADD PRIMARY KEY (`id_templates`);

--
-- Index pour la table `to_contain`
--
ALTER TABLE `to_contain`
  ADD PRIMARY KEY (`id_disk_units`,`id_files`),
  ADD KEY `id_files` (`id_files`);

--
-- Index pour la table `to_graduate`
--
ALTER TABLE `to_graduate`
  ADD PRIMARY KEY (`id_articles`,`id_users`,`id_certificates`),
  ADD KEY `id_users` (`id_users`),
  ADD KEY `id_certificates` (`id_certificates`);

--
-- Index pour la table `to_have`
--
ALTER TABLE `to_have`
  ADD PRIMARY KEY (`id_articles`,`id_tags`),
  ADD KEY `id_tags` (`id_tags`);

--
-- Index pour la table `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id_users`),
  ADD KEY `id_role` (`id_role`);

--
-- AUTO_INCREMENT pour les tables déchargées
--

--
-- AUTO_INCREMENT pour la table `articles`
--
ALTER TABLE `articles`
  MODIFY `id_articles` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=25;

--
-- AUTO_INCREMENT pour la table `categories`
--
ALTER TABLE `categories`
  MODIFY `id_categories` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- AUTO_INCREMENT pour la table `certificates`
--
ALTER TABLE `certificates`
  MODIFY `id_certificates` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=60;

--
-- AUTO_INCREMENT pour la table `choices`
--
ALTER TABLE `choices`
  MODIFY `id_choices` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=258;

--
-- AUTO_INCREMENT pour la table `contents`
--
ALTER TABLE `contents`
  MODIFY `id_contents` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=320;

--
-- AUTO_INCREMENT pour la table `disk_units`
--
ALTER TABLE `disk_units`
  MODIFY `id_disk_units` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=7;

--
-- AUTO_INCREMENT pour la table `files`
--
ALTER TABLE `files`
  MODIFY `id_files` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=27;

--
-- AUTO_INCREMENT pour la table `menu`
--
ALTER TABLE `menu`
  MODIFY `id_menu` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=8;

--
-- AUTO_INCREMENT pour la table `menu_admin`
--
ALTER TABLE `menu_admin`
  MODIFY `id_menu_admin` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=8;

--
-- AUTO_INCREMENT pour la table `questions`
--
ALTER TABLE `questions`
  MODIFY `id_questions` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=74;

--
-- AUTO_INCREMENT pour la table `role`
--
ALTER TABLE `role`
  MODIFY `id_role` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- AUTO_INCREMENT pour la table `tags`
--
ALTER TABLE `tags`
  MODIFY `id_tags` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=23;

--
-- AUTO_INCREMENT pour la table `templates`
--
ALTER TABLE `templates`
  MODIFY `id_templates` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=10;

--
-- AUTO_INCREMENT pour la table `users`
--
ALTER TABLE `users`
  MODIFY `id_users` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=20;

--
-- Contraintes pour les tables déchargées
--

--
-- Contraintes pour la table `articles`
--
ALTER TABLE `articles`
  ADD CONSTRAINT `articles_ibfk_1` FOREIGN KEY (`id_categories`) REFERENCES `categories` (`id_categories`),
  ADD CONSTRAINT `articles_ibfk_2` FOREIGN KEY (`id_users`) REFERENCES `users` (`id_users`);

--
-- Contraintes pour la table `choices`
--
ALTER TABLE `choices`
  ADD CONSTRAINT `choices_ibfk_1` FOREIGN KEY (`id_questions`) REFERENCES `questions` (`id_questions`);

--
-- Contraintes pour la table `contents`
--
ALTER TABLE `contents`
  ADD CONSTRAINT `contents_ibfk_1` FOREIGN KEY (`id_templates`) REFERENCES `templates` (`id_templates`),
  ADD CONSTRAINT `contents_ibfk_2` FOREIGN KEY (`id_articles`) REFERENCES `articles` (`id_articles`);

--
-- Contraintes pour la table `questions`
--
ALTER TABLE `questions`
  ADD CONSTRAINT `questions_ibfk_1` FOREIGN KEY (`id_articles`) REFERENCES `articles` (`id_articles`);

--
-- Contraintes pour la table `to_contain`
--
ALTER TABLE `to_contain`
  ADD CONSTRAINT `to_contain_ibfk_1` FOREIGN KEY (`id_disk_units`) REFERENCES `disk_units` (`id_disk_units`),
  ADD CONSTRAINT `to_contain_ibfk_2` FOREIGN KEY (`id_files`) REFERENCES `files` (`id_files`);

--
-- Contraintes pour la table `to_graduate`
--
ALTER TABLE `to_graduate`
  ADD CONSTRAINT `to_graduate_ibfk_1` FOREIGN KEY (`id_articles`) REFERENCES `articles` (`id_articles`),
  ADD CONSTRAINT `to_graduate_ibfk_2` FOREIGN KEY (`id_users`) REFERENCES `users` (`id_users`),
  ADD CONSTRAINT `to_graduate_ibfk_3` FOREIGN KEY (`id_certificates`) REFERENCES `certificates` (`id_certificates`);

--
-- Contraintes pour la table `to_have`
--
ALTER TABLE `to_have`
  ADD CONSTRAINT `to_have_ibfk_1` FOREIGN KEY (`id_articles`) REFERENCES `articles` (`id_articles`),
  ADD CONSTRAINT `to_have_ibfk_2` FOREIGN KEY (`id_tags`) REFERENCES `tags` (`id_tags`);

--
-- Contraintes pour la table `users`
--
ALTER TABLE `users`
  ADD CONSTRAINT `users_ibfk_1` FOREIGN KEY (`id_role`) REFERENCES `role` (`id_role`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
